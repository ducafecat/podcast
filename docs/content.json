[{"title":"Flutter 创建动画屏幕","date":"2022-01-20T16:00:00.000Z","path":"2022/01/21/2022/create-an-animation-screen-in-flutter/","text":"原文 https://medium.com/@baran.aslankan4/create-an-animation-screen-in-flutter-683d9a534d67 代码https://github.com/ducafecat/getx_quick_start 参考 https://pub.flutter-io.cn/packages/animated_text_kit https://pub.flutter-io.cn/packages/simple_animations https://pub.flutter-io.cn/packages/google_fonts 正文大家好，今天我要向大家展示如何在 Flutter 中创建一个动画屏幕，就像这样; 安装依赖项您可以从 pub.dev 获得依赖项 这些是我在我的项目中使用的版本: 123animated_text_kit: ^4.2.1simple_animations: ^3.1.1google_fonts: ^2.1.0 在获得依赖关系之后，我们在编码之前还有一个步骤。 有一个叫做 Liquid Studio 的应用程序是由 Felix Blaschke 创建的，这个应用程序生成飞镖代码来制作一些动画。 https://felixblaschke.github.io/liquid-studio/#/ 现在是设计部分: 有许多选项和颜色选择，为此我使用了默认设置和颜色。 现在，为了使它动画化，我们需要添加另一个层称为 Plasma。 点击添加图层按钮并选择 Plasma。 现在你可以自定义渐变层和 plasma layers，我为自己做了一些定制。 现在要导出，点击左上角的导出按钮。 单击导出场景以导出所有图层。 现在我们有了彩色动画的代码，我们将在 IDE 中使用这段代码，但在此之前，让我们先创建类结构。 让我们创建一个有状态的小部件并首先返回一个 Scaffold。 现在，我们希望跳过动画页当我们点击屏幕，要做到这一点，我们可以使用 GestureDetector 小部件。 12345678@override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( ), ); &#125; 现在粘贴我们在 liquid studio 中导出的代码，作为 GestureDetector 小部件的子部件。 12345678910111213141516171819202122232425262728293031323334353637383940@override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( child: Container( decoration: BoxDecoration( gradient: LinearGradient( tileMode: TileMode.mirror, begin: Alignment.topRight, end: Alignment.bottomRight, colors: [ Color(0xfff44336), Color(0xff2196f3), ], stops: [ 0, 1, ], ), backgroundBlendMode: BlendMode.srcOver, ), PlasmaRenderer( type: PlasmaType.infinity, particles: 10, color: Color(0x442eaeaa), blur: 0.31, size: 1, speed: 1.86, offset: 0, blendMode: BlendMode.plus, particleType: ParticleType.atlas, variation1: 0, variation2: 0, variation3: 0, rotation: 0, ), ), ), ); &#125; 它应该看起来像这样，现在你会有一个错误，这是因为我们还没有导入简单的动画。 导入类顶部的简单动画库。 1import 'package:simple_animations/simple_animations.dart'; 现在我们的动画颜色已经准备好了，可以点击导航另一个页面，我们将使用 GestureDetector 小部件的点击方法。 在 Container Widget 下，create on tap method 并导航到所需的页面。 123onTap: ()&#123; Navigator.of(context).pushReplacementNamed('/home'); &#125;, 现在，当我们测试代码时，应该是这样的: 现在只剩下一件事情要做，那就是动画文字部分。 在这段代码中，Container 小部件有一个子元素，那就是 plasma 渲染器，plasma 渲染器可以帮助我们创建颜色动画。现在，为了向屏幕添加文本，我们需要向 Container Widget 添加另一个子元素。要添加子元素，我们需要使用 Stack Widget 覆盖所有子元素。 点击 PlasmaRenderer Widget，然后点击点击 Widget 后出现的灯泡。 选择 wrap with Column 选项。 现在我们必须在这里停下来！ 让我告诉你为什么我选择用列选择，它也可以是行。 我们将使用 Stack Widget，这个 Widget 可以帮助我们把 Widget 放在彼此之上，基本上就是叠加 Widget。 但是我为什么要选择专栏呢？ 因为堆栈，列和行窗口小部件没有子窗口，他们有子窗口，如果我选择窗口小部件而不是列，那么我将不得不创建括号和改变子窗口小部件，所以我选择列的原因基本上是为了更快地编码。这一点都不重要，但我只是想提一下 所以我们已经创建了我们的堆栈小部件，其中一个子部件是 PlasmaRenderer，现在我们要添加动画文本作为子部件，但在创建中心小部件之前，让我们在屏幕中央显示文本。 为了获得动画文本，我们需要使用 AnimatedTextKit 小部件，因此我们必须导入库。 123import 'package:animated_text_kit/animated_text_kit.dart';Center( child: AnimatedTextKit( ), ), 在 PlasmaRenderer 之后添加此代码。 获得了一个名为 animatedTexts 的列表，这个列表将包含我们想要在屏幕上显示的所有文本。 在 pub.dev 中，AnimatedTextKit 包中有许多文本动画，我选择了旋转文本，但是您可以尝试不同的动画。 12345animatedTexts: [ RotateAnimatedText('Hello',textStyle: const TextStyle(fontSize: 32,fontWeight: FontWeight.bold,color: Colors.white)), RotateAnimatedText('Animation screen',textStyle: const TextStyle(fontSize: 32,fontWeight: FontWeight.bold,color: Colors.white)), RotateAnimatedText('Click to get started',textStyle: const TextStyle(fontSize: 32,fontWeight: FontWeight.bold,color: Colors.white)), ], 在这里 RotateAnimatedText 采用我们的字符串，你可以添加样式来改变字体大小和粗体，此外你还可以导入谷歌字体和添加一些自定义字体。对于颜色部分，我选择了白色，你可以选择任何你想要的颜色。 现在文本已经完成，但是我们需要一些动画时间的定制。 我们可以使用一些方法来帮助我们定制我们的动画。 totalRepeatCount: 您可以编写希望动画重复的次数 pause: 动画文本之间的暂停时间 12totalRepeatCount: 1,pause: const Duration(milliseconds: 3000), 将这些内容写入 AnimatedTextKit 小部件。 我希望它只执行一次，所以我设置重复计数 1。 Pause 采用 Duration 方法，我将其设置为 3000 毫秒，也就是 3 秒。 整个代码应该是这样的: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@override Widget build(BuildContext context) &#123; return Scaffold( body: GestureDetector( child: Container( decoration: BoxDecoration( gradient: LinearGradient( tileMode: TileMode.mirror, begin: Alignment.topLeft, end: Alignment.bottomRight, colors: [ Color(0xffff1100), Color(0xff008eff), ], stops: [ 0, 1, ], ), backgroundBlendMode: BlendMode.srcOver, ), child: Stack( children:[ PlasmaRenderer( type: PlasmaType.infinity, particles: 10, color: Color(0x442eaeaa), blur: 0.31, size: 1, speed: 1.86, offset: 0, blendMode: BlendMode.plus, particleType: ParticleType.atlas, variation1: 0, variation2: 0, variation3: 0, rotation: 0, ), Center( child: AnimatedTextKit( animatedTexts: [ RotateAnimatedText('Hello',textStyle: const TextStyle(fontSize: 32,fontWeight: FontWeight.bold,color: Colors.white)), RotateAnimatedText('Animation screen',textStyle: const TextStyle(fontSize: 32,fontWeight: FontWeight.bold,color: Colors.white)), RotateAnimatedText('Click to get started',textStyle: const TextStyle(fontSize: 32,fontWeight: FontWeight.bold,color: Colors.white)), ], totalRepeatCount: 1, pause: const Duration(milliseconds: 3000), ), ),], ), ), onTap: ()&#123; Navigator.of(context).pushReplacementNamed('/home'); &#125; ), ); &#125; 您可以自定义您的动画和使用更多的方法或更多的动画文本根据您的口味。 这就是我今天的全部内容，谢谢阅读，希望你喜欢，下次写作时再见，祝你有个愉快的一天; © 猫哥 微信 ducafecat 博客 ducafecat.tech github bilibili 订阅号","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 后台运行代码","date":"2022-01-19T16:00:00.000Z","path":"2022/01/20/2022/flutter-run-code-in-the-background/","text":"原文 https://www.dltlabs.com/blog/flutter-run-code-in-the-background-513940 参考 https://pub.dev/packages/background_fetch 正文今天，我将解释如何在 Flutter 创建一个后台任务。 在此之前，让我们理解什么是后台任务。后台任务是在后台运行的应用程序的辅助进程，即使应用程序没有运行或处于终止状态。 这一功能对于需要在后台执行任务而不需要用户打开应用程序的应用程序来说是有益的ーー例如，每 15 分钟调用 api 获取数据。 让我们在一个示例项目中实现一个后台任务，以便更好地理解这一操作的含义。 步骤: pubspec.yaml 12flutter pub add background_fetchflutter pub get 在 main.dart 文件中导入后台包，并注册 HeadlessTask，以便在应用程序终止后接收 backgroundFetch 事件。 例如: 12345678910111213void backgroundFetchHeadlessTask(HeadlessTask task) async &#123;var taskId = task.taskId;if(taskId == ‘your_task_id’) &#123;print(‘your_task_id’);print(‘[BackgroundFetch] Headless event received.’);_//TODO: perform tasks like — call api, DB and local notification etc…_&#125;&#125;void main() &#123;runApp(MyApp());_//Registering backgroundFetch to receive events after app is terminated.// Requires &#123;stopOnTerminate: false, enableHeadless: true&#125;_BackgroundFetch._registerHeadlessTask_(backgroundFetchHeadlessTask);&#125; 这里我们必须传递一个顶级函数。让我们在 registerHeadlessTask 方法中给它命名为 call back dispatcher。然后我们定义需要在后台运行的任务: 配置 BackgroundFetch12345678910111213141516171819202122232425Future&lt;void&gt; initPlatformState() async &#123;_// Configure BackgroundFetch._var status = await BackgroundFetch._configure_(BackgroundFetchConfig(minimumFetchInterval: 15,forceAlarmManager: false,stopOnTerminate: false,startOnBoot: true,enableHeadless: true,requiresBatteryNotLow: false,requiresCharging: false,requiresStorageNotLow: false,requiresDeviceIdle: false,requiredNetworkType: NetworkType.NONE,), _onBackgroundFetch, _onBackgroundFetchTimeout);print(‘[BackgroundFetch] configure success: $status’);_// Schedule backgroundfetch for the 1st time it will execute with 1000ms delay.// where device must be powered (and delay will be throttled by the OS)._BackgroundFetch.scheduleTask(TaskConfig(taskId: “com.dltlabs.task”,delay: 1000,periodic: false,stopOnTerminate: false,enableHeadless: true));&#125; 调用 initState 中的 initPlatformState 方法并设置 BackgroundFetchConfig 类的配置。换句话说，在传递其他参数的同时，提供注册一次性任务或周期性任务的选项。 在这里，如果存在多个任务，任务 id 可以帮助我们轻松地识别单个任务。输入数据可以是处理任务所需的任何信息。 如果我们希望在应用程序处于终止状态时继续工作，请将 stopOnTerminate 参数的值设置为 false 。如果 stopOnTerminate 设置为 true ，后台服务将在应用程序终止时终止。 1234void _onBackgroundFetchTimeout(String taskId) &#123;print(“[BackgroundFetch] TIMEOUT: $taskId”);BackgroundFetch.finish(taskId);&#125; 当操作系统没有执行后台任务或者任务无法在给定时间内运行时，将调用 onBackgroundFetchTimeout 方法。在这种方法中，我们可以用任务 Id 来处理任务。 123456void _onBackgroundFetch(String taskId) async &#123;if(taskId == ‘your_task_id’) &#123;print(‘[BackgroundFetch] Event received’);//TODO: perform your task like : call the API’s, call the DB and local notification.&#125;&#125; 当后台服务执行事件时，将调用 onBackgroundFetch 方法。在这个方法中，我们将接收任务 id 作为一个参数，它可以用来处理任务。在需要调用 api 将数据保存到数据库或显示本地通知等情况下，这一点非常重要。 默认情况下，调用任务之后的时间间隔的频率为 15 分钟。如果你想把它设置成其他的东西，你也可以在这里做。在 Android 上，后台进程的最小时间间隔为 15 分钟。如果该值小于 15，Android 默认使用 15 分钟。 Also, we must also remember to make changes inside the info.plist and manifest.xml file for both iOS \\&amp; Android. We need to set some of the permissions, and we also need to copy and paste other settings. If you need these settings, you can get them at the following links: Android , OS. 此外，我们还必须记住对 Android IOS 的 info.plist 和 manifest.xml 文件进行更改。我们需要设置一些权限，还需要复制和粘贴其他设置。如果你需要这些设置，你可以通过以下链接获得: IOS , Android。 谢谢你的阅读！ © 猫哥 微信 ducafecat 博客 ducafecat.tech github bilibili 订阅号","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter Convex Bottom 底部导航","date":"2022-01-13T13:00:00.000Z","path":"2022/01/13/2022/convex-bottom-bar-in-flutter/","text":"原文 https://medium.flutterdevs.com/convex-bottom-bar-in-flutter-7158fc642111 代码https://github.com/flutter-devs/convex_bottom_bar_demo 参考 https://pub.dev/packages/convex_bottom_bar 正文 convex Bottom 底部条是一个应用程序 sketch 图，它的形状是 convex Bottom 的。它可以使用户界面看起来很棒，也可以改进用户与界面的交互方式。在本文中，我们将建立一个简单的应用程序与最简单的形式之一，在 Flutter convex Bottom bar 目录: 引言 添加依赖性 如何使用 功能 属性 实施 总结 GitHub 链接 简介:大家好，今天我们要讨论的是一个非常重要的关于 Flutter UI 的话题，这个话题就是底层导航栏。在本文中，我们了解了Convex Bottom Bar。Convex Bottom Bar是一种 Flutter 包装。Convex Bottom 的底部条是一个应用程序栏草图这样的方式，有一个 convex Bottom 状它。它可以使用户界面看起来很棒，也可以改进用户与界面的交互方式。在本文中，我们将构建一个简单的应用程序与最简单的形式之一的Convex Bottom Bar。 查看列表 TabItems 小部件，您可以解释在 appbar 中显示的图标和它们的标题。列表应该只包含奇数的 TabItems 来运行小部件，而不会引起谬误。如果要显示图像或图标，可以为每个 TabItem 小部件中的图标变量提供图像。如果你想生成一个图标底部 appbar，你可以使用 ConvexButton.fab 小部件。它生成的参数更少，并且有一个快速漂亮的单图标 appbar。 添加依赖项:在你的项目中去 pubspec。添加依赖项: 添加 https://pub.dev/packages/convex_bottom_bar 的最新版本。 12345dependencies: flutter: sdk: flutter cupertino_icons: ^1.0.2 convex_bottom_bar: ^3.0.0 我们使用 convax_bottom_bar 来创建一个更好的 bootobar UI。 如何使用:通常， ConvexAppBar 可以通过设置它的 bottomNavigationBar 来与脚手架一起工作。convexAppBar 有两个构造函数，convexAppBar ()将使用 levant 样式简化制表符的创建。将其添加到包的 pubspec.yaml 文件中，使用最新版本。 123Scaffold( body: bottomNavigationBar: ConvexAppBar();); 特点: 提供各种内部款式 可以更改 AppBar 的主题。 提供用于修改新样式的构建器 API。 在选项卡菜单中加入徽章。 优美的过渡动画 提供钩子 API 来覆盖一些内部样式。 RTL 补强 属性: 下面是 _Convex_Bottom_Bar_ 的一些性质: fixed (副标题图标停留在中心) fixedCircle (相同，但在固定图标的所有边上都有一个白色的圆圈) react (上标图标取代点击另一个图标) reactCircle (与上标图标中的白色圆圈相同) textIn (选定的离子出现相应的标题) titled (未选择的图标是显示其标题的单个图标) flip (点击图标显示一个 flip 动画) custom (使用 ConvexBottomAppBar 构建器自定义预定义的参数) height (grabbing the appbar) top (grabbing the superscripted icon) curveSize (拉伸上标图标的曲线) color (设置图标的颜色) backgroundColor (设置 appbar 背景颜色) gradient (使用渐变小部件设置 appbar 背景颜色) activeColor (设置圆形颜色) 实施方案:在 Convex_Bottom_Bar 演示中，首先，我们在这个类中创建一个名为 MyHomePage ()的有状态类，我们创建一个值为 0 的变量 selectedpage 类型的 integer pass。定义一个名为 pageNo 的列表，在这个列表中我们传递要添加到 bootom 导航栏中的所有页面。 12int selectedpage =0;final _pageNo = [Home() , Favorite() , CartPage() , ProfilePage()]; 在 BuildContext ()中，我们定义 Scaffold。 1234appBar: AppBar( centerTitle: true, title: Text('Convex Bottom Bar'),), 首先在正文中传递 _pageno，其值为 selectedPage。使用 scaffold 属性，我们使用 bottomNavigationBar。在这里，我们创建 ConvexAppBar ()并传递 Items、 initialActiveIndex 和 onTap。在条目中，我们通过所有的屏幕，我们希望在我们的应用程序中显示。在 initialActiveIndexwe 中，我们传递已经定义的变量 selectedpage，在 onTap 中，我们传递 index 并在 setState 中定义 setState () ，我们传递 selectedpage 相当于 index。 1234567891011121314bottomNavigationBar: ConvexAppBar( items: [ TabItem(icon: Icons._home_, title: 'Home'), TabItem(icon: Icons._favorite_, title: 'Favorite'), TabItem(icon: Icons._shopping_cart_, title: 'Cart'), TabItem(icon: Icons._person_, title: 'Profile'), ], initialActiveIndex: selectedpage, onTap: (int index)&#123; setState(() &#123; selectedpage = index; &#125;); &#125;,), 如果我们创建不同的页面, Home(), Favorite(), CartPage(), ProfilePage(). 在 Home 类中，我们定义一个带有背景颜色的文本。 Home 主屏幕: 123456789101112131415161718192021222324import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';class Home extends StatefulWidget &#123; const Home(&#123;Key? key&#125;) : super(key: key); @override _HomeState createState() =&gt; _HomeState();&#125;class _HomeState extends State&lt;Home&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Text('Home Page', style: TextStyle( fontSize: 20, fontWeight: FontWeight.bold ),), ), ); &#125;&#125; Favorite 最喜欢的屏幕: 123456789101112131415161718192021222324import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';class Favorite extends StatefulWidget &#123; const Favorite(&#123;Key? key&#125;) : super(key: key); @override _FavoriteState createState() =&gt; _FavoriteState();&#125;class _FavoriteState extends State&lt;Favorite&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors._greenAccent_, body: Center( child: Text('Favorite Page', style: TextStyle( fontSize: 20, fontWeight: FontWeight._bold_ ), )), ); &#125;&#125; CartPage 屏幕: 1234567891011121314151617181920212223import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';class CartPage extends StatefulWidget &#123; const CartPage(&#123;Key? key&#125;) : super(key: key); @override _CartPageState createState() =&gt; _CartPageState();&#125;class _CartPageState extends State&lt;CartPage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors._pink_.shade100, body: Center( child: Text('Cart Page', style: TextStyle( fontSize: 20, fontWeight: FontWeight._bold_ ),)), ); &#125;&#125; _ProfilePage 个人资料页面: 12345678910111213141516171819202122import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';class ProfilePage extends StatefulWidget &#123; const ProfilePage(&#123;Key? key&#125;) : super(key: key); @override _ProfilePageState createState() =&gt; _ProfilePageState();&#125;class _ProfilePageState extends State&lt;ProfilePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors._yellow_, body: Center( child: Text('Profile Page', style: TextStyle( fontSize: 20, fontWeight: FontWeight._bold_ ),)), ); &#125;&#125; 当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 结语:本文介绍了什么是Convex Bottom Bar以及如何在 Flutter 法中实现Convex Bottom Bar。你可以根据自己的需要使用这个包。 如果我做错了什么，请在评论中告诉我，我很乐意改进。 鼓掌如果这篇文章对你有帮助的话。 GitHub Link:https://github.com/flutter-devs/convex_bottom_bar_demo © 猫哥 微信 ducafecat 博客 ducafecat.tech github bilibili 订阅号","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"基于 Riverpod 的 Flutter 状态管理","date":"2022-01-11T16:00:00.000Z","path":"2022/01/12/2022/flutter-state-management-with-riverpod/","text":"原文 https://itnext.io/flutter-state-management-with-riverpod-ef8d4ef77392 代码https://github.com/iisprey/riverpod_example 参考 https://itnext.io/a-minimalist-guide-to-riverpod-4eb24b3386a1 https://pub.dev/packages/state_notifier https://iisprey.medium.com/get-rid-of-all-kind-of-boilerplate-code-with-flutter-hooks-2e17eea06ca0 https://iisprey.medium.com/how-to-handle-complex-json-in-flutter-4982015b4fdf 正文 正如我上周所承诺的，我将向您展示我自己的最终国家管理解决方案路径 Riverpod + StateNotifier + Hooks + FreezedRiverpod 太棒了！但是好的例子并不多。只有最基本的，就这样。这一次，我试图使一个例子既可理解又复杂。我的目的是通过这个例子教你什么时候使用 Riverpod，以及如何使用它。尽管我简化了过程。希望你喜欢！ 动机 在这个例子中我们要做什么？我们只需要从 API 中获取一些数据，然后在 UI 中对它们进行排序和过滤 基本上，我们会; Create simple and complex providers and combine them 创建简单和复杂的提供程序并将它们组合起来 Use AsyncValue object and show async value in the UI using when method 使用 AsyncValue 对象并在 UI 中使用 when 方法显示 async 值 Also, create freezed objects for immutable object solution 同时，为不可变物件/解决方案创建冻结对象 我们开始吧！ 创建 API 服务 注意: 我没有找到一个好的 API 模型来使用过滤功能，因为我自己添加了这些角色。原谅我这么说 123456789101112131415161718final userService = Provider((ref) =&gt; UserService());class UserService &#123; final _dio = Dio(BaseOptions(baseUrl: 'https://reqres.in/api/')); Future&lt;List&lt;User&gt;&gt; getUsers() async &#123; final res = await _dio.get('users'); final List list = res.data['data']; // API didn't have user roles I just added by hand (it looks ugly but never mind) list[0]['role'] = 'normal'; list[1]['role'] = 'normal'; list[2]['role'] = 'normal'; list[3]['role'] = 'admin'; list[4]['role'] = 'admin'; list[5]['role'] = 'normal'; return list.map((e) =&gt; User.fromJson(e)).toList(); &#125;&#125; 使用 freezed 和 json_serializable 创建不可变模型我们只需要创建一个 1234567891011121314151617part 'user.freezed.dart';part 'user.g.dart';@freezedclass User with _$User &#123; @JsonSerializable(fieldRename: FieldRename.snake) const factory User(&#123; required int id, required String email, required String firstName, required String lastName, required String avatar, @JsonKey(unknownEnumValue: Role.normal) required Role role, &#125;) = _User; factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);&#125; 如果你想了解更多关于 freezed 的信息，请查看这篇文章。 https://iisprey.medium.com/how-to-handle-complex-json-in-flutter-4982015b4fdf 从服务中获得 value你可以想想，AsyncValue 是什么? 它只是一个联合类，帮助我们处理我们的值的状态。它提供了一个现成的提供者包。 我将在接下来的文章中详细解释，但就目前而言，仅此而已。 1234567891011121314151617181920final usersProvider = StateNotifierProvider.autoDispose&lt;UserNotifier, AsyncValue&lt;List&lt;User&gt;&gt;&gt;((ref) &#123; return UserNotifier(ref);&#125;);class UserNotifier extends StateNotifier&lt;AsyncValue&lt;List&lt;User&gt;&gt;&gt; &#123; final AutoDisposeStateNotifierProviderRef _ref; late final UserService _service; UserNotifier(this._ref) : super(const AsyncValue.data(&lt;User&gt;[])) &#123; _service = _ref.watch(userService); getUsers(); &#125; Future&lt;void&gt; getUsers() async &#123; state = const AsyncValue.loading(); final res = await AsyncValue.guard(() async =&gt; await _service.getUsers()); state = AsyncValue.data(res.asData!.value); &#125;&#125; 创建排序和过滤器提供程序12345enum Role &#123; none, normal, admin &#125;enum Sort &#123; normal, reversed &#125;final filterProvider = StateProvider.autoDispose&lt;Role&gt;((_) =&gt; Role.none);final sortProvider = StateProvider.autoDispose&lt;Sort&gt;((_) =&gt; Sort.normal); 从提供程序获取获取的列表并进行筛选，然后使用其他提供程序对它们进行排序1234567891011121314151617181920212223242526final filteredAndSortedUsersProvider = Provider.autoDispose.family&lt;List&lt;User&gt;, List&lt;User&gt;&gt;((ref, users) &#123; final filter = ref.watch(filterProvider); final sort = ref.watch(sortProvider); late final List&lt;User&gt; filteredList; switch (filter) &#123; case Role.admin: filteredList = users.where((e) =&gt; e.role == Role.admin).toList(); break; case Role.normal: filteredList = users.where((e) =&gt; e.role == Role.normal).toList(); break; default: filteredList = users; &#125; switch (sort) &#123; case Sort.normal: return filteredList; case Sort.reversed: return filteredList.reversed.toList(); default: return filteredList; &#125;&#125;); 在用户界面中显示所有内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class HomePage extends ConsumerWidget &#123; const HomePage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context, WidgetRef ref) &#123; final users = ref.watch(usersProvider); return Scaffold( appBar: AppBar( centerTitle: true, title: const Text('Users'), ), body: RefreshIndicator( onRefresh: () async =&gt; await ref.refresh(usersProvider), child: users.when( data: (list) &#123; final newList = ref.watch(filteredAndSortedUsersProvider(list)); if (newList.isEmpty) &#123; return const Center(child: Text('There is no user')); &#125; return ListView.builder( itemCount: newList.length, itemBuilder: (_, i) &#123; final user = newList[i]; return ListTile( minVerticalPadding: 25, leading: Image.network(user.avatar), title: Text('$&#123;user.firstName&#125; $&#123;user.lastName&#125;'), trailing: Text(user.role.name), ); &#125;, ); &#125;, error: (_, __) =&gt; const Center(child: Text('err')), loading: () =&gt; const Center(child: CircularProgressIndicator()), ), ), floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat, floatingActionButton: Row( mainAxisSize: MainAxisSize.min, children: [ Expanded( child: Padding( padding: const EdgeInsets.all(8.0), child: Consumer( builder: (_, ref, __) &#123; final sort = ref.watch(sortProvider.state); return ElevatedButton( onPressed: () &#123; if (sort.state == Sort.reversed) &#123; sort.state = Sort.normal; &#125; else &#123; sort.state = Sort.reversed; &#125; &#125;, child: Text( sort.state == Sort.normal ? 'sort reversed' : 'sort normal', ), ); &#125;, ), ), ), Expanded( child: Padding( padding: const EdgeInsets.all(8.0), child: Consumer( builder: (_, ref, __) &#123; final filter = ref.watch(filterProvider.state); return ElevatedButton( onPressed: () &#123; if (filter.state == Role.admin) &#123; filter.state = Role.none; &#125; else &#123; filter.state = Role.admin; &#125; &#125;, child: Text( filter.state == Role.admin ? 'remove filter' : 'filter admins', ), ); &#125;, ), ), ), ], ), ); &#125;&#125; 结束如果你把这个例子看作一个电子商务应用程序，那么这个例子就更有意义了 我不是 riverpod 的宗师。只是学习和分享我的经验，所以请如果你知道一个更好的方式使用 riverpod 请让我们知道！ 示例 Github 项目这是源代码。 https://github.com/iisprey/riverpod_example 谢谢你的阅读 © 猫哥 ducafecat.tech github bilibili 订阅号","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 最好的导航插件","date":"2021-12-28T16:00:00.000Z","path":"2021/12/29/translation/best-nav-bar-packages-for-flutter/","text":"前言一个好的导航对 APP 是很重要的，以下这些导航插件也许对你一开始有帮助。 不过好的体验还是要自己写。 原文 https://tomicriedel.medium.com/best-nav-bar-packages-for-flutter-3ea86aed1e65 正文 Curved Navigation Bar 有了这个包，你可以很容易地创建一个非常漂亮的导航栏，这是一个真正的吸引注意的方式。有一个非常好的动画和许多定制选项，这是一个非常好的扩展为您的下一个应用程序！ Bottom Bar with Sheet是一个普通的底部栏，但是它提供了一个非常有用的功能。有时候你想在屏幕上有更多的空间，但是你是怎么做到的呢？嗯，非常简单: 有了这个导航条，你可以拉出一个“第二屏幕”/表，通过这样做，你得到更多的空间。下面是一个小例子: Convex Bottom Bar使用 Convex Bottom Bar，你可以创建令人印象深刻的底部栏，一定会吸引用户的眼球！ Sliding Clipped Nav Bar提供了一个很好的方式，让你的应用程序对用户来说更有趣。由于其令人难以置信的简单的执行和美丽的设计，它是最好的导航 Pub 包之一。 但是… … 说够了，导航栏和这个包装看起来怎么样？ 我想你很清楚我为什么这么喜欢这个包裹。有这么多的定制可能性和实现非常简单。 Custom Navigation Bar这个导航栏为你提供了一个美丽的动画底部 Pub ，它的灵感来自于一个关于运球的帖子。看看这些美丽的动画吧: Persistent Bottom Navigation Bar使用这个包，你可以创建一个底部导航栏，它可以遍历多个子屏幕: © 猫哥 ducafecat.tech github bilibili 订阅号","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 布局 - 理解约束、布局调试工具","date":"2021-12-22T16:00:00.000Z","path":"2021/12/23/flutter-daily/flutter-understanding-constraints/","text":"前言每个渲染引擎都有一套自己的规则，比如浏览器 html 流式布局，Flutter 里的是约束布局，这是一种科学的设计。 我想引擎设计出来肯定是有考虑，如: 容易学习，快速上手 零配置可用 高容错性（溢出、默认尺寸） 常见场景方案（横向、纵向、滚动、叠加、嵌套、响应式、自适应、浮动、大列表…） 参考经典的约束规则文章 Marcelo Glasberg 撰写，后来被 flutter.dev 收录，掘金也有人翻译。 https://medium.com/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2 https://juejin.cn/post/6846687593745088526 https://docs.flutter.dev/development/ui/layout/constraints 本节目标 理解布局约束原则 掌握调试布局工具 名词，紧约束、松约束、unbounded 视频https://www.bilibili.com/video/BV1X44y177Ns/ 正文 布局的话题展开说，就是各种布局方案+具体组件的使用。 但是约束布局是核心，这也是本文的侧重。 让子元素竟可能的大，撑满父元素1234567891011void main(List&lt;String&gt; args) &#123; runApp(build());&#125;Widget build() &#123; return Container( width: 200, height: 200, color: Colors.amber, );&#125; 确认位置后，按子元素大小显示12345678910111213void main(List&lt;String&gt; args) &#123; runApp(build());&#125;Widget build() &#123; return Center( child: Container( width: 200, height: 200, color: Colors.amber, ), );&#125; 核心规则：Constraints go down. Sizes go up. Positions are set by parents. 上层 widget 向下层 widget 传递约束条件。 下层 widget 向上层 widget 传递大小信息。 上层 widget 决定下层 widget 的位置。 约束布局 1234567891011Widget _buildScaffold() &#123; return Scaffold( body: Column( children: const &lt;Widget&gt;[ Text(\"aaaaaa\"), Text(\"bbbbb\"), Text(\"cccc\"), ], ), );&#125; 宽度 0.0 &lt;= w &lt;= 303.0 , 高度 0.0 &lt;= h &lt;= 523.0 ，就是上层传下来的约束 宽度 w=32.0 , 高度 h=16.0 就是组件向上层传递的大小信息 元素左边 w=7.5，右边 w=7.5，就是上层决定下层的组件位置 紧约束、松约束 紧约束 tight 它的最大/最小宽度是一致的，高度也一样。 松约束 loose 最小宽度/高度为 0 同时是紧约束、松约束 如果最大最小都是 0 1234567891011121314151617Widget _buildScaffold() &#123; return Scaffold( body: ConstrainedBox( constraints: const BoxConstraints( minWidth: 100, minHeight: 100, maxWidth: 150, maxHeight: 150, ), child: Container( width: 10, height: 10, color: Colors.blue, ), ), );&#125; 当宽 150&lt;=w&lt;=150 , 高 150&lt;=h&lt;=150, 最大/最小宽度是一致的情况，称为紧约束 最小宽度/高度为 0 时，称为松约束 有边界 bounded、无边界 unboundedRow Column ListView 这种组件 属于 unbounded 1234567891011121314Widget _buildScaffold() &#123; return Scaffold( body: Column( children: [ const FlutterLogo(size: 50), const FlutterLogo(size: 20), Container( height: 2000, color: Colors.amber, ), ], ), );&#125; 我们可以发现 height unconstrained 不受限制的，这种就是无边界 再看子元素在垂直方向高度是不受限制的 UnconstrainedBox 不受约束UnconstrainedBox 可以不受约束自己控制大小 12345678910111213141516171819Widget _buildScaffold() &#123; return Scaffold( body: ConstrainedBox( constraints: const BoxConstraints( minWidth: 100, minHeight: 100, maxWidth: 150, maxHeight: 150, ), child: UnconstrainedBox( child: Container( width: 10, height: 10, color: Colors.blue, ), ), ), );&#125; 可以发现外部约束是, 宽 100.0 &lt;= w &lt;= 150 , 高 100.0 &lt;= h &lt;= 150 , 但是 UnconstrainedBox 不受约束影响，但是看起来没有左对齐，而是居中了，我们可以通过 Align 来调整位置。 总结今天我们就是把布局很核心的约束、限制规则讲了，大家在布局的时候还是要多思考。 如果你的布局代码写的很复杂，就要去思考重构了。 当然了业务需要是另外一回事，尽量的让布局引擎默认规则来处理，这样兼容性好。 © 猫哥 ducafecat.tech github b 站 https://ducafecat.tech/img/banner-gzh.png","tags":[{"name":"布局","slug":"布局","permalink":"https://blog.ducafecat.tech/tags/布局/"}]},{"title":"最佳的 VS Code Flutter 开发插件","date":"2021-12-20T13:25:31.000Z","path":"2021/12/20/translation/best-vs-code-extensions-for-flutter/","text":"原文 https://itnext.io/best-vs-code-extensions-for-flutter-adcc808c5204 最佳 VS Flutter 代码扩展VS 代码是目前应用最广泛的 Flutter 集成开发环境之一。但是有许多方法可以通过使用 VS 代码的扩展来提高工作效率。 Awesome Flutter SnippetsAwesome Flutter Snippets 是一个常用 Flutter 类和方法的集合。它通过消除与创建小部件相关的大部分样板代码来提高开发速度。通过分别输入快捷键 streamBldr 和 singleChildSV ，可以创建诸如 StreamBuilder 和 SingleChildScrollView 之类的小部件。 Pubspec AssistPubspec Assist 是一个 Visual Studio Code 扩展，它允许您轻松地添加对 Dart 和 Flutter 项目的 Pubspec.yaml 的依赖项，而不需要离开编辑器。 注意: 在 Dart 版本 &gt; 2.5 中，这个功能是默认可用的！ Material Icon ThemeMaterial Icon Theme 主题是一个 Visual Studio 代码扩展，允许你改变你的文件夹和文件图标，并使它们不枯燥！ Dart Data Class Generator DartDart 数据类生成器是一个 Visual Studio 代码扩展，它允许您轻松、快速地创建 Dart 数据类，而且不需要编写样板文件或运行代码生成。 Todo TreeDart 数据类生成器是一个 Visual Studio 代码扩展，这个扩展可以快速搜索 (using [ripgrep](https://github.com/BurntSushi/ripgrep)) 你的工作空间中的评论标签，比如 TODO 和 FIXME，并在浏览器面板的树视图中显示它们。单击树中的 TODO 将打开文件并将光标放在包含 TODO 的行上。 找到的 TODOs 也可以在打开的文件中突出显示。 Better CommentsBetter Comments 是 visualstudiocode 扩展，该扩展将帮助您在代码中创建更加人性化的注释。有了这个扩展，你就可以把你的注释分类为: Alerts Queries TODOs Highlights 注释掉的代码也可以进行样式设置，以清楚地表明代码不应该出现在那里 任何其他你想要的评论样式都可以在设置中指定 Remove Comments删除注释是一个 visualstudio 代码扩展，这个扩展将帮助您立即从代码中删除所有注释！一次性整理和删除你的代码！ Image PreviewImage Preview 是一个 Visual Studio Code 扩展，可以在 gutter 和 hover 中显示要预览的图像。 State Management SnippetsGetX Snippets GetX Snippets 是一个 Visual Studio Code 扩展，用来加速 Flutter 开发应用程序的过程，目标是每个使用 Get 包的人。 Bloc Bloc 是一个 Visual Studio Code 扩展。这个软件包是为了方便实现 BLoC 设计模式(业务逻辑组件)与 Flutter 开发应用程序，目标是每个人使用 bloc 包。 Flutter Riverpod Snippets Flutter Riverpod Snippets 是一个 Visual Studio Code 扩展，它可以提高你使用 Riverpod 的方式。它包含不同代码段的集合，例如 provider。 Provider Flutter Provider Snippets 是一个 Visual Studio Code 扩展，它允许收集使用提供程序时常用的 Flutter 类和方法。它可以加快你的发展速度。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 2.8 发布 新特性速览","date":"2021-12-13T16:00:00.000Z","path":"2021/12/14/flutter-daily/flutter-2-8-news/","text":"视频https://www.bilibili.com/video/bv1sR4y1x758 参考 https://medium.com/flutter/whats-new-in-flutter-2-8-d085b763d181 https://medium.com/flutter/announcing-general-availability-for-the-google-mobile-ads-sdk-for-flutter-574e51ea6783 https://flutter.dev/monetization https://api.flutter-io.cn/flutter/widgets/HtmlElementView-class.html https://pub.flutter-io.cn/packages/webview_flutter 正文性能提升 程序启动 在低端 Android 设备上启动的时间减少了约 50%，高端设备上减少了约 10% 低端 Android 设备的初始帧出现间隔时间最多减少了约 300ms 在低端设备上的启动时间至少减少了 100ms 应用内存 减少了加载前约 40MB 的内存使用 后续的内存占用量进一步减少了约 10% 性能分析 性能跟踪中的新的 流事件让开发人员可以跟踪光栅缓存图片的生命周期 Flutter DevTools新版的 DevTools 添加了一个新的「增强跟踪」功能， 用来帮助开发者诊断消耗较大的构建、布局和绘制操作引起的 UI 卡顿。 启用任何一个追踪功能后，时间轴中将视情况展示 Widget 的构建、RenderObject 布局和 RenderObject 绘制的事件。 此外，新版的 DevTools 增加了应用程序启动性能的分析支持。 该配置文件包含从 Dart VM 初始化到第一个 Flutter 帧渲染的 CPU 样本。 在你按下「Profile app start up」按钮并加载应用程序启动配置文件后， 你将看到为配置文件选择了「AppStartUp」用户标签。 你还可以通过在可用用户标签列表中选择此用户标签过滤器（如果存在）来加载应用程序启动配置文件。 选择此标签会显示你的应用程序启动的个人资料数据。 Web 平台的平台视图 (PlatformView)支持嵌入 HtmlElementView 对象，这真是太好了，我可以嵌入地图、iframe 有待确认。 https://api.flutter-io.cn/flutter/widgets/HtmlElementView-class.html 适用于 Flutter 广告的 Google 广告Google Mobile SDK for Flutter 已于 11 月正式发布 https://medium.com/flutter/announcing-general-availability-for-the-google-mobile-ads-sdk-for-flutter-574e51ea6783 https://flutter.dev/monetization 这很重要哦，你可以收钱了。 WebView 3.0https://pub.flutter-io.cn/packages/webview_flutter 支持使用 POST 和 GET 来加载内容 加载文件或字符串内容为 HTML 支持透明背景 在加载内容前设置 Cookies webview_flutter_web 插件支持 iframe 插入123dependencies: webview_flutter: ^3.0.0 webview_flutter_web: ^0.1.0 # 显式依赖未经认可的插件 官方推荐的插件https://pub.flutter-io.cn/flutter/favorites 路由 新导航 v2 https://pub.flutter-io.cn/packages/beamer https://pub.flutter-io.cn/packages/routemaster https://pub.flutter-io.cn/packages/go_router sqlite 库 drift https://pub.flutter-io.cn/packages/drift freezed model 代码生成器，支持注解 https://pub.flutter-io.cn/packages/freezed dart_code_metrics 代码静态质量检查 https://pub.flutter-io.cn/packages/dart_code_metrics ui 相关库 https://pub.flutter-io.cn/packages/flex_color_scheme https://pub.flutter-io.cn/packages/flutter_svg https://pub.flutter-io.cn/packages/feedback https://pub.flutter-io.cn/packages/toggle_switch https://pub.flutter-io.cn/packages/auto_size_text 特定平台插件开发 通过 pubspec.yaml 配置 https://docs.flutter.dev/development/packages-and-plugins/developing-packages#plugin-platforms 用 dart 写插件 https://docs.flutter.dev/development/packages-and-plugins/developing-packages#dart-only-platform-implementations Dart FFI 现在很成熟了 https://dart.dev/guides/libraries/c-interop Firebasehttp://firebase.flutter.dev/ 所有 FlutterFire 插件都从 beta 阶段升级到稳定阶段 在 DartPad 中为几个 Firebase 服务提供新支持 新的库可以更容易地为身份验证和实时 Firestore 查询构建 UI 新的 Firestore 对象/文档映射用于 Flutter，可在 Alpha 中使用 UI 也升级了 桌面开发 中文、韩文输入支持 Announcing FlutterFire for Desktophttps://invertase.io/blog/announcing-flutterfire-desktop DartPad 切换 flutter 版本 预载入很多包 方便的嵌入你的 gist 代码 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"2021年12月 - Jetbrains Fleet 对比 Vscode","date":"2021-12-08T16:00:00.000Z","path":"2021/12/09/blog/2021-jetbrains-fleet-vs-vscode/","text":"视频https://www.bilibili.com/video/BV11Y411p7Km/ 前言 https://www.jetbrains.com/fleet/ 我已经申请了 fleet 的试用，但是还没收到邮件。 其实还是蛮期待有个免费 ide 能和 vscode 较量下 参考 https://www.jetbrains.com/fleet/ https://www.jetbrains.com/help/fleet/1.0/getting-started.html https://www.youtube.com/watch?v=ow5kdhDa_pk https://betterprogramming.pub/will-jetbrains-fleet-be-a-vscode-killer-89554d1096ae JetBrains 特性快速启动我估计架构还是原来的哪套，就是做了优化，然后界面 UI 也干净点，符合现在审美。 就是快速打开，然后语法高亮 其实现在的机器多核心后 intel11 m1 m1x pro，原来的卡顿感已经不明显了 一键智能老本行了，对 java go paython … 语言就行代码引擎索引 多人协作 远程开发可以连到 Jetbrains Space、远程的机器、Docker 容器、Cloud 云服务 总结与 vscode 比较 彻底的开源 web 浏览器编辑器 插件的丰富程度 如果插件可以 js 写，很多 vscode 也容易转入 Jetbrains Fleet 的目标 让更多人使用 Jetbrains 产品，扩大品牌价值 转化付费，个人、企业用户 感觉远程调试还是一个重点，对我来说还是很有必要的，有的项目一启动就是 30G 内存，有机会下次聊 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter开源项目 - appFlowy 真的是 Notion 的替代品? 一周暴涨 star 9k 多!","date":"2021-12-01T14:20:14.000Z","path":"2021/12/01/flutter-opensource/flutter-opensource-appflowy/","text":"githttps://www.appflowy.io/ https://github.com/AppFlowy-IO/appflowy 也就 1 周 star 9.8k，我以为他是刷的。 目标&amp;特色 目标替代 Notion 数据 100% 自己管理 开源方式提供，你可以自己改 多平台支持 原生体验，估计是用了 flutter 关系 编译运行 git clone 1git clone https://github.com/AppFlowy-IO/appflowy.git 安装 rust 12345678910cd appflowy/frontendmake install_rustsource $HOME/.cargo/envmake install_cargo_makecargo make install_targets 切换 flutter dev 123456flutter channel devorfvm use devfvm global dev flutter 启用 desktop 12345678# for windowsflutter config --enable-windows-desktop# for macosflutter config --enable-macos-desktop# for linuxflutter config --enable-linux-desktop 用 vscode 或者其它 idea 打开 1open appflowy/frontend 代码架构 技术选型 flutter: 多端适配 rust: ffi 平台接口、服务端 flutter 端 frontend/app_flowy 前端业务 rust 层 frontend/rust-lib 共享库 shared-lib shared-lib 后端 rust api backend 参阅技术说明 doc 系统设计说明 doc/APPFLOWY_SYSTEM_DESIGN.md 1234567891011121314151617 Frontend FLowySDK │ ┌─────────┐ │ ┌7─▶│Handler A│ │ │ └─────────┘ │ ┌─────────┐ │ ┌─────────┐┌──────┐ ┌────┐ ┌──────────────┐ │ ┌───▶│Module A │──┼──▶│Handler B││Widget│─1─▶│Bloc│─2─▶│ Repository A │─3─┐ │ │ └─────────┘ │ └─────────┘└──────┘ └────┘ └──────────────┘ │ │ │ │ ┌─────────┐ ┌──────────────┐ │ ┌───────┐ ┌─┴──┐ ┌───────────┐ │ ┌─────────┐ └──▶│Handler C│ │ Repository B │───┼───▶│ Event │─4─▶│FFI │─5──▶│Dispatcher │─6─┼───▶│Module B │ └─────────┘ └──────────────┘ │ └───────┘ └─┬──┘ └───────────┘ │ └─────────┘ ┌──────────────┐ │ │ │ │ Repository C │───┘ │ │ ┌─────────┐ └──────────────┘ │ └───▶│Module C │ │ └─────────┘ │ │ Here are the event flow: User click on the Widget(The user interface) that invokes the Bloc actions Bloc calls the repositories to perform additional operations to handle the actions. Repository offers the functionalities by combining the event, defined in the FlowySDK. Events will be passed in the FlowySDK through the FFI interface. Dispatcher parses the event and generates the specific action scheduled in the FlowySDK runtime. Dispatcher find the event handler declared by the modules. Handler consumes the event and generates the response. The response will be returned to the widget through the FFI. The event flow will be discussed in two parts: the frontend implemented in flutter and the FlowySDK implemented in Rust. linux 编译说明 doc/BUILD_ON_LINUX.md windows 编译说明 doc/BUILD_ON_WINDOWS.md 贡献参与说明 doc/CONTRIBUTING.md DDD 设计说明 doc/DOMAIN_DRIVEN_DESIGN.md 123456789101112131415161718┌──────────────────────────────────────────────────┐ ─────────▶│ Presentation Layer │──┐ Dependency└──────────────────────────────────────────────────┘ │ │ │ ▼ │┌──────────────────────────────────────────────────┐ ││ Application Layer │ │└──────────────────────────────────────────────────┘ │ │ │ ▼ │┌──────────────────────────────────────────────────┐ ││ Domain Layer │◀─┘└──────────────────────────────────────────────────┘ ▲ │┌──────────────────────────────────────────────────┐│ Infrastructure Layer │└──────────────────────────────────────────────────┘ Presentation Layer: Responsible for presenting information to the user and interpreting user commands. Consists of Widgets and also the state of the Widgets. Application Layer: Defines the jobs the software is supposed to do. (Shouldn’t find any UI code or network code) Coordinates the application activity and delegates work to the next layer down. It doesn’t contain any complex business logic but the basic validation on the user input beforepassing to the other layer. Domain Layer: Responsible for representing concepts of the business. Manages the business state or delegated to the infrastructure layer. Self contained and it doesn’t depend on any other layers. Domain should be well isolated from theother layers. Infrastructure Layer: Provides generic technical capabilities that support the higher layers. It deals with APIs, persistence and network, etc. Implements the repository interface and hiding the complexity of the Domain layer. 编辑器 doc/EDITOR.md roadmap https://trello.com/b/NCyXCXXh/appflowy-roadmap 看看本地文件在哪里 找到 sqlite 搜索本地 123find ~ -iname &apos;flowy-database.db&apos;~/Library/Containers/com.appflowy.macos/Data/Documents/flowy/fd3ada7d-7653-4196-90e1-7de0019627bc/flowy-database.db flutter 插件 flutter-quill https://github.com/singerdmx/flutter-quill 富文本编辑器 freezed https://pub.flutter-io.cn/packages/freezed 数据 model 生成器，支持注解方式 flutter_colorpicker https://pub.flutter-io.cn/packages/flutter_colorpicker 颜色选取工具 styled_widget https://pub.flutter-io.cn/packages/styled_widget 简化小组件定义 1234567891011121314Icon(OMIcons.home, color: Colors.white) .padding(all: 10) .decorated(color: Color(0xff7AC1E7), shape: BoxShape.circle) .padding(all: 15) .decorated(color: Color(0xffE8F2F7), shape: BoxShape.circle) .padding(all: 20) .card( elevation: 10, shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(20), ), ) .alignment(Alignment.center) .backgroundColor(Color(0xffEBECF1)); get_it https://pub.flutter-io.cn/packages/get_it 全局访问你的业务对象，你可以拆分业务和 UI 1234567891011121314151617// 定义final getIt = GetIt.instance;void setup() &#123; getIt.registerSingleton&lt;AppModel&gt;(AppModel());// Alternatively you could write it if you don't like global variables GetIt.I.registerSingleton&lt;AppModel&gt;(AppModel());&#125;// 使用MaterialButton( child: Text(\"Update\"), onPressed: getIt&lt;AppModel&gt;().update // given that your AppModel has a method update), 总结 看到人家的架构，感觉自己弱爆了，我还是先领域分层设计做做干净 flutter bloc , rust ffi web protobuf 感觉还是成熟的选择 如果持续更新的话，我也很想看看架构的演变 现阶段估计还是在测试架构设计，应该不会上很多功能 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 19 布局规则 紧约束、松约束、无边界","date":"2021-11-23T16:00:00.000Z","path":"2021/11/24/flutter/flutter-19-layout-rule/","text":"目标 掌握 Flutter 布局规则 掌握常见布局方式 学会调试技巧 视频参考 https://docs.flutter.dev/development/ui/layout/constraints https://flutter.cn/docs/development/ui/layout/constraints https://github.com/marcglasberg/flutter_layout_article https://docs.flutter.dev/development/ui/layout/box-constraints https://flutter.cn/docs/development/ui/layout/box-constraints 正文 1. 名称解释1.1 紧约束 tight 、松约束 loose 官方解释 A tight constraint offers a single possibility, an exact size. In other words, a tight constraint has its maximum width equal to its minimum width; and has its maximum height equal to its minimum height. A loose constraint, on the other hand, sets the maximum width and height, but lets the widget be as small as it wants. In other words, a loose constraint has a minimum width and height both equal to zero: 紧约束 tight 它的最大/最小宽度是一致的，高度也一样。 松约束 loose 最小宽度/高度为 0 同时是紧约束、松约束 如果最大最小都是 0 有边界 bounded、无边界 unbounded大部分组件都是有界 bounded 有些组件假装自己没有边界 unbounded ，如 listView row column 这种 2. 布局原则2.1 组件大小与位置 只有一个组件的时候占满全屏 https://dartpad.dev/926a55893c9284a85831f857b6004ccf 子元素不指定位置，填充父元素尺寸 https://dartpad.dev/75eaf5a64d96e35fa887946bb8f6185b Scaffold body 默认左上对齐 https://dartpad.dev/802b6a69388b2c881361be26c9eb2736 2.2 约束盒子、紧约束、松约束 向下传递约束，向上传递尺寸 https://dartpad.dev/a49dd136dedda0f3ba06d59f00901d0d 通过 BoxConstraints 向下传递约束 BoxConstraints.loosen 松约束 BoxConstraints.tightFor 紧约束 https://dartpad.dev/5d495e039d84aa4789960f5fd4763700 通过 SizeBox 向下传递约束 SizedBox.expand 最大尺寸 https://dartpad.dev/9c6a5bd2a751727b4318a1c9db4f417a 2.3 Column Row ListView 都是无边界 unbounded 组件 Row Column 大小由子元素最大尺寸决定, 主轴方向 unbounded 不限制约束 https://dartpad.dev/2ccab9b37a26b91efb87c249ecff81f8 Expand Flex 按比例调整尺寸 https://dartpad.dev/2b83cb698dc732d1a60ddd107b2a6152 2.4 Stack 布局规则 最大尺寸匹配最大的子元素 https://dartpad.dev/918da13543e31dc570576cd24be7cbcc 元素分为有位置、无位置 最大尺寸优先匹配有位置元素 当只有一个 Positioned 时，Stack 将会占满整个父元素 通过 fit: StackFit.passthrough 属性可以调整父组件传递过来的约束规则 https://dartpad.dev/1f39b5557f8cd693327de6a1d4efb6fb 元素溢出裁剪 clipBehavior: Clip.hardEdge 元素溢出点击事件无效 https://dartpad.dev/0cc1ab3e157775b4f9633105d9bf32fb 总结尽量让你的布局代码精简适配布局原则，而不是写了很繁琐，越复杂约容易出错，当然业务层面还是需要去拆分成业务组件的各种组合。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter 修正你的 dart damn syntax 语法","date":"2021-11-08T16:00:00.000Z","path":"2021/11/09/translation/fix-your-dart-damn-syntax/","text":"原文 https://itnext.io/fix-your-dart-damn-syntax-b3d3474373bd 参考 https://dart.dev/guides/language/effective-dart https://dart.dev/guides/language/effective-dart/style https://dart-lang.github.io/linter/lints/index.html 正文当我检查其他项目的时候，有些事情经常困扰着我，那就是我们大多数人不遵守 Dart 语法规则 我知道你可能来自另一种语言背景，但是你现在使用的是 Dart，而 Dart 做的有些不同。 实际上，Dart 文档完美地解释了一切，但是我们大多数人都懒得阅读整个文档。所以我决定为我们的懒虫们写一个总结。 希望你能从中受益！ 文件夹/档案1234lower_snake_caseNOTFolderNamefileNamefile-name 类1UpperCamelCase 函数1lowerCamelCase 变量1lowerCamelCase extensions 扩展1UpperCamelCase mixins 混合1UpperCamelCase constants 常量123CAPITALIZE_EVERY_DAMN_LETTER // NOlowerCamelCase // yes enums 枚举123enum Name &#123; ENUM, NAME &#125; // WRONG!!enum Name &#123; enum, name &#125; // RIGHT!! 对于未使用的回调参数常量名，最好使用 _ __12345// IF YOU WON'T USE DON'T MENTION ITfutureOfVoid.then((unusedParameter) =&gt; print('Operation complete.'));futureOfVoid.then((_) =&gt; print('Operation complete.')); 更喜欢使用字符串模板来组合字符串和值12345// GOOD BOY'Hello, $name! You are $&#123;year - birth&#125; years old.';// BAD BOY'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...'; 避免使用不必要的 getters 和 setters12345678910111213// GOODclass Box &#123; var contents;&#125;// BADclass Box &#123; var _contents; get contents =&gt; _contents; set contents(value) &#123; _contents = value; &#125;&#125; 尽可能的写上类型定义12345678910add(a,b) =&gt; a + b; // DAMN WRONGint add(int a, int b) =&gt; a + b; // HELL YEAHBUTfinal List&lt;String&gt; users = &lt;String&gt;[]; // THAT'S OVERKILLfinal List&lt;String&gt; users = []; // GREATfinal users = &lt;String&gt;[]; // WONDERFUL new 可以不要用了12345// I'm old dudenew Container();// I'm a brand new energetic open-minded sexy young dudeContainer(); 对不起，如果我有点咄咄逼人，但请立即修复您的代码，否则我会找到你。此外，我想如果我遇到新的沉船时间增加更多的提示，所以请小心。 谢谢你的阅读 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 6 个建议改善你的代码结构","date":"2021-11-07T22:00:00.000Z","path":"2021/11/08/translation/5-flutter-tips-for-better-code-structure/","text":"原文 https://itnext.io/5-flutter-tips-for-better-code-structure-fa514845a903 正文1. 将 init 操作与 main 函数分离，使其更加清晰 2. 你可以简单地管理这样的 GetX 路由，而不需要任何麻烦 用法 1Get.toNamed(Routes.login); 怎么做 3. 你也可以在一个地方管理你的样式风格 用法 12345// S stands for StylesS.colors.redS.textStyles.f10MediumS.shadows.softShadow 怎么做 4. 像 boss 一样管理你的资源 用法 12345// R stands for Resources// AnimationsR.anims.loading// SVG imagesR.icons.logo// `magesR.images. 怎么做 5. 集中管理你的常量 用法 12345// C stands for ConstantsC.titleC.namesC.descp 怎么做 6. 建立你的工具类 utils，我们在一个地方使用所有的时间 用法 12345Utils.formatDate(date,locale);Utils.formatters.onlyTwoDecimalDigits;Utils.show.dialog(); 怎么做 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 保护你的APP数据安全","date":"2021-11-03T16:00:00.000Z","path":"2021/11/04/translation/securing-flutter-apps/","text":"原文 https://medium.com/@mohammadEzzo/securing-flutter-apps-3cd1aedda088 参考 https://www.guardsquare.com/en/blog/iOS-SSL-certificate-pinning-bypassing https://www.freecodecamp.org/news/openssl-command-cheatsheet-b441be1e8c4a/ https://www.freecodecamp.org/news/what-is-tls-transport-layer-security-encryption-explained-in-plain-english/ 正文 目前，大多数应用程序都包含支付或存储一些重要的个人数据，这增加了数据被攻击者利用或暴露的风险。 在这篇文章中，我将谈论最有效的做法，以尽量减少 Flutter 应用程序中任何安全漏洞的风险，并设置尽可能多的路障，以任何攻击者的方式。当然，这并不能保证你的应用程序是 100% 安全的。 让我们开始保护通信层 https://www.guardsquare.com/en/blog/ios-ssl-certificate-pinning-bypassing 当攻击者锁定一个应用程序时，首先要做的事情之一就是查看他们是否 能拦截在应用程序和服务器后端之间传递的任何数据 。 1- 采用高度加密:您可以通过使用 SSL 和 TLS 等协议来实现这一点，这些协议很容易添加到您的代码中，并且很难妥协。 如果您正在处理特别敏感的数据，您甚至可能需要更进一步，在应用程序中构建一个类似 vpn 的解决方案。 2- 限制网络流量将网络流量或连接限制到不安全端点的一种方法是显式地将域名列为白名单。 要做到这一点，在 flutter 应用程序，我们需要为每个平台做一些步骤: android : go to the android folder and create this file under 进入 android 文件夹，创建下面的文件 1res/xml/network_security_config.xml 然后复制这个并将其添加到创建的 xml 文件中: 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;network-security-config&gt; &lt;domain-config&gt; &lt;domain includeSubdomains=\"true\"&gt;YOURDOMAIN.com&lt;/domain&gt; &lt;trust-anchors&gt; &lt;certificates src=\"@raw/YOURCERTIFICATE\"/&gt; &lt;/trust-anchors&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; for ios: add this to the info.plist file: 把这个添加到 info.plist 文件: 123456789101112131415&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;YOURDOMAIN.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 然后用你的服务器域名替换 YOURDOMAIN.com 。 这样做将确保您的应用程序不被允许与任何其他域通信。 3- 认可证书SSL pinning 解决了 MITM (Man In The Middle)攻击。 怎么做到的？ 在简单的语言中，您将从后端开发人员获得一个服务器证书文件，并将证书钉在每个 API 调用中。因此，HTTP 客户端将把这个证书作为一个可信赖的证书。现在，如果出现了 MITM，并且应用程序得到了一些错误的证书，那么由于握手错误，API 调用将被中断。 所以让我们实现这个 Flutter : 最有可能的证书延长将是。“.cef” 但是这个扩展在 flutter 中不可读，所以我们需要将其转换为 “.pem” 使用这个命令。 1_openssl x509 -inform der -in_ Certificate_.cer -out_ Certificate_.pem_ 证书是您可以自己使用的文件名。 然后将证书作为资产添加到 pubspec.yaml。 现在使用 Dio 包，我们可以管理应用程序中的所有请求: 1234567final dio = Dio(); ByteData bytes = await rootBundle.load('assets/Certificate.pem');(dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) &#123; SecurityContext sc = SecurityContext(); sc.setTrustedCertificatesBytes(bytes.buffer.asUint8List()); HttpClient httpClient = HttpClient(context: sc); return httpClient;&#125;; 在这段代码中，我们从资产中读取证书，并将其作为可信证书添加到 dio 实例的 http 客户端。 现在，当使用这个 dio 实例向另一个服务器发出任何请求时，由于服务器的证书无效，我们将得到一个握手错误。 4-使身份认证刀枪不入除了你的应用程序的数据流，下一个最常见的攻击载体是它的认证方法的任何弱点。 因此，与服务器进行双因素身份验证是必要的，也是值得实现的。 除此之外，你还需要注意如何处理像钥匙交换这样的事情。至少，您应该使用加密来保证这些事务的安全。 到目前为止，我们已经尽力保护与服务器的传输层。 现在我们开始保护应用本身。 保护申请 基本了解 Android app. Source — Pranay Airan. 1- 模糊编码编译后的二进制文件和应用程序的代码可以被逆向设计。可以公开的内容包括字符串、方法和类名以及 API 键。这些数据要么是原始形式，要么是纯文本形式。 你可以做的是使用 --obfuscate 参数时，建立您的 apk。 1flutter build appbundle --obfuscate --split-debug-info=/&lt;directory&gt; 从本土的角度来说，你需要通过以下方式来处理这个问题: android 在 /android/app/build.gradle 文件中，添加以下内容: 1234567891011android &#123; ... buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled true useProguard true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 在 /android/app/proguard-rules.pro 中创建一个 ProGuard 配置文件: 1234567# Flutter-keep class io.flutter.app. &#123; *; &#125;-keep class io.flutter.plugin. &#123; *; &#125;-keep class io.flutter.util. &#123; *; &#125;-keep class io.flutter.view. &#123; *; &#125;-keep class io.flutter. &#123; *; &#125;-keep class io.flutter.plugins. &#123; *; &#125; 使用 ProGuard，它不仅可以模糊你的代码，还可以帮助你缩小 Android 应用程序的大小。 iOS 如果你使用 Objective-C 或 Swift 来编译 iOS，编译器会去掉这些符号并对你的代码进行优化，这就使得攻击者很难读取你的代码的编译输出。 还有一些付费工具可以帮助你模糊代码: iXGuard 和 Vermatrix. 2- 越狱和植根设备越狱的 iOS 和安卓设备有更多的特权，可能会给用户的设备带来恶意软件，从而绕过设备的正常运行。 flutter_jailbreak_detection 是一个软件包，它可以帮助你检测你的应用是否正在一个越狱或根植的设备上运行, 它在 Android 上使用 RootBeer on Android, and DTTJailbreakDetection ，在 iOS 上使用 DTTJailbreakDetection 。 而且很容易使用: 1234import 'package:flutter_jailbreak_detection/flutter_jailbreak_detection.dart';bool jailbroken = await FlutterJailbreakDetection.jailbroken;bool developerMode = await FlutterJailbreakDetection.developerMode; _// android only._ https://pub.dev/packages/flutter_jailbreak_detection 3-保护用户资料为了存储敏感的用户数据，你不应该使用共享首选项或 sqflite，因为它很容易在任何设备上打开，因为你需要对存储的数据进行加密，你可以使用 flutter_secure_storage 。 https://pub.dev/packages/flutter_secure_storage 这个软件包使用了 Android 的 Keystore 和 iOS 的 Keychains。 还值得设置一个周期性时间，以便自动清除过期的数据缓存。 4. 使用本地身份验证假设用户手机被盗，并且您的应用程序已经安装在手机上，并且它有一些支付信息:) 为了防止任何访问您的应用程序，您应该使用生物特征识别认证使用此软件包。 https://pub.dev/packages/local_auth 5- 背景快拍预防当一个应用程序被背景化时，操作系统会获取任务切换器中最后一个可见状态的快照。因此，防止后台快照捕捉到账户余额和付款细节是非常需要的。 用这个 secure_application 包就能解决这个问题 https://pub.dev/packages/secure_application 他的插件允许你保护你的应用程序内容不被点击查看。 总结最终，作为一个开发人员，这就是所有人对你的要求。 我还想提到“如何保护您的 Flutter 应用程序?” 是移动应用程序开发者在求职面试中最常见的问题，所以我希望这将是有用的。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 下载文件操作","date":"2021-11-02T16:00:00.000Z","path":"2021/11/03/translation/downloading-a-file-in-flutter/","text":"原文 https://medium.com/halkbank-mobile-tech/downloading-a-file-in-flutter-d6762825c0a4 代码https://github.com/deremakif/FlowderSample 参考 https://pub.dev/packages/path_provider https://pub.dev/packages/flutter_downloader https://pub.dev/packages/flowder https://pub.dev/packages/open_file https://pub.dev/packages/percent_indicator 正文今天我要写一篇关于 flowder package 的文章。我用它从服务器上下载文件。有很多方法可以做到这一点，而且还有更受欢迎的软件包如 flutter_downloader 。但我更喜欢 flowder 软件包，因为它的实现很简单。 首先，如果下载文件夹不存在，我们应该创建它。要做到这一点，我们需要导入 path_provider package。并在当前页的 initState() 中调用 initPlatformState 方法。 12345678910111213Future&lt;void&gt; initPlatformState() async &#123; _setPath(); if (!mounted) return;&#125;void _setPath() async &#123; Directory _path = await getApplicationDocumentsDirectory(); String _localPath = _path.path + Platform.pathSeparator + 'Download'; final savedDir = Directory(_localPath); bool hasExisted = await savedDir.exists(); if (!hasExisted) &#123; savedDir.create(); &#125; path = _localPath;&#125; 现在，我们有下载文件夹来保存文件。包的下载方法需要两个参数: URL 和选项。您可以根据需要自定义选项。 123456789101112131415161718ElevatedButton( onPressed: () async &#123; options = DownloaderUtils( progressCallback: (current, total) &#123; final progress = (current / total) * 100; print('Downloading: $progress'); &#125;, file: File('$path/loremipsum.pdf'), progress: ProgressImplementation(), onDone: () &#123; OpenFile.open('$path/loremipsum.pdf'); &#125;, deleteOnCancel: true, ); core = await Flowder.download( \"https://assets.website-files.com/603d0d2db8ec32ba7d44fffe/603d0e327eb2748c8ab1053f_loremipsum.pdf\", options, );&#125;, 我使用 OpenFile package 包在文件完成下载过程时打开它。我还使用了 percent_indicator package 包来显示进展。 如果以后不需要使用该文件，可以在关闭文档后删除该文件。重要的是不要增加应用程序的大小。 1234OpenFile.open('$path/loremipsum.pdf').then((value) &#123; File f = File('$path/loremipsum.pdf'); f.delete();&#125;); 应用程序演示 示例项目的源代码。 GitHub - deremakif/FlowderSamplehttps://github.com/deremakif/FlowderSample © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 到底能不能做 APP， GetX 能实战么，我上架了一款APP Helber","date":"2021-10-25T16:00:00.000Z","path":"2021/10/26/translation/my-app-helber-v2/","text":"前言群里有不少新加入的朋友，大家会有一个疑惑，就是 Flutter 做 app 到底靠谱么。 还有这个 GetX 实战中的表现如何，是否有大坑。 我这边上架了一款产品 helber。 官方https://helberapp.com/ 苹果店https://apps.apple.com/app/id1533390110 谷歌店https://play.google.com/store/apps/details?id=com.zykj.qubang 应用的业务是按地理位置社交互助。 虽然是全球可用，但是主打的还是北美，服务器也是西雅图。 欢迎加微信技术内测讨论 ducafecat，备注 helber 用到的组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# The following adds the Cupertino Icons font to your application.# Use with the CupertinoIcons class for iOS style icons.cupertino_icons: ^1.0.2get: ^4.3.6dio: ^4.0.0# 权限permission_handler: ^8.1.2# app信息package_info: ^2.0.2# 本地存储shared_preferences: ^2.0.8# 刷新加载pull_to_refresh: ^2.0.0# toast 提示flutter_easyloading: ^3.0.3# 底部弹出框modal_bottom_sheet: ^2.0.0# 输入框pinput: ^1.2.0# 适配屏幕flutter_screenutil: ^5.0.0+2# 网络图片cached_network_image: ^3.1.0# 媒体选择wechat_assets_picker: ^6.0.4wechat_camera_picker: ^2.4.1# 滑块carousel_slider: ^4.0.0# svgflutter_svg: ^0.22.0# 瀑布流waterfall_flow: ^3.0.1# 加密crypto: ^3.0.1# OSSaliyun_oss_flutter: ^1.0.5# 视频图片压缩video_compress: ^3.1.0flutter_image_compress: ^1.1.0# 图片预览photo_view: ^0.12.0# 视频播放chewie: ^1.2.2video_player: ^2.2.5# 选择# flutter_cupertino_datetime_picker: ^2.0.1flutter_picker: ^2.0.2# 时间转换intl: ^0.17.0# 定位geolocator: ^7.6.2# 地图google_maps_flutter: ^2.0.11google_maps_cluster_manager: ^3.0.0+1# 缓存flutter_cache_manager: ^3.1.2# webkitwebview_flutter: ^2.0.12# 打开urlurl_launcher: ^6.0.12# 升级r_upgrade: ^0.3.5version: ^2.0.0# app 打开 uriuni_links: ^0.5.1# IMtencent_im_sdk_plugin: ^3.5.0# 腾讯推送tpns_flutter_plugin: git: url: https://gitee.com/ducafecat/TPNS-Flutter-Plugin# google signgoogle_sign_in: ^5.1.1# apple signsign_in_with_apple: ^3.2.0# facebook signflutter_facebook_auth: ^3.5.2# sentrysentry_flutter: ^6.0.1# 头部背景# draggable_home: ^1.0.2# 第三方登录按钮auth_buttons: ^1.0.1+4# 倒计时timer_count_down: ^2.2.0 项目规模页数: 40~50 业务 社交信息 积分系统 商品兑换 商家端 技术点 地理定位 长列表 拍照、拍视频 阿里 oss 图片缓存 图片预览 缩率图 腾讯聊天 腾讯消息推送 TPNS pin 安全 数据离线 三方登录 谷歌、苹果、facebook 性能测试 帧率 性能图层 CPU 总结这个项目前端我架构的，业务代码都是我的伙伴完成的。 没有做特别的优化，基本上就是依赖框架，对 卡 IO、拉取包多次请求、列表数据缓存 等都没有做优化（跑通务第一位）。 就是这样也能看到性能还是可以的 平均帧数 59/秒，cpu、内存 也还可以。 个别动画卡帧数，要想性能好，还是要自己动手，这就是后面的事情了。 本来想录视频说的，但是各种原因（带娃），我之后找时间吧。 这个项目还没正式对外推，计划是 2 周后。 欢迎加微信技术内测讨论 ducafecat，备注 helber，如果你也生活在北美那就更好了。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 模式对话框","date":"2021-10-24T16:00:00.000Z","path":"2021/10/25/translation/how-to-display-the-modal-bottom-sheet-programmatically-in-flutter/","text":"原文 https://betterprogramming.pub/how-to-display-the-modal-bottom-sheet-programmatically-in-flutter-d1fad5fdd462 代码https://github.com/macro6461/flutter_to_do 参考 https://stackoverflow.com/questions/69471054/unable-to-reflect-updated-parent-state-in-showmodalbottomsheet https://stackoverflow.com/questions/69486752/trigger-floatingactionbutton-onpressed-without-pressing-the-button https://stackoverflow.com/users/1647098/eimmer 正文如果你是从我以前的帖子来的，你看到我启动了我的待办事项应用程序，解决了我状态更新时不能用 [showModalBottomSheet](https://api.flutter.dev/flutter/material/showModalBottomSheet.html) 方法更新 NewToDo 的问题。 在 Stack Overflow 上问了一个问题之后，我终于可以把我的 NewToDo 小部件放到 showModalBottomSheet 中了。这样，NewToDo 小部件只有在我单击 FloatingActionButton 时才可见，而不是必须一直可见。 然而，在实现这个目标后不久，我注意到我的应用程序中还有一个问题。 当我选择要编辑的 ToDo 项目时，我希望能够重用我的 NewToDo。我认为这是有意义的，因为它是同样的两个输入，可以用来改变相同的两个状态值，title 和 content。 问题是什么？ 除了在我的 FloatingActionButton 小部件(绿色圆圈)的 onPressed 方法之外，我无法在任何地方执行 showModalBottomSheet (绿色箭头)。 我需要能够触发 onPressed 方法，每当我点击编辑标题 ElevatedButton 小部件(红色圆圈标记) ，每个 ToDo 项目。 我考虑了如何找到一种方法来模拟 onPressed 事件，以便执行 showmodbottomsheet 回调。 由于无法模拟 onPressed 事件(and frustrated) ，我带着 Stack Overflow 去看看是否有其他人对如何实现我所寻找的目标有任何想法。 过了一会儿，我得到了答案。我松了一口气… … 也谦卑起来。 如此简单… 如此纯洁 我采纳了 eimmer’s 的建议，没有把我的 showModalBottomSheet 放在 onPressed 方法中，而是把它分解成了它自己的函数 renderShowModal。参见下文: 123456789101112_renderShowModal()&#123; return showModalBottomSheet&lt;void&gt;( context: context, builder: (BuildContext context) &#123; return ValueListenableBuilder( valueListenable: titleController, builder: (context, _content, child) &#123; return NewToDo(titleController, contentController, _addTodo, _clear, _todo); &#125;); &#125;, );&#125; 这样做之后，我就可以重写我的 onPressed 方法了。 1onPressed: _renderShowModal, 现在我们已经把我们的 showModalBottomSheet 放在单独的函数中，让我们看看它是否工作: 太棒了！我们现在需要做的就是在 editTodo 函数的末尾调用相同的函数，当你点击编辑 EelevatedButton 时，这个函数就会被调用。 12345678910void _editTodo(ToDo todoitem)&#123; setState(() &#123; _todo = todoitem; content = todoitem.content; title = todoitem.title; &#125;); contentController.text = todoitem.content; titleController.text = todoitem.title; _renderShowModal();&#125; 现在让我们看看当我们单击 ToDo 项目旁边的 edit 时它是否工作。 Viola! 维奥拉 我们现在可以使用 NewToDo 来创建新的 ToDo 项目和编辑现有的 ToDo 项目。 通过将 showModalBottomSheet 包装在一个单独的函数中，我们可以通过调用 renderShowModal，让我们的应用程序在任何时候都可以呈现 NewToDo invoking _renderShowModal。 这个应用的所有代码都在 GitHub 上。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 的加密和解密数据","date":"2021-10-17T16:00:00.000Z","path":"2021/10/18/translation/explore-encrypt-decrypt-data-in-flutter/","text":"原文 https://medium.com/flutterdevs/explore-encrypt-decrypt-data-in-flutter-576425347439 参考 https://pub.flutter-io.cn/packages/encrypt 正文了解如何加密和解密数据在您的 Flutter 应用程序 Flutter 是一个可移植的 UI 工具包。换句话说，它是一个全面的应用软件开发工具包(SDK) ，包括小部件和工具。Flutter 是一个免费的开源工具，用于开发移动、桌面和 web 应用程序。 Flutter 是一种跨平台的开发工具。这意味着用同样的代码，我们可以同时创建 IOs 和 Android 应用程序。这是在整个过程中节省时间和资源的最佳方式。在这方面，hot reload 正在获得移动开发者的支持。允许我们通过热重装快速查看在代码中实现的更改。 在本文中，我们将探讨使用加密包 Flutter 加密和解密数据文件。借助于这个软件包，用户可以轻松地加密和解密数据。那么让我们开始吧。 加密是将数据转换为编码(密码)数据形式的过程。如果任何未经授权的个人或实体获得访问权限，他们将无法读取。在发送文件之前，有必要将文件保护到每个移动应用程序或网站上，并在网络上传递数据，以防止未经授权的接收者访问其数据。它有助于保护私有和敏感信息，并可以提高客户端应用程序和服务器之间通信的安全性。 解密是将已编码的数据从后台转换为正常(普通)数据形式的过程。在这篇文章中，我们将展示如何加密输入数据，然后将其解密回正常形式。 演示模块: 加密数据类型: 我们将看到 3 种不同类型的算法加密和解密数据的 Flutter 。 1- AES 算法 : (高级加密标准)已经成为世界各地政府、金融机构和安全意识强的企业的首选加密算法。美国国家安全局(NSC)使用它来保护国家的“最高机密”信息。 2- Fernet 算法: Fernet 是一种非对称加密方法，它可以确保加密的消息在没有密钥的情况下不能被操纵/读取。它对密钥使用 url 安全编码。Fernet 还在 CBC 模式和 PKCS7 填充中使用 128 位 AES，HMAC 使用 SHA256 进行身份验证。这个 IV 是由 os 创建的。随机()。所有这些都是好的软件所需要的。 3- Salsa 算法 : Salsa20 是提交给 eSTREAM 项目的一个密码，运行时间从 2004 年到 2008 年，该项目旨在促进流密码的发展。该算法被认为是一种设计良好的高效算法。目前还没有任何针对 Salsa20 密码家族的已知有效攻击。 代码步骤:让我们从代码实现开始。要实现以下项目，你需要集成到您的 Flutter 应用程序的加密包。 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 encrypt: ^ 5.0.1 现在在你的 Dart 代码中，你可以使用以下导入这个包。 1import 'package:crypto/crypto.dart'; 步骤 2: 我创建了一个 dart 文件来定义 AES、 Fernet 和 Salsa 算法。 这个文件有两种方法，用 AES 算法加密和解密数据。 123456789101112131415161718192021class EncryptData&#123;_//for AES Algorithms_ static Encrypted? _encrypted_; static var _decrypted_; static _encryptAES_(plainText)&#123; final key = Key.fromUtf8('my 32 length key................'); final iv = IV.fromLength(16); final encrypter = Encrypter(AES(key)); _encrypted_ = encrypter.encrypt(plainText, iv: iv); print(_encrypted_!.base64); &#125; static _decryptAES_(plainText)&#123; final key = Key.fromUtf8('my 32 length key................'); final iv = IV.fromLength(16); final encrypter = Encrypter(AES(key)); _decrypted_ = encrypter.decrypt(_encrypted_!, iv: iv); print(_decrypted_); &#125;&#125; 这个文件有 2 个方法加密和解密数据使用萨尔萨算法。 123456789101112131415161718192021_//for Fernet Algorithms_static Encrypted? _fernetEncrypted_;static var _fernetDecrypted_; static _encryptFernet_(plainText)&#123; final key = Key.fromUtf8('my32lengthsupersecretnooneknows1'); final iv = IV.fromLength(16); final b64key = Key.fromUtf8(base64Url.encode(key.bytes)); final fernet = Fernet(b64key); final encrypter = Encrypter(fernet); _fernetEncrypted_ = encrypter.encrypt(plainText); print(_fernetEncrypted_!.base64); _// random cipher text_ print(fernet.extractTimestamp(_fernetEncrypted_!.bytes)); &#125; static _decryptFernet_(plainText)&#123; final key = Key.fromUtf8('my32lengthsupersecretnooneknows1'); final iv = IV.fromLength(16); final b64key = Key.fromUtf8(base64Url.encode(key.bytes)); final fernet = Fernet(b64key); final encrypter = Encrypter(fernet); _fernetDecrypted_ = encrypter.decrypt(_fernetEncrypted_!); print(_fernetDecrypted_); &#125; 步骤 3: 现在终于在主屏幕 Dart 文件中调用上面的方法。 在这个文件中，我已经设计了一个卡，1 个文本字段和 2 个按钮，2 个文本视图显示加密和解密的结果。下面是截图和代码片段。 全部代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import 'package:encrypt_data_demo/encrypt_data.dart';import 'package:flutter/material.dart';class HomeView extends StatefulWidget &#123; @override _HomeViewState createState() =&gt; _HomeViewState();&#125;class _HomeViewState extends State&lt;HomeView&gt; &#123; TextEditingController? _controller=TextEditingController(); @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors._orange_, appBar: AppBar( title: Text(\"Encrypt and Decrypt Data\"), ), body: SingleChildScrollView( child: Container( margin: EdgeInsets.only(top:10,bottom: 10), child: _buildBody(), ), ), ); &#125; Widget _buildBody() &#123; return Container( height: 280, width: MediaQuery._of_(context).size.width, margin: EdgeInsets.only(left: 10,right: 10), child: Card( elevation: 2, child: Container( padding: EdgeInsets.only(left: 15,right: 15,top:15,bottom: 15), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( child: TextField( controller: _controller, decoration: InputDecoration( border: OutlineInputBorder(), hintText: 'Enter Text', ), ), ), SizedBox(height: 30), Text(\"EncryptText : $&#123;EncryptData._aesEncrypted_!=null?EncryptData._aesEncrypted_?.base64:''&#125;\", maxLines: 2, style:TextStyle( color: Colors._black_, fontSize: 16 ), overflow: TextOverflow.ellipsis, ), SizedBox(height: 10,), Expanded( child: Text(\"DecryptText : $&#123;EncryptData._aesDecrypted_!=null?EncryptData._aesDecrypted_:''&#125;\", maxLines: 2, overflow: TextOverflow.ellipsis, style:TextStyle( color: Colors._black_, fontSize: 16 ) ), ), SizedBox(height: 20,), Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ ElevatedButton( style: ElevatedButton._styleFrom_( primary: Colors._blue_, _// background_ onPrimary: Colors._white_, ), onPressed: () &#123; setState(() &#123; EncryptData._encryptAES_(_controller!.text); &#125;); &#125;, child: Text('Encryption'), ), ElevatedButton( style: ElevatedButton._styleFrom_( primary: Colors._blue_, _// background_ onPrimary: Colors._white_, ), onPressed: () &#123; setState(() &#123; EncryptData._decryptAES_(_controller!.text); &#125;); &#125;, child: Text('Decryption'), ) ], ) ], ), ), ), ); &#125;&#125; 结束语:在本文中，我解释了 Flutter 加密数据的基本概况，您可以根据自己的选择修改这段代码。这是一个小的介绍加密和解密数据的用户交互从我这边，它的工作使用 Flutter 。 我希望这个博客将提供您尝试在您的 Flutter 项目的探索，加密和解密数据充足的信息。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 导航 Navigator v2 与 GetX","date":"2021-10-13T16:00:00.000Z","path":"2021/10/14/flutter-daily/flutter-navigator-v2-introduce/","text":"前言因为有不少群友想让我讲下 导航 2.0，那我就来说下吧，这不是个新东西了，2019 年 10 月出的 2.0 的推出并不会影响你 1.0 的使用，他只是加法，这种设计非常好，我的老代码还能跑 2.0 的出现，我认为主要是解决 2 个问题： Web 开发 url 参数， http://xxxxxxx/detail/123 对 Page 的堆栈管理（删除某几个，复用某几个，防止无限叠加） 今天我们会先回顾下 1.0 ，然后讲下 2.0 特性，再结合 GetX 来说说一个路由需要解决那些问题，让我们开始吧。 本节目标 回顾 导航 1.0 匿名路由 命名路由 onGenerateRoute 手动解析 新导航 2.0 特性 Page Route RouteInformationParser RouterDelegate GetX 解决了什么问题 路由定义 简化操作 全局操控 路由守卫 视频代码https://github.com/ducafecat/flutter_navigator_v2 参考 https://flutter.cn/community/tutorials/understanding-navigator-v2 https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit#heading=h.l6kdsrb6j9id https://www.raywenderlich.com/19457817-flutter-navigator-2-0-and-deep-links#toc-anchor-001 https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade 正文1. 回顾 Navigator v11.1 匿名路由 主要是通过 Push() Pop() 来操作路由，简单场景也能满足业务 见代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import 'package:flutter/material.dart';void main() &#123; runApp(const NavigatorApp());&#125;class NavigatorApp extends StatelessWidget &#123; const NavigatorApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return const MaterialApp( home: ListPage(), ); &#125;&#125;class ListPage extends StatelessWidget &#123; const ListPage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: const Text('Navigator.push -&gt; Details'), onPressed: () &#123; Navigator.push( context, MaterialPageRoute(builder: (context) &#123; return const DetailPage(); &#125;), ); &#125;, ), ), ); &#125;&#125;class DetailPage extends StatelessWidget &#123; const DetailPage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: const Text('Navigator.pop -&gt; Pop'), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 1.2 命名路由这种方式就优雅了很多，事先定义好路由名字，点赞 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import 'package:flutter/material.dart';void main() &#123; runApp(const NavigatorApp());&#125;class NavigatorApp extends StatelessWidget &#123; const NavigatorApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( routes: &#123; '/': (context) =&gt; const ListPage(), '/details': (context) =&gt; const DetailPage(), &#125;, ); &#125;&#125;class ListPage extends StatelessWidget &#123; const ListPage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: const Text('Navigator.pushNamed -&gt; Details'), onPressed: () &#123; Navigator.pushNamed( context, '/details', ); &#125;, ), ), ); &#125;&#125;class DetailPage extends StatelessWidget &#123; const DetailPage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: const Text('Navigator.pop -&gt; Pop'), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 1.3 onGenerateRoute 手动解析上面的命名路由是好，但是 传参数 不灵活，所有采用 onGenerateRoute 来动态处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import 'package:flutter/material.dart';void main() &#123; runApp(const NavigatorApp());&#125;class NavigatorApp extends StatelessWidget &#123; const NavigatorApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( onGenerateRoute: (settings) &#123; // Handle '/' if (settings.name == '/') &#123; return MaterialPageRoute(builder: (context) =&gt; const ListPage()); &#125; // Handle '/details/:id' var uri = Uri.parse(settings.name!); if (uri.pathSegments.length == 2 &amp;&amp; uri.pathSegments.first == 'details') &#123; var id = uri.pathSegments[1]; return MaterialPageRoute(builder: (context) =&gt; DetailPage(id: id)); &#125; return MaterialPageRoute(builder: (context) =&gt; const UnknownPage()); &#125;, ); &#125;&#125;class ListPage extends StatelessWidget &#123; const ListPage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: const Text('Navigator.pushNamed -&gt; Details'), onPressed: () &#123; Navigator.pushNamed( context, '/details/001', ); &#125;, ), ), ); &#125;&#125;class DetailPage extends StatelessWidget &#123; final String id; const DetailPage(&#123;Key? key, required this.id&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: Text('Navigator.pop -&gt; Pop, id = ' + id), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125;class UnknownPage extends StatelessWidget &#123; const UnknownPage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Center( child: TextButton( child: const Text('Navigator.pop -&gt; Unknown'), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125;&#125; 2. 新 Navigator 2.0Navigator 2.0 参考 新加的对象有: Page: 一个不可更改的对象，用于设置 Navigator 的历史堆栈。 Router: 配置要由 Navigator 显示的页面列表。通常此页面列表根据平台或应用的状态变化而变化。 RouteInformationParser: 它从 RouteInformationProvider 中获取 RouteInformation，并将其解析为用户定义的数据类型。 RouterDelegate: 定义了 Router 如何学习应用状态变化以及如何响应这些变化的应用特定行为。它的工作是监听 RouteInformationParser 和应用状态，并利用当前的 Pages 列表构建 Navigator。 BackButtonDispatcher: 向 Router 报告返回按钮按下的情况。 2.1 Page 组件这是新导航的基础，Page 是一个抽象类，需要继承后使用，最终通过重写 createRoute 方法生成 Route 路由。 上代码 MyPage 12345678910111213141516171819202122import 'package:flutter/material.dart';class MyPage&lt;T&gt; extends Page&lt;T&gt; &#123; const MyPage(&#123; required LocalKey key, required String name, required this.builder, &#125;) : super(key: key, name: name); final WidgetBuilder builder; @override Route&lt;T&gt; createRoute(BuildContext context) &#123; return MaterialPageRoute( settings: this, builder: builder, ); &#125; @override String toString() =&gt; '$name';&#125; MyApp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import 'package:flutter/material.dart';import 'package:flutter_navigator_v2/pages/home.dart';import 'package:flutter_navigator_v2/pages/list.dart';import 'package:flutter_navigator_v2/router/page.dart';void main() &#123; runApp(const MyApp());&#125;class MyApp extends StatefulWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; final _navigatorKey = GlobalKey&lt;NavigatorState&gt;(); final pages = [ MyPage( key: const ValueKey('/'), name: '/home', builder: (context) =&gt; const HomePage(), ), MyPage( key: const ValueKey('/list'), name: '/list', builder: (context) =&gt; const ListPage(), ) ]; bool _onPopPage(Route&lt;dynamic&gt; route, dynamic result) &#123; setState(() =&gt; pages.remove(route.settings)); return route.didPop(result); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: Scaffold( body: Navigator( key: _navigatorKey, onPopPage: _onPopPage, pages: List.of(pages), ), ), ); &#125;&#125; 2.2 Router 组件Router 是 Navigator 2.0 中新增的另一个非常重要的组件，继承自 StatefulWidget，可以管理自己的状态。 核心对象： MaterialApp.router 初始化 RouterDelegate 必须项，路由代理 RouteInformationParser 必须项，路由信息解析 backButtonDispatcher 返回事件 回退键 TransitionDelegate 转场动画 上代码 lib/router/router_names.dart 1234567import 'package:flutter_navigator_v2/pages/home.dart';import 'package:flutter_navigator_v2/pages/list.dart';final routerNames = &#123; \"/\": (context) =&gt; const HomePage(), \"/list\": (context) =&gt; const ListPage(),&#125;; lib/router/route_parser.dart 123456789101112131415161718import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';class MyRouteParser extends RouteInformationParser&lt;String&gt; &#123; // 接受系统传递给我们的路由信息 routeInformation，然后，返回转发给我们之前定义的路由代理 RouterDelegate， // 解析后的类型为 RouteInformationParser 的泛型类型，即这里的 String @override Future&lt;String&gt; parseRouteInformation(RouteInformation routeInformation) &#123; var location = routeInformation.location; return SynchronousFuture(location!); &#125; // 返回一个 RouteInformation 对象，表示从传入的 configuration 恢复路由信息。 @override RouteInformation restoreRouteInformation(String configuration) &#123; return RouteInformation(location: configuration); &#125;&#125; lib/router/router_delegate.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';import 'package:flutter_navigator_v2/router/page.dart';import 'package:flutter_navigator_v2/router/router_names.dart';class MyRouteDelegate extends RouterDelegate&lt;String&gt; with PopNavigatorRouterDelegateMixin&lt;String&gt;, ChangeNotifier &#123; final _stack = &lt;String&gt;[]; static MyRouteDelegate of(BuildContext context) &#123; final delegate = Router.of(context).routerDelegate; assert(delegate is MyRouteDelegate, 'Delegate type must match'); return delegate as MyRouteDelegate; &#125; MyRouteDelegate(&#123; required this.onGenerateRoute, &#125;); final RouteFactory onGenerateRoute; @override GlobalKey&lt;NavigatorState&gt; navigatorKey = GlobalKey&lt;NavigatorState&gt;(); @override String? get currentConfiguration =&gt; _stack.isNotEmpty ? _stack.last : null; List&lt;String&gt; get stack =&gt; List.unmodifiable(_stack); void toName(String newRoute) &#123; _stack.add(newRoute); notifyListeners(); &#125; void push(String newRoute) &#123; _stack.add(newRoute); notifyListeners(); &#125; void remove(String routeName) &#123; _stack.remove(routeName); notifyListeners(); &#125; void pop() &#123; _stack.remove(_stack.last); notifyListeners(); &#125; bool _onPopPage(Route&lt;dynamic&gt; route, dynamic result) &#123; if (_stack.isNotEmpty) &#123; if (_stack.last == route.settings.name) &#123; _stack.remove(route.settings.name); notifyListeners(); &#125; &#125; return route.didPop(result); &#125; @override Future&lt;void&gt; setInitialRoutePath(String configuration) &#123; return setNewRoutePath(configuration); &#125; @override Future&lt;void&gt; setNewRoutePath(String configuration) &#123; _stack ..clear() ..add(configuration); return SynchronousFuture&lt;void&gt;(null); &#125; @override Widget build(BuildContext context) &#123; return Navigator( key: navigatorKey, onPopPage: _onPopPage, pages: [ for (final name in _stack) MyPage( key: ValueKey(name), name: name, builder: routerNames[name] as Widget Function(BuildContext), ), ], ); &#125;&#125; lib/example_05_router_delegate.dart 123456789101112131415161718192021222324252627282930313233343536373839404142import 'package:flutter/material.dart';import 'package:flutter_navigator_v2/pages/home.dart';import 'package:flutter_navigator_v2/router/route_parser.dart';import 'package:flutter_navigator_v2/router/router_delegate.dart';void main() &#123; runApp(const MyApp());&#125;class MyApp extends StatefulWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; final delegate = MyRouteDelegate( onGenerateRoute: (RouteSettings settings) &#123; return MaterialPageRoute( settings: settings, builder: (BuildContext context) &#123; return const HomePage(); &#125;, ); &#125;, ); @override Widget build(BuildContext context) &#123; // Navigator 2.0 之后，Flutter 也提供了 MaterialApp 的新构造函数 router 来帮助我们直接在应用顶层构造出全局的 Router 组件 return MaterialApp.router( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, visualDensity: VisualDensity.adaptivePlatformDensity, ), routeInformationParser: MyRouteParser(), // 路由信息解析 routerDelegate: delegate, // 路由代理 ); &#125;&#125; 3. GetX作为一个路由组件需要解决的问题: 路由定义 简化操作 全局操控 路由守卫 转场动画 适配 Web SEO 场景 堆栈管理（欠缺） GetPage 对象继承了 Page, 在定义路由阶段就声明了功能：命名路由、转场、嵌套、中间件… 12345678910111213141516171819202122class GetPage&lt;T&gt; extends Page&lt;T&gt; &#123; @override final String name; final GetPageBuilder page; final bool? popGesture; final Map&lt;String, String&gt;? parameter; final String? title; final Transition? transition; final Curve curve; final Alignment? alignment; final bool maintainState; final bool opaque; final Bindings? binding; final List&lt;Bindings&gt; bindings; final CustomTransition? customTransition; final Duration? transitionDuration; final bool fullscreenDialog; final RouteSettings? settings; final List&lt;GetPage&gt;? children; final List&lt;GetMiddleware&gt;? middlewares; final PathDecoded path; final GetPage? unknownRoute; GetNavigation 导航对象及方法丰富的方法 GetMiddleware 路由中间件在 Page 的生命周期里处理 结束语关于 GetX 的使用，不在这里重复，这里只是想阐述一个路由组件生产环境下要面对的问题。 GetX 快速上手 -&gt; 点这里 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"桌面 Flutter 应用程序","date":"2021-10-13T16:00:00.000Z","path":"2021/10/14/translation/flutter-app-for-desktop/","text":"原文 https://medium.com/flutterdevs/flutter-app-for-desktop-d949f4d20cdb 代码https://github.com/flutter-devs/flutter_app_for_desktop 参考 https://flutter.dev/docs/get-started/install/windows#windows-setup 正文了解如何设置运行桌面上的应用程序在您的 Flutter 应用程序 在 Flutter 中，Flutter 应用程序屏幕上的每个组件都是一个小工具。屏幕的透视图完全依赖于用于构建应用程序的小部件的选择和分组。此外，应用程序代码的结构是一个小部件树。 在这个博客中，我们将了解如何在桌面上运行 Flutter 应用程序，以及设置这个应用程序的要求是什么？.我们将看到一步一步的流程，并创建一个应用程序来理解桌面应用程序的构建过程。 Flutter : “ Flutter 是谷歌的 UI 工具包，它可以帮助你在创纪录的时间内用一个代码库为移动设备、网络和桌面构建漂亮的本地组合应用程序。” 它是免费和开源的。它最初是由谷歌发展而来，目前由 ECMA 标准监管。 Flutter 应用程序利用 Dart 编程语言来制作应用程序。这个 dart 编程和其他编程语言有一些相同的亮点，比如 Kotlin 和 Swift，并且可以被转换成 JavaScript 代码。 Flutter 的好处:Flutter 为我们提供了在多个平台上运行应用程序的机会。比如，网络，桌面，Android/iOS。市场上有许多语言可以在多种平台上运行应用程序。但与其他语言相比，flutter 在不同平台上运行应用程序所需的时间更少。因为 flutter 不像其他语言那样使用 mediator 桥来运行应用程序。因此，在不同的平台上运行应用程序时， Flutter 速度很快。下面是一些关键点 所有平台中相同的用户界面和业务逻辑。 减少代码和开发时间。 类似于本地应用程序的性能。 自定义，动画 UI 可用于任何复杂的小部件。 自己的渲染图形引擎，即 skia。 简单的平台专用逻辑实现。 超越手机的潜在能力。 Flutter 平台特定的标准: 特定于 Android 平台 特定于 iOS 平台 特定于 Web 平台 桌面平台专用 为桌面平台上运行的应用程序设置特定: 首先，创建您的 Flutter 项目 然后将你的频道切换到贝塔 Flutter 频道。因为它涵盖了桌面支持，在 Beta 版本中可以使用，并且在 Beta 头条大新闻中可以使用这个命令。 1&gt; flutter channel beta Flutter 转到 flutter 文档，点击窗口设置选项，阅读文档。 https://flutter.dev/docs/get-started/install/windows#windows-setup 然后使用这个命令启用你的窗口。 1&gt; flutter config — enable-windows-desktop 查看下面的文档 https://flutter.dev/docs/get-started/install/windows#windows-setup 启用窗口后 重新启动 android studio 。 重新启动 android studio 之后，现在使用下面的命令创建 windows 支持目录。 1&gt; flutter create. 现在安装 visual studio 去这个链接。 https://visualstudio.microsoft.com/downloads/ 在 visual studio 安装后，你终于可以在桌面上运行你的应用了。选择桌面设备在你的 android studio 和运行应用程序。 实施方案:现在我正在设计一个在桌面上测试的页面。你可以在桌面上运行任何应用程序。我在这里展示的只是这个应用程序的最后一个页面代码实现，它是代码片段。如果你想查看完整的代码，请访问下面给出的 Github 链接。 在这个网页上，我正在设计一个课程列表卡与图像和文字为购买课程列表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302import 'package:e_learning_app/constants/constants.dart';import 'package:e_learning_app/model/Courses_items_model.dart';import 'package:e_learning_app/model/read_blog_model.dart';import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';import 'dart:io' show Platform;class ReadScreenView extends StatefulWidget &#123; const ReadScreenView(&#123;Key? key&#125;) : super(key: key); @override _ReadScreenViewState createState() =&gt; _ReadScreenViewState();&#125;class _ReadScreenViewState extends State&lt;ReadScreenView&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: _buildBody(), ); &#125; Widget _buildBody() &#123; return Container( height: MediaQuery._of_(context).size.height, child: Stack( children: [ Container( height: MediaQuery._of_(context).size.height, _//color: Colors.cyan,_ child: Container( margin: EdgeInsets.only(bottom: 350), height: 250, decoration: BoxDecoration( color: Color(0xffff9b57), borderRadius: BorderRadius.only( bottomLeft: Radius.circular(40), bottomRight: Radius.circular(40))), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( padding: EdgeInsets.only( left: 20, right: 20, top: 30), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ InkWell( onTap:()&#123; Navigator._pop_(context); &#125;, child: Container( _//margin: EdgeInsets.only(right: 25,top: 10),_ height: 30, width: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(5), color: Color(0xfff3ac7c), ), child: Icon( Icons._arrow_back_, color: Colors._white_, size: 20, ), ), ), Container( _// margin: EdgeInsets.only(right: 25,top: 10),_ height: 30, width: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(5), color: Color(0xfff3ac7c), ), child: Icon( Icons._menu_, color: Colors._white_, size: 20, ), ), ])), Container( padding: EdgeInsets.only(left: 20, right: 20, top: 16), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( child: Text( \"Purchase Courses\", style: TextStyle( color: Colors._white_, fontSize: 20, _//fontWeight: FontWeight.bold_ ), ), ), SizedBox( height: 5, ), Container( child: Text( \"Categories\", style: TextStyle( color: Colors._white_, fontSize: 12, _//fontWeight: FontWeight.bold_ ), ), ), ], ), ), Container( padding: EdgeInsets.only(left: 20, top: 16), height: 140, alignment: Alignment._center_, _//color: Colors.orange,_ child: ListView.builder( scrollDirection: Axis.horizontal, shrinkWrap: true, itemCount: readBlogList.length, itemBuilder: (BuildContext context, int index) &#123; return _buildCategorySection(readBlogList[index]); &#125;), ), ], ), ), ), Positioned( top: 260, left: 0, right: 0, bottom: 0, child: SizedBox( height: MediaQuery._of_(context).size.height - 260, width: MediaQuery._of_(context).size.width, child: Container( _//color: Colors.yellow,_ padding: EdgeInsets.only(left: 4, right: 4), width: MediaQuery._of_(context).size.width, child: ListView.builder( _//physics: NeverScrollableScrollPhysics(),_ scrollDirection: Axis.vertical, shrinkWrap: true, itemCount: readBlogList.length, itemBuilder: (BuildContext context, int index) &#123; return _buildPurchaseCourses(readBlogList[index]); &#125;), ), ), ), Positioned( bottom: 0, child: Container( padding: EdgeInsets.only(left: 20, right: 20, top: 10, bottom: 10), height: 70, width: MediaQuery._of_(context).size.width, color: Colors._white_, child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( \"Purchase Courses\", style: TextStyle( color: Colors._black_, fontSize: 14, _//fontWeight: FontWeight.bold_ ), ), Text( \"5\", style: TextStyle( color: Colors._red_, fontSize: 20, _//fontWeight: FontWeight.bold_ ), ), ], ), Container( height: 40, width: 130, margin: EdgeInsets.only(bottom: 10), decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), color: Color(0xffdc4651)), child: Container( padding: EdgeInsets.only(left: 20, right: 20), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Text( \"Category\", style: TextStyle(color: Colors._white_), ), Icon(Icons._arrow_drop_down_, color: Colors._white_) ], ), ), ) ], ), ), ), ], ), ); &#125; Widget _buildCategorySection(ReadBlogModel readBlogList) &#123; return Container( height: 50, width: 110, child: Card( color: Colors._white_, child: Column( _//mainAxisAlignment: MainAxisAlignment.spaceBetween,_ children: [ Container( height: 90, child: ClipRRect( borderRadius: BorderRadius.only(topLeft: Radius.circular(5),topRight: Radius.circular(5)), child: Image.network( readBlogList.image!, fit: BoxFit.fill, height: 50, width: 110, ), )), Container( padding: EdgeInsets.all(5), child: Text( \"Categories\", style: TextStyle( color: Colors._black_, fontSize: 12, _//fontWeight: FontWeight.bold_ ), ), ), ], ), ), ); &#125; Widget _buildPurchaseCourses(ReadBlogModel readBlogList) &#123; return Container( margin: EdgeInsets.only(left: 10, right: 10), _//padding: EdgeInsets.only(left: 10,right: 20),_ height: 80, child: Card( child: Container( padding: EdgeInsets.only(left: 10, right: 10), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Container( height: 40, width: 40, child: ClipRRect( child: Image.network( readBlogList.image!, fit: BoxFit.fill, ), borderRadius: BorderRadius.circular(8), ), ), _//SizedBox(width: 20,),_ Container( padding: EdgeInsets.only(right: 120), child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text( readBlogList.title!, style: TextStyle( fontSize: 12, _//fontWeight: FontWeight.bold_ ), ), Text( readBlogList.subTitle!, style: TextStyle( fontSize: 12, _//fontWeight: FontWeight.bold_ ), ), ], ), ), _// SizedBox(width: 130,),_ Container( height: 30, width: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), color: Color(0xfffee8db), ), child: Icon( Icons._done_, color: Color(0xffdd8e8d), size: 16, ), ) ], ), ), )); &#125;&#125; 当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 结语:在本文中，我已经简单地解释了桌面应用程序的设置。 GitHub Link:https://github.com/flutter-devs/flutter_app_for_desktop © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter theme 主题样式生成工具","date":"2021-10-12T16:00:00.000Z","path":"2021/10/13/translation/using-flutter-theming-tools-generated-dart-material-theme-in-your-application/","text":"原文 https://medium.com/@sheikhg1900/using-flutter-theming-tools-generated-dart-material-theme-in-your-application-f190f3919e88 参考 https://medium.com/@sheikhg1900/using-flutter-theming-tools-generated-dart-material-theme-in-your-application-f190f3919e88 正文在你的 android 手机上打开 Flutter 主题工具应用程序 。按照指南为你的应用程序准备一个很棒的 Dart 主题。 将生成的 Dart 主题代码复制到剪贴板中。 要在您的计算机上获取主题，请在 IDE 中，(例如 Visual Studio Code)。将其粘贴到您手机上的 slack 聊天中，以便您可以从计算机上的 slack 获取代码。在移动设备 slack 上，输入 ```。将出现一个框。将剪贴板内容粘贴到该框中。 可选：按照相同的步骤为黑暗模式生成另一个 Dart 主题。 打开您现有的 flutter 项目。使用以下内容创建 generated_theme.dart 文件。 12345import 'package:flutter/material.dart';ThemeData get mylightTheme &#123;// TODO: Copy Generated Light Theme Here.return theme;&#125;ThemeData get myDarkTheme &#123;// TODO: Copy Generated Dark Theme Here.return theme;&#125; 用生成的代码替换 TODO 注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ThemeData get mylightTheme &#123;// Flutter Theming Tool 1.0.0+10, developed by Tamata Soft// Initialize ThemeData. var theme = ThemeData( primarySwatch: Colors.blue, brightness: Brightness.light, );// Main Setting. theme = theme.copyWith( colorScheme: theme.colorScheme.copyWith( onPrimary: const Color(0xffffffff), secondary: Colors.deepOrange, ), );// ElevatedButton Setting. theme = theme.copyWith( elevatedButtonTheme: ElevatedButtonThemeData( style: ButtonStyle( shape: MaterialStateProperty.all( const RoundedRectangleBorder( borderRadius: BorderRadius.only( topLeft: Radius.circular(16.0), topRight: Radius.circular(16.0), ), ), ), ), ), );// OutlinedButton Setting. theme = theme.copyWith( outlinedButtonTheme: OutlinedButtonThemeData( style: ButtonStyle( shape: MaterialStateProperty.all( const RoundedRectangleBorder( borderRadius: BorderRadius.only( topLeft: Radius.circular(16.0), topRight: Radius.circular(16.0), ), ), ), ), ), );// Chip Setting. theme = theme.copyWith( chipTheme: theme.chipTheme.copyWith( shape: const RoundedRectangleBorder( borderRadius: BorderRadius.only( topLeft: Radius.circular(16.0), bottomRight: Radius.circular(16.0), ), ), labelStyle: (theme.chipTheme.labelStyle).copyWith( color: Colors.deepOrange, shadows: [ const Shadow( blurRadius: 2.0, color: Colors.grey, ) ], ), secondaryLabelStyle: (theme.chipTheme.labelStyle).copyWith( shadows: [ const Shadow( blurRadius: 2.0, ) ], ), ), ); return theme;&#125; 打开 main.dart 文件。在 MaterialApp 小部件中添加 theme 属性。 123456MaterialApp( title: 'Flutter Demo', theme: mylightTheme, ---- ----) 所需的包.google_fonts © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 网络搜索引擎SEO优化友好","date":"2021-10-07T16:00:00.000Z","path":"2021/10/08/translation/flutter-web-seo-friendly/","text":"原文 https://medium.com/mindful-engineering/flutter-web-seo-friendly-317528c29cc6 参考 https://pub.dev/packages/seo_renderer 正文目前，在开发移动和网络应用程序时， Flutter 将成为一种流行趋势。我们都知道桌面版本正处于 beta 测试阶段，并且在 Flutter web 的稳定版本中被淘汰。我们都知道，当互联网出现在图片中时，目标受众就会大得多(世界范围内)。我们的网站不能很容易地到达用户只要输入和搜索到一个搜索引擎，我们得到的结果。当网站是为企业和其他人建立的时候，索引很重要。 当我们希望通过增加搜索索引来建议用户选择我们的应用时，搜索引擎优化是最重要的。 是否可能与 Flutter 网络搜索引擎优化？ 这个问题在开发网络应用程序之前或之后出现在我的脑海中。对 web 应用程序更好的 SEO 支持是 Flutter 开发者下一个版本的目标。 这里是我的网站后，使其 SEO 友好的结果 以前: 之后: 搜索引擎优化 搜索引擎优化搜索引擎是一个过程，它可以提高网站流量的质量和数量，使网站或网页从搜索引擎获得流量。搜索引擎优化的目标是无偿流量，而不是直接流量或付费流量。 什么是 seo 友好型？建立一个 seo 友好的网站意味着谷歌和其他搜索引擎可以高效地抓取网站上的每个页面，有效地解释内容，并将其索引到数据库中。一旦编入索引，他们就可以根据用户搜索的主题向用户提供最相关、最有价值的网页。 我遵循的步骤，使网站 SEO 友好 标题的长度至少应该是 207 个字符 描述长度最少 690 个字符将是有益的 需要在 index.html 中添加关键字 meta（关键字应根据页面内容正确，并且需要添加至少 10 个关键字以存档良好的 SEO） 需要增加一个移动优化的观点 包装每个文本、图像、链接[\\*_seo_render 感谢上帝\\*](https://pub.dev/packages/seo_renderer) 包将有助于使网站 SEO 友好。它是用来渲染文本，链接，图像小部件作为 HTML 元素 SEO 的目的。(仍在开发中)_ 语义小工具也可以帮助使网站 seo 友好 适用于 seo 的 Meta 标签 开放图表标签 1234567og:title - The title of your object as it should appear within the graph, e.g., \"The Rock\".og:type - The type of your object, e.g., \"video.movie\". Depending on the type you specify, other properties may also be required.og:image - An image URL which should represent your object within the graph.og:url - The canonical URL of your object that will be used as its permanent ID in the graph, e.g., \"https://www.imdb.com/title/tt0117500/\". 在 meta 标签中有许多可用的属性，你可以在这里找到 here 使用 seo 渲染库渲染文本小部件作为 HTML 元素 首先，我们需要添加一个RouteObserver 从导航堆栈中弹出时自动删除 Html 元素MaterialApp 1navigatorObservers: &lt;RouteObserver&lt;ModalRoute&lt;void&gt;&gt;[routeObserver], 将这个依赖项添加到pubspec.yaml pubspec.yaml 从 Pub 取包裹 1flutter packages get 所有的文本，图片和链接都应该像这样被扭曲 home_page.dart 只要传递你的 Text/RichText 小工具和一个选项 RenderController() 可用于在可滚动内容/更改位置的情况下刷新内容(位置) 需要通过 child : Widget, anchorText : String, link : String &amp; 可选的 RenderConroller() 需要通过 child : Widget, link : String, alt : String &amp; 可选的 RenderConroller() 语义学这个小部件使用小部件的含义描述对小部件树进行注释。 可访问性工具、搜索引擎和其他语义分析软件使用它来确定应用程序的含义。 这种语义将为移动环境中的可访问性服务提供信息。 Semantics 语义学 当你只想描述一个特定的小部件 MergeSemantics 当你想要描述一组组件的时候。在这个例子中，不同的Semantics 语义学 在这个节点的子树中定义的one single Semantics 一个单一的语义学。这可能是非常有用的重新组语义，但是，在语义冲突的情况下，结果可能是荒谬的 语义的属性:在语义学中有许多可用的属性，比如, label: 它提供了一个小部件的文本描述，是基本的语义信息 container: 此节点是否在语义树中引入新的语义节点(SemanticsNode)。它不能用上层语义，即独立语义进行分离或合并 explicitChildNodes : 默认值为 false，表示是否强制显示子窗口小部件的语义信息。它可以理解为分裂语义学 scopesRoute: 如果它不是空的，则无论节点是否对应于子树的根，子树都应该声明路由名称。通常explicitChildNodes将其设置为 true，并在路由跳转中使用它，例如Page jumps,Dialog, BottomSheet, PopupMenu 弹出部分 这里显示了语义的一些属性, semantics_demo.dart 如果希望调试应用程序的语义，可以将 MaterialApp 的 showSemanticsDebugger 属性设置为 true。这将迫使 Flutter 生成一个覆盖可视化的语义树。 搜索引擎渲染器 | Flutter Packagehttps://pub.dev/packages/seo_renderer © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 如何在10分钟内快速的创建图片编辑器","date":"2021-09-29T16:00:00.000Z","path":"2021/09/30/translation/how-to-build-a-photo-editing-app-in-10-minutes-using-flutter-and-img-ly/","text":"猫哥说我最近在做一个社交 APP，里面需要图片、视频的编辑器，如果你和我一样有这样的需求 你可以试试这款 https://img.ly 原文https://promise-amadi.medium.com/how-to-build-a-photo-editing-app-in-10-minutes-using-flutter-and-img-ly-5d9601173822 源码https://github.com/Wizpna/photo_editor.git 参考 https://img.ly/photo-sdk https://pub.dev/packages/photo_editor_sdk https://pub.dev/packages/image_picker 正文 大家好，在今天的文章中，你将学习如何使用 Flutter 和 Img.ly 构建一个照片编辑应用程序。 但是，在我深入本教程的技术方面之前，我想对 IMG.LY 做一个简单的解释。 IMG.LY 是一家总部位于德国的公司，通过其图片和视频编辑 SDK 提供最先进的图像和视频处理解决方案。 主要用于照片编辑目的，而且 SDK 很容易在移动应用程序上实现。 那么让我们开始吧使用 Visual Studio、 IntelliJ 或 Android Studio 创建一个新的 Flutter 项目。 成功创建一个新的 flutter 项目后，打开“ pubspec.yaml”，并安装 photo_editor_sdk 和 image_picker 插件。 123dependencies: photo_editor_sdk: ^2.0.0 image_picker: ^0.8.1+3 注意: image_picker 这个插件将用于从设备中获取照片，而 photo_editor_sdk 将用于照片编辑。 为 Android 配置 PhotoEditor SDKSDK 相当大，因此你需要为你的项目启用 Multidex 如下: 编辑 android/build.gradle 并在顶部添加以下行 12345678910buildscript &#123; repositories &#123; google() jcenter() maven &#123; url \"https://artifactory.img.ly/artifactory/imgly\" &#125; &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:4.1.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" classpath 'ly.img.android.sdk:plugin:8.3.1' &#125;&#125; 请注意: 为了更新 Android 版本的 PhotoEditor SDK，将版本字符串 version 8.3.1 替换为更新的版本 newer release 。 打开 **android/app/build.gradle** file (not android/build.gradle) 并在末尾添加以下代码行: 12345678910111213android &#123; defaultConfig &#123; applicationId \"com.example.photo_editor\" minSdkVersion 16 targetSdkVersion 30 versionCode flutterVersionCode.toInteger() versionName flutterVersionName multiDexEnabled true &#125;&#125;dependencies &#123; implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\" implementation 'androidx.multidex:multidex:2.0.1'&#125; 打开 android/app/build.gradle file (not android/build.gradle) 在 apply plugin 下面添加以下行 apply plugin: &quot;com.android.application&quot;: 12345678910111213141516171819202122232425apply plugin: 'ly.img.android.sdk'apply plugin: 'kotlin-android'apply plugin: 'ly.img.android.sdk'apply from: \"$flutterRoot/packages/flutter_tools/gradle/flutter.gradle\"// Comment out the modules you don't need, to save size.imglyConfig &#123; modules &#123; include 'ui:text' include 'ui:focus' include 'ui:frame' include 'ui:brush' include 'ui:filter' include 'ui:sticker' include 'ui:overlay' include 'ui:transform' include 'ui:adjustment' include 'ui:text-design'// This module is big, remove the serializer if you don't need that feature. include 'backend:serializer'// Remove the asset packs you don't need, these are also big in size. include 'assets:font-basic' include 'assets:frame-basic' include 'assets:filter-basic' include 'assets:overlay-basic' include 'assets:sticker-shapes' include 'assets:sticker-emoticons'include 'backend:sticker-smart' &#125;&#125; 为 iOS 设置 ImagePicker打开 &lt;project root&gt;/ios/Runner/Info.plist 并将以下键添加到 Info.plist 文件中 123456&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; &lt;string&gt;app needs permission for the photo library&lt;/string&gt; &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;app needs access to the camera.&lt;/string&gt; &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;app needs access to the microphone, if you intend to record videos.&lt;/string&gt; 打开你的 main.dart 文件，像下面的代码片段一样更新你的代码: 您必须创建一个名为 imgFromGallery 的方法 当调用 imgFromGallery 方法时，它将打开设备上的图像目录。 下一步将创建另一个名为 imglyEditor. 的方法。 当调用 imglyEditor 方法时，它将打开 Img.ly 编辑器。 使用物理设备或模拟器测试运行应用程序。 P.S: 这是源码 source code © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"下一个 Flutter 项目要记住的 11 件事","date":"2021-09-28T16:00:00.000Z","path":"2021/09/29/translation/11-things-to-remember-for-your-next-flutter-project/","text":"原文 https://medium.com/flutter-community/11-things-to-remember-for-your-next-flutter-project-1c7c380895ca 正文创建一个新的 Flutter 项目是一件好事ーー新鲜的代码库、没有遗留代码(还没有)、空安全性、您最喜欢的软件包的最新版本等等。但是与此同时，您应该在项目开始时做出关键的决策，这些决策将为未来奠定基础，例如工具、包、文件结构、状态管理解决方案、测试计划。否则，这个项目最终会变成另一碗意大利面和肉丸。为了避免这种情况，我准备了一个列表，在我看来，这个项目中最重要的元素应该尽早决定。我希望它能帮助你，因此ーー快乐的阅读！ 1. 静态程序分析 I will not write messy code ( 我不会写乱七八糟的代码(source 来源) Linter 是一个静态分析工具，用于识别和标记代码中的编程错误、警告和样式缺陷，以便您修复它们。在 Flutter 上下文中，这是最容易实现的东西之一，也是保持代码干净的最有用的东西之一。 有很多不同的规则可以让你的代码遵循，但是我建议你使用一个预先定义的规则，它已经遵循了基于 Dart 样式指南的最佳实践: https://dart-lang.github.io/linter/lints/index.html https://dart.dev/guides/language/effective-dart/style lint; flutter_lints Flutter; very_good_analysis. 无论选择哪个包，都可以在 analysisservices _ options. yaml 文件中添加或删除任何特定的静态分析规则。 2. 本地化(l10n) 本地化 [来源](https://marcosantadev.com/wp-content/uploads/Localization_Tips.jpg 什么是本地化(简称 l10n) ？ 本地化是对产品或服务的调整，以满足特定语言、文化或期望人群的“外观和感觉”的需要ー TechTarget 建立一个用户感觉自然的应用程序是必要的，例如使用正确的翻译、日期和货币格式、文本方向。因此，本地化是一个基本的工具。即使您正在构建单个区域/语言应用程序，我仍然建议您尽早实现本地化，从而将文本与 UI 代码分离开来。因此，可以在不影响代码的情况下对它们进行重用和调整。 Flutter documentation 精巧地解释了国际化应用程序的过程。如果缺省方式看起来太复杂，或者您需要一些有用的扩展和帮助器方法，那么有一些流行的第三方包，比如 easy_localization ，可以帮助您完成本地化过程。 3. 环境(有一些味道) Programming environments 来源 我敢打赌，当有人在生产中损坏数据或删除整个用户表时，您至少已经从您的环境中听说过一个案例(没有双关意思)。相信我，这一点也不好玩。因此，为你的项目创建不同的环境是一个很好的实践: (本地)环境ー用来让你抓狂: 在代码中做实验，直接在数据库中更改数据，使用快捷键并硬编码认证标记或提供模拟数据。玩得开心，并提供这些功能 帮助您验证代码中的更改，用“真实”数据(通常在这种环境中使用生产数据快照)测试特性，并在将应用程序发布到生产环境之前验证它。如果你的团队中有质量保证工程师，这就是他们发光发热的地方 环境ー由真实用户使用的环境，其中数据损坏是不可接受的(请始终进行备份) 拥有这样的环境可以帮助您在这些更改到达用户手中之前安全地实验和验证特性。 现在，另一个部分——味道。不，不，我们不是在讨论甜的、咸的或酸的东西ーー这只是在编程中用来描述应用程序的不同构建变体的另一个术语。例如，您希望使图标和标题、 API 端点或任何其他配置对于每个特定环境都不同。为此，您需要定义一种不同的“味道”，这种味道在为特定环境构建应用程序时使用。这里有一些关于如何为 create flavours for Flutter 。 4. 持续集成和持续交付 持续集成阶段(CI)和持续交付集成阶段(CD)source 来源 在引入不同的环境之后，自然而然的下一步是自动化构建、测试和发布应用程序的过程。CI/CD 本身就是一个相当复杂的主题，无论如何我都不是这个领域的专家，因此我建议搜索一些关于如何使应用程序开发的不同阶段自动化的其他资源。 然而，有很多 NoOps 解决方案是与 Flutter 兼容的，所以你可以轻松自动化你的开发过程: Appcircle; Codemagic 代码魔法; Bitrise; VS App Center (还没有 Flutter 集成，但是有一些资源可以帮助你设置所有的东西) 这些解决方案中的任何一个都可以解决问题ーー简单地说，选择一个符合你的需要和预算的方案。 5. 后端代码 ( 另一个关于后端的迷因(source 来源) 您是否已经用任何特殊的或者不那么花哨的编程语言实现了后端？很好，您可以跳过这一步，但我仍然建议您查看一些云解决方案，以供将来参考。 在简化版本中，应用程序的后端部分有两个选项: 使用您喜欢的任何编程语言和框架实现自定义后端解决方案，但是稍后将处理所有DevOps 让你的代码和数据可以从应用程序中访问 使用任何云解决方案来加速开发过程，并将大部分 DevOps 留给云供应商 如果你觉得第二个选择很有吸引力，可以从支持 Flutter 的云平台中选择一些: Google Firebase 谷歌 Firebase; AWS Amplify; Supabase 女名女子名; 云平台为您的应用程序提供身份验证、数据库、存储、 API 选项和许多其他特性。如果您只需要验证这个想法并快速构建 MVP，而不需要花费大量时间在成熟的后端解决方案上，那么上述任何一个都是一个很好的选择。 6. 日志记录，崩溃数据和分析 ( 哎呀，出问题了source 来源) 伐木被低估了ーー在这里，我说过了！一切都很好，直到出现问题，你需要了解这方面的信息。当我们讨论什么应该记录，什么不应该记录时，总有一个灰色地带。但有一件事情始终是明确的: 您必须知道应用程序何时崩溃以及问题的原因。你收集的关于这个事件的数据越多，就越容易发现和解决这个问题。 像 Sentry, Firebase Crashlytics, Datadog 、 Datadog 这样的服务可以帮助你记录最重要的数据、崩溃报告，甚至在你的应用程序或相关服务出现故障时设置通知。 另一种类型的日志记录是收集用户数据用于分析目的。当您构建一个全新的、可能是一流的产品时，了解用户的需求、他们的行为以及他们如何使用应用程序是至关重要的。为此，各种分析工具可以集成到您的 Flutter 应用程序，如 Firebase Analytics 分析，App Center Analytics 中心分析和许多更多。 7. 应用程序 branding Material theming ( Material 主题化(source 来源) 任何应用程序或品牌的主要目标之一就是获得认可。使用正确的颜色调色板，标志，图标，设计元素，内容，字体，有时甚至布局使你的产品脱颖而出。这就是应用程序的品牌化，在开始的时候准备好基本的部分将会在整个项目中节省你很多时间。 如果你已经准备好了你的 UI 原型或者设计组件，现在是时候把它们转移到你的应用程序中并定义主题—- 颜色、字体、形状等等。为了方便起见，一个叫 Mike Rydstrom 的好人为这个 flex_color_scheme 方案创建了一个出色的包。 8. 项目结构和状态管理 ( Flutter 状态管理(source 来源) 是的，有争议的那个。需要澄清的是，根本没有所谓的“最佳国家管理解决方案”或“最佳应用程序架构”——如果有人不这么认为，请记住，他们可能也会先把牛奶倒进碗里，然后再倒麦片。这是最糟糕的部分ーー我不能教你最好的方法。我只能提供几个选项或分享我的偏好。 下一个 Flutter 项目的几个文件结构选项: Clean Architecture 清洁的建筑 — ー清晰的关注点分离，是否长久存在。老实说，我不喜欢这样。我觉得这个概念中有太多的抽象，可能会减缓开发进程 Layered Architecture 分层建筑 ー依赖于将数据、业务和表示逻辑分为不同层次的想法。这样的文件结构对于中小型项目来说工作得很好，但是我觉得当项目增长时，这些层会变得越来越不堪重负 Modular Architecture (I have described this concept 模块化体系结构(我已经描述了这个概念here 这里) ー把程式码分割成不同功能的模组，以便不同的模组互相作用。这是我最喜欢的一个ー它与集团国家管理解决方案(TEAM BLoC，YEAH!)顺利地工作对于大型项目来说，规模很大。然而，它也带来了一些挑战，比如公共逻辑放在哪里，不同的模块应该如何通信等等 关于《 Flutter 》中的国家管理问题，我想我们已经到了可以把整个会议都用来讨论这个问题的时候了，但是事后还没有最后的答案。我只想补充一点，选择一个你觉得最舒服的。你可以在 here 找到一个全面的选项列表。 9. 代码生成 Code generation ( 代码生成(source 来源) 如果您想简化一些步骤并节省一些开发时间，您可以在项目中使用代码生成。少编码，多交付！ Code less, deliver more 有一系列不同的工具可以使用，无论是处理本地化、资产、解析 JSON、生成模型类、实现服务定位器、路由，还是处理不可变状态。唯一要做的就是调查可用的工具和包，并选择最好的工具和包来满足您的项目需求。 对于一个快速 Flutter 项目启动，我建议检查出 Very Good CLI 。这将节省您几个小时的配置(不幸的是，我已经学会了艰难的方式)。 此外，上个月我还做了一个关于 code generation 的演讲ーー它可能是 Flutter 代码生成旅程的起点，所以看看吧！ 10. 测试策略 Application testing ( 应用程式测试(source 来源) 用测试来覆盖 100% 的代码是好还是坏？当然，这很棒，但是代价是什么呢？这样想的话，您可能会掉进一个注定要陷入困境的深渊，在那里您花费更多的时间编写测试，而不是开发特性。为了避免这种情况，您需要一个测试策略。 不要误会我的意思ー用测试覆盖代码是一件好事，而且代码中越隐蔽的地方，在实现新特性时就越安全。只是，在我看来，与编写测试所花费的时间相比，您应该找到测试仍然为您带来更多价值的平衡点。例如，这是我的测试策略: Business logic (services, repositories, BLoCs) should be covered 85-100% in 业务逻辑(服务、存储库、集群)应该在unit/integration tests 单元/集成测试 ー这是所有应用程序中最重要的部分，因此我看到了测试的很大价值; Widget tests 小部件测试 应该包含所有可重用的 UI 组件。当单个组件被正确测试时，您可以开始测试单个屏幕，但是不要太详细 End-to-end tests 端到端测试, 涵盖了主要的应用程序流以及与 UI 的交互。没有深层次的魔法ーー只是经历一些关键的工作流程。它们包含的屏幕越多越好 当整个用户界面准备就绪并实现时ーgolden tests 黄金试验 确保 UI 不会受到以后更改的影响 老实说，我仍然在测试中寻找中庸之道，但是相信我，你会在一个又一个项目中做得更好。 11. 自述文件 Make a README ( 自述文件(source 来源) 你没听错，文件。README 文件是项目中最重要的文档，尤其是在团队中工作时。 您是否刚刚引入了一个需要代码生成的新解决方案？您是否刚刚添加了一个有用的 bash 脚本来自动完成这个过程？您是否实现了一个必须在项目中的任何地方使用的全局记录器？我们无法读取你的思想ーー在 README 文件中提到这一点！ 没有太多的文档(至少我没有遇到过这种情况) ，只有缺乏关于项目和代码的信息。所有生成、测试和运行代码的命令、各种文件结构决策、图表、外部工具和服务、关于不同环境的信息(没有 SECRET KEYS)都应该放在这里，并保存在一个单独的地方。这是一个无聊的工作，但却是一个非常有价值的工作！ Phew, what a ride… ( 这车真不错… .source 来源) 就是这样! 谢谢你花时间阅读这篇文章。 我错过了什么吗? 在评论中提及吧! 在构建一个新的 Flutter 应用程序时，你的清单是什么？ © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"基于 Linux 的 Flutter 方法通道 Channels","date":"2021-09-23T16:00:00.000Z","path":"2021/09/24/translation/using-flutter-method-channels-on-linux/","text":"原文 https://medium.com/flutter-community/using-flutter-method-channels-on-linux-2f6ae3e99653 代码https://github.com/charafau/linux_method_channel 参考 https://flutter.dev/docs/development/platform-integration/platform-channels https://engine.chinmaygarde.com/fl__value_8cc.html https://engine.chinmaygarde.com/fl__value_8h.html#a1b2a2f35eb78370fbb2d1af774f6d245 https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools 正文Flutter Method Channels on Linux基于 Linux 的 Flutter 方法通道又见面了！今天我将继续我的 Flutter Linux 之旅，我们将再次接触 Linux 集成。上次我们设法为插件开发设置了 Visual Studio Code，今天我们将进一步研究 Method Channels。 如果你想创建一个带有方法通道支持的插件，非常简单，只需要使用 flutter create \\-t plugin \\--platforms=linux &lt;name of your project&gt; 从模板生成一个 Flutter 项目。但是，如果你不想创建一个单独的插件，只是添加一些自定义代码到 Flutter Linux 应用程序中呢？我发现这并不简单，所以我想我会写这篇文章，这样你就不用自己解决了。 为了不再拖延下去，让我们开始吧。 创建方法通道首先，我们需要创建编解码器 codec ，binary messenger 二进制信使和信道。接下来，我们将向自定义方法分配一个方法调用，我们将在下一步中创建这个方法。 为此，让我们打开我的 my_application.cc 。在 linux 文件夹中抄送并导航到我的 my_application_activate 函数。接下来，我们在插件初始化之后实现上面描述的对象。 在下面的示例中，name_of_our_channel 的名称是我们从 Dart 代码调用的方法。 回调函数现在我们来创建一个回调函数: 非常简单，我们传递一个通道、 methodcall 和一些用户数据。 To check for the channel’s method name we need to use the fl_method_call_get_name function on method_call object. And compare it with strcmp like so: 为了检查通道的方法名，我们需要在 method_call 对象上使用 fl_method_call_get_name 函数。然后把它和 strcmp 比较，就像这样: 方法未实现响应如果传递给 channel 的方法不存在，我们需要返回未实现的结果来做这件事，我们需要调用 fl_method_call_respond 错误处理在开始讨论参数和自定义结果之前，让我们先快速了解一下错误处理。 幸运的是，它与未实现的方法非常相似: 我们可以看到它几乎是相同的，我们只是用 fl_method_error_response_new 创建结果，而不是用 fl_method_not_implemented_response_new。 获取 Dart 参数好了，现在是时候从头开始写我们想写的东西了。让我们假设我们想要从 Dart 发送数据到 c + + ，为了做到这一点，我们只需要从 Dart 端发送一个地图，但是如何获取呢？ 为此，我们需要调用 fl_method_call_get_args(FlMethodCall) ，它返回一个指向 FlValue 的指针。 接下来我们检查返回的值是否是正确的类型: 在上面的例子中，我们查找字符串，但是还有其他的，比如 int、 float、 bool、 map。对于完整的清单检验 Flutter Engine Documentation 类型检查也是一样，检查枚举的整个列表到 Documentation 返回一些值我们几乎完成了，我们设法处理了未实现的方法、错误和从方法中获取参数。剩下的是返回 Dart 的值。 对我们来说幸运的是，这与我们已经完成的工作非常相似，我们只需要创建 FlMethodResponse 并将 FlValue 放入其中。下面是一个例子: 像前面一样，这里有更多价值创造函数的文档链接 link to documentation for more value creation function 代码完成 + 调试我想我应该给你一些奖励，因为你来到这里，所以我决定在 Visual Studio Code 中编写代码完成和调试的设置程序。 在开始之前，必须安装 C++ 和 Cmake 插件。 首先让我们设置代码完成。创建名为 c_cpp_properties.json 的文件。Json 在里面。在你的项目的根目录下放一个 .vscode 文件夹，然后把这个配置文件放进去: 检查编译器路径(Flutter 使用 Clang)并根据需要调整 c/c + + 标准。 为了设置调试，我们需要在 launch.json 中创建启动配置 .vscode 文件夹。让我们来看一下配置: 非常简单，但是需要更改二进制名称。此外，要知道，使它的工作，你需要建立您的 Flutter 项目与 flutter run。 本文结束谢谢你的阅读，希望你会发现它很有用。 编程愉快！ 完整的例子可以在这里找到。 https://github.com/charafau/linux_method_channel © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter 最简单的应用程序图标制作方法","date":"2021-09-16T16:00:00.000Z","path":"2021/09/17/translation/the-easiest-way-to-make-app-icons-in-flutter/","text":"原文 https://medium.com/@bharadwaj.palakurthy/the-easiest-way-to-make-app-icons-in-flutter-9fe1bc9dd646 参考 https://pub.flutter-io.cn/packages/flutter_launcher_icons 正文 让我们承认这一点ーー管理应用程序图标是一项重复的任务。他们必须生成的多分辨率和手动放置在几个文件夹，这是一个世俗的任务采取。你可能需要做一些小的改变或者修改，现在你必须重复整个替换图标的过程。 不仅如此，根据我们选择的平台或操作系统的版本，还应用了不同的规则。所以把这些都记在心里，这个过程最好是自动化，而不是手动完成。我们将在这里使用这个名为“ flutter_launcher_icons”的 flutter 包来自动生成所有需要的分辨率。 Flutter Launcher Icons:一个命令行工具，简化了更新应用程序启动图标的任务。完全灵活，允许你选择你想要更新启动器图标的平台，如果你想要的话，选择保留你的旧启动器图标，以防你想在未来的某个时候返回。 先决条件在任何情况下，当从图形编辑器导出时，应该是: Format: 32-bit 格式: 32 位PNG 巴布亚新几内亚 Icon size 图标大小must be up to 1024x1024 pixels 必须达到 1024x1024 像素 确保在 40 像素处可见(这是最小的图标)(Apple Requirement) (苹果需求) 最大尺寸1024KB (Android Requirement) 1024KB (Android 版本要求) 图标必须用no transparency 没有透明度 形状必须是正方形no rounded corners 没有圆角 需要一个自适应的 android 图标background 背景and 及foreground 前景to be separated 分开 安卓产品图标关键字 The intended look might be different from the guidelines provided by the platforms. So we’ll be creating 3 different flavors for android, iOS, adaptive icons. 预期的外观可能与平台提供的指导方针不同。因此，我们将为 android、 iOS 和自适应图标创建三种不同的风格。 预期外观 Android and iOS (no transparency) 安卓和 iOS (没有透明度) Adaptive Icons for Android 8.0 and above 8.0 及以上版本的自适应图标 实施方案:我们将使用一个名为 flutter_launcher_icons 的包 现在我们需要分别在你的代码中实现它: 第一步: 添加依赖项。 将 dependency 添加到位于 Flutter 项目根目录中的 pubspec.yaml 文件: 12dev_dependencies: flutter_launcher_icons: any 第二步: 配置属性 1234567flutter_icons: ios: true android: true image_path_ios: \"assets/launcher/icon.png\" image_path_android: \"assets/launcher/icon.png\" adaptive_icon_background: \"assets/launcher/background.png\" adaptive_icon_foreground: \"assets/launcher/foreground.png\" 图像在你的 assets/launcher/ 第三步: 运行包 设置完配置后，剩下要做的就是运行包。 12flutter pub getflutter pub run flutter_launcher_icons:main 第四步: 跑步 如果一切顺利，资产已经产生。现在，您已经准备好构建应用程序并运行它了。恭喜你 属性: 目前，它只能用于为 android/ios 分配图标 image_path 图像路径: : 图标图像文件的位置，你想用它作为应用程序启动图标 image_path_android 图片/path/android: : 特定于 Android 平台的图标图像文件的位置 image_path_ios 图片/path/ios: : 特定于 iOS 平台的图标图像文件位置 接下来的两个属性只在生成 Android 启动器图标时使用 adaptive_icon_background 背景: You can pass in a solid color (E.g. “#ffffff”) or image asset (E.g. “assets/images/christmas-background.png”) which will be used to fill out the background of the adaptive icon. adaptive_icon_foreground 自适应图标前景: The image asset which will be used for the icon foreground of the adaptive icon : 将用于自适应图标的前景图标的图像资产 Thank you!谢谢 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter 多选项目插件","date":"2021-09-15T16:00:00.000Z","path":"2021/09/16/translation/explore-multi-select-items-in-flutter/","text":"原文 https://medium.com/flutterdevs/explore-multi-select-items-in-flutter-a90665e17be 参考 https://pub.dev/packages/multi_select_item 正文 Flutter 小部件是使用现代框架构建的。这就像是一种反应。在这里，我们从小部件开始创建任何应用程序。屏幕中的每个组件都是一个小部件。这个小部件描述了根据他目前的配置和状态，他的前景应该是什么样的。小部件展示类似于它的想法和当前的设置和状态。 Flutter 自动化测试使您能够满足您的应用程序的高响应性，因为它有助于在您的应用程序中发现 bug 和各种问题。 Flutter 是一个工具，开发移动，桌面，网络应用程序与代码 \\&amp; 是一个免费和开放源码的工具。 Flutter 有能力容易测试任何应用程序。这种能力就是他们在目标平台上按照我们希望的方式工作。 Dart 测试适用于单元测试和非 ui 测试; 它在开发机器上运行，不依赖于 Flutter 应用程序的 GUI。 在这个博客，我们将探索 Flutter 多选择项目。我们还将实现一个演示的多项目在 Flutter 选择。如何使用它们在您的 Flutter 应用程序。那么让我们开始吧。 多选择项 | Flutter 包装 https://pub.dev/packages/multi_select_item 多选项目:多选项这是一个处理多选项的 Flutter 库使用这个库我们创建一个列表，当我们可以删除这个列表中的项目时使用这个小部件我们将它包装在列表视图构建器项目中，这样我们就可以很容易地创建一个多选项列表。 实施方案:你需要分别在你的代码中实现它: 第一步: 添加依赖项。 将依赖项添加到 pubspec ー yaml 文件。 首先，在 pubspec. yaml 中添加 flutter 本地化和 intl 库。 12dependencies: multi_select_item: ^1.0.3 步骤 2: 导入包: 1import 'package:multi_select_item/multi_select_item.dart'; 第三步: 启用 AndriodX 1234org.gradle.jvmargs=-Xmx1536Mandroid.enableR8=trueandroid.useAndroidX=trueandroid.enableJetifier=true 代码步骤:要实现这一点，您需要先编写“首先定义控制器”。 1MultiSelectController controller = new MultiSelectController(); 在此之后，我们创建了一个列表，该列表在 initState ()内定义了它的值，并在此之后按列表长度确定控制器的设置长度。参考下面的代码包括在内。 123456789101112@overridevoid initState() &#123; super.initState(); multiSelectList.add(&#123;\"images\": 'assets/images/resort_1.jpg', \"desc\":\"Welcome to New York City!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/resort_2.jpg' ,\"desc\":\"Welcome to Los Angeles!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/resort_3.jpg' ,\"desc\":\"Welcome to Chicago!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/resort_4.jpg', \"desc\":\"Welcome to Houston!\"&#125;); controller.disableEditingWhenNoneSelected = true; controller.set(multiSelectList.length);&#125; 在这之后，我们使用一个 ListViewBuilder 小部件，其中我们使用了 MultiSelectItem ()小部件，其中我们使用了卡片及其子属性，我们使用了行小部件，其中我们初始化上面定义的列表值，该列表值具有图像和文本，并在其 onSelected ()上列出控制器是在 setState 内部定义的，用于选择值。 12345678910111213141516171819202122232425262728293031323334353637383940414243ListView.builder( itemCount: multiSelectList.length, itemBuilder: (context, index) &#123; return MultiSelectItem( isSelecting: controller.isSelecting, onSelected: () &#123; setState(() &#123; controller.toggle(index); &#125;); &#125;, child:Container( height:75, margin: EdgeInsets.only(left:15,right:15,top:15), decoration: BoxDecoration( borderRadius: BorderRadius.circular(12), color: Colors._transparent_, ), child:Card( color:controller.isSelected(index) ? Colors._grey_.shade200:Colors._white_, shape: RoundedRectangleBorder( borderRadius: BorderRadius.all(Radius.circular(8.0)), ), child:Padding( padding:EdgeInsets.symmetric(vertical:10, horizontal: 12), child: Row( children: [ _//contentPadding: EdgeInsets.symmetric(vertical: 12, horizontal: 16),_ ClipRRect( borderRadius: BorderRadius.circular(12), child:Image.asset(multiSelectList[index]['images'],fit:BoxFit.cover,width:60,height:60,), ), SizedBox(width:20,), Text(multiSelectList[index]['desc'], style: TextStyle(fontSize:14)), ], ), ), ), ), ); &#125;,), 之后，我们将删除选定的项目，以删除这我们采取 forEach 和排序的价值，这将排序我们的选择项目首先从最大的 id 最小的 id，然后它将逐一删除它。 123456789101112void delete() &#123; var list = controller.selectedIndexes; list.sort((b, a) =&gt; a.compareTo(b)); list.forEach((element) &#123; multiSelectList.removeAt(element); &#125;); setState(() &#123; controller.set(multiSelectList.length); &#125;);&#125; 全部代码 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import 'package:multi_select_item/multi_select_item.dart';import 'package:flutter/material.dart';class MultiSelectListDemo extends StatefulWidget &#123; @override _MultiSelectListDemoState createState() =&gt; new _MultiSelectListDemoState();&#125;class _MultiSelectListDemoState extends State&lt;MultiSelectListDemo&gt; &#123; List multiSelectList = []; MultiSelectController controller = new MultiSelectController(); @override void initState() &#123; super.initState(); multiSelectList.add(&#123;\"images\": 'assets/images/resort_1.jpg', \"desc\":\"Welcome to New York City!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/resort_2.jpg' ,\"desc\":\"Welcome to Los Angeles!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/resort_3.jpg' ,\"desc\":\"Welcome to Chicago!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/resort_4.jpg', \"desc\":\"Welcome to Houston!\"&#125;); multiSelectList.add(&#123;\"images\":'assets/images/sanfrancisco.jpg', \"desc\":\"Welcome to San francisco!\"&#125;); controller.disableEditingWhenNoneSelected = true; controller.set(multiSelectList.length); &#125; void add() &#123; multiSelectList.add(&#123;\"images\": multiSelectList.length&#125;); multiSelectList.add(&#123;\"desc\": multiSelectList.length&#125;); setState(() &#123; controller.set(multiSelectList.length); &#125;); &#125; void delete() &#123; var list = controller.selectedIndexes; list.sort((b, a) =&gt; a.compareTo(b)); list.forEach((element) &#123; multiSelectList.removeAt(element); &#125;); setState(() &#123; controller.set(multiSelectList.length); &#125;); &#125; void selectAll() &#123; setState(() &#123; controller.toggleAll(); &#125;); &#125; @override Widget build(BuildContext context) &#123; return WillPopScope( onWillPop: () async &#123; var before = !controller.isSelecting; setState(() &#123; controller.deselectAll(); &#125;); return before; &#125;, child: new Scaffold( appBar: new AppBar( title: new Text('Selected $&#123;controller.selectedIndexes.length&#125;' ), actions: (controller.isSelecting) ? &lt;Widget&gt;[ IconButton( icon: Icon(Icons._select_all_), onPressed: selectAll, ), IconButton( icon: Icon(Icons._delete_), onPressed: delete, ) ] : &lt;Widget&gt;[], ), body:Container( child: ListView.builder( itemCount: multiSelectList.length, itemBuilder: (context, index) &#123; return InkWell( onTap: () &#123;&#125;, child: MultiSelectItem( isSelecting: controller.isSelecting, onSelected: () &#123; setState(() &#123; controller.toggle(index); &#125;); &#125;, child:Container( height:75, margin: EdgeInsets.only(left:15,right:15,top:15), decoration: BoxDecoration( borderRadius: BorderRadius.circular(12), color: Colors._transparent_, ), child:Card( color:controller.isSelected(index) ? Colors._grey_.shade200:Colors._white_, shape: RoundedRectangleBorder( borderRadius: BorderRadius.all(Radius.circular(8.0)), ), child:Padding( padding:EdgeInsets.symmetric(vertical:10, horizontal: 12), child: Row( children: [ _//contentPadding: EdgeInsets.symmetric(vertical: 12, horizontal: 16),_ ClipRRect( borderRadius: BorderRadius.circular(12), child:Image.asset(multiSelectList[index]['images'],fit:BoxFit.cover,width:60,height:60,), ), SizedBox(width:20,), Text(multiSelectList[index]['desc'], style: TextStyle(fontSize:14)), ], ), ), ), ), ), ); &#125;, ), ), ), ); &#125;&#125; 结语:在本文中，我解释了 Explore GetIt In Flutter，你可以根据自己的修改和实验，这个小介绍来自 Explore GetIt In Flutter 从我们这边的演示。 我希望这个博客将为您提供充分的信息，在尝试在您的 Flutter 项目探索 GetIt 在 Flutter 。我们向你展示了什么是探索和 Flutter 是在您的 Flutter 应用的工作，所以请尝试它。 如果我做错了什么，请在评论中告诉我，我很乐意改进。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter SnackBar 组件插件","date":"2021-09-13T16:00:00.000Z","path":"2021/09/14/translation/snackbar-widget-in-flutter/","text":"原文 https://medium.com/flutterdevs/snackbar-widget-in-flutter-476bb2431538 代码https://github.com/flutter-devs/flutter_snackbar_demo 参考 https://pub.flutter-io.cn/packages/another_flushbar 正文了解如何创建静态和自定义 SnackBar 小部件在您的 Flutter 应用程序 无论何时你要编写在 Flutter 构建任何东西的代码，它都会在一个小部件中。Flutter 应用程序屏幕上的每个元素都是一个小部件。屏幕的透视图完全依赖于用于构建应用程序的小部件的选择和分组。此外，应用程序代码的结构是一个小部件树。 在本博客中，我们将了解静态和自定义 SnackBar 小部件及其在 flutter 中的功能。我们将在这个 SnackBar Widget 小部件上看到一个简单演示程序的实现。 https://pub.flutter-io.cn/packages/another_flushbar 在 Flutter 中，SnackBar 是一个小工具，它可以轻量级地在你的应用程序中弹出一条快速消息，在发生事情时短暂地标示出用户。使用 SnackBar，你可以在你的应用程序底部弹出一条消息几秒钟。 默认情况下，SnackBar 显示在屏幕的底部，当指定的时间完成，它将从屏幕上消失，我们可以使一个自定义的 SnackBar 也和它包含一些行动，允许用户添加或删除任何行动和图像。SnackBar 需要一个 Scaffold，带有一个 Scaffold 实例，你的 SnackBar 会立即弹出。通过使用 scaffold，可以很容易地在小部件树中的任何位置获得 scaffold 的引用。功能。 演示模块: 如何实现 dart 文件中的代码: 你需要分别在你的代码中实现它: 首先，在这个 Dart 文件中，我创建了两个按钮，第一个按钮用于显示默认的 SnackBar，第二个按钮用于自定义 SnackBar。 Default SnackBar 默认 SnackBar 显示 SnackBar 有两个步骤。首先，您必须创建一个 SnackBar，这可以通过调用以下构造函数来完成。非常简单易用。这是密码。 12final snackBar = SnackBar(content: Text('Yay! A DefaultSnackBar!'));ScaffoldMessenger._of_(context).showSnackBar(snackBar); 但默认情况下，我们的一些要求没有得到满足。所以 May 自定义 SnackBar 正在做这件事。对于自定义 SnackBar，我必须使用 Flushbar 依赖项。这是一个非常和谐的依赖性设计您的自定义 SnackBar 根据您的选择。 首先，在 pubspec.yaml 中添加 SnackBar 的依赖项 1another_flushbar: ^1.10.24 然后必须创建一个方法来显示自定义 SnackBar。 123456789101112131415161718192021222324252627void showFloatingFlushbar( &#123;@required BuildContext? context, @required String? message, @required bool? isError&#125;)&#123; Flushbar? flush; bool? _wasButtonClicked; flush = Flushbar&lt;bool&gt;( title: \"Hey User\", message: message, backgroundColor: isError! ? Colors._red_ : Colors._blueAccent_, duration: Duration(seconds: 3), margin: EdgeInsets.all(20), icon: Icon( Icons._info_outline_, color: Colors._white_,), mainButton: FlatButton( onPressed: () &#123; flush!.dismiss(true); _// result = true_ &#125;, child: Text( \"ADD\", style: TextStyle(color: Colors._amber_), ), ),) _// &lt;bool&gt; is the type of the result passed to dismiss() and collected by show().then((result)&#123;&#125;)_ ..show(context!).then((result) &#123; &#125;);&#125; 当我们运行应用程序时，我们应该获得屏幕输出，就像下面的屏幕截图一样。 Custom SnackBar 自定义 SnackBar 全部代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145import 'package:another_flushbar/flushbar.dart';import 'package:flutter/material.dart';class SnackBarView extends StatefulWidget &#123; const SnackBarView(&#123;Key? key&#125;) : super(key: key); @override _SnackBarViewState createState() =&gt; _SnackBarViewState();&#125;class _SnackBarViewState extends State&lt;SnackBarView&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ _buildSnackBarButton() ], ), ); &#125; Widget _buildSnackBarButton() &#123; return Column( children: [ Center( child: InkWell( onTap: ()&#123; final snackBar = SnackBar(content: Text('Yay! A Default SnackBar!')); ScaffoldMessenger._of_(context).showSnackBar(snackBar); &#125;, child: Container( height: 40, width: 180, decoration: BoxDecoration( color: Colors._pinkAccent_, borderRadius: BorderRadius.all(Radius.circular(15)) ), child: Center( child: Text(\"SnackBar\", style: TextStyle( color: Colors._white_, fontSize: 16, ),), ), ), ), ), SizedBox(height: 10,), Center( child: InkWell( onTap: ()&#123; showFloatingFlushbar(context: context, message: 'Custom Snackbar!', isError: false); _// showSnackBar( // context: context, // message: 'Custom Snackbar!', // isError: false);_ &#125;, child: Container( height: 40, width: 180, decoration: BoxDecoration( color: Colors._pinkAccent_, borderRadius: BorderRadius.all(Radius.circular(15)) ), child: Center( child: Text(\"Custom SnackBar\", style: TextStyle( color: Colors._white_, fontSize: 16, ),), ), ), ), ), ], ); &#125;&#125;void showFloatingFlushbar( &#123;@required BuildContext? context, @required String? message, @required bool? isError&#125;)&#123; Flushbar? flush; bool? _wasButtonClicked; flush = Flushbar&lt;bool&gt;( title: \"Hey User\", message: message, backgroundColor: isError! ? Colors._red_ : Colors._blueAccent_, duration: Duration(seconds: 3), margin: EdgeInsets.all(20), icon: Icon( Icons._info_outline_, color: Colors._white_,), mainButton: FlatButton( onPressed: () &#123; flush!.dismiss(true); _// result = true_ &#125;, child: Text( \"ADD\", style: TextStyle(color: Colors._amber_), ), ),) _// &lt;bool&gt; is the type of the result passed to dismiss() and collected by show().then((result)&#123;&#125;)_ ..show(context!).then((result) &#123; &#125;);&#125;void showSnackBar( &#123;@required BuildContext? context, @required String? message, @required bool? isError&#125;) &#123; final snackBar = SnackBar( content: Text( message!, style: TextStyle(fontSize: 14.0, fontWeight: FontWeight._normal_), ), duration: Duration(seconds: 3), backgroundColor: isError! ? Colors._red_ : Colors._green_, width: 340.0, padding: const EdgeInsets.symmetric( horizontal: 8.0, ), behavior: SnackBarBehavior.floating, shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(10.0), ), action: SnackBarAction( label: 'Undo', textColor: Colors._white_, onPressed: () &#123;&#125;, ), ); ScaffoldMessenger._of_(context!).showSnackBar(snackBar);&#125; Conclusion:结语:在本文中，我已经简单介绍了 SnackBar 小部件的基本概况，您可以根据自己的选择修改这段代码。这是我对 SnackBar Widget On User Interaction 的一个小小介绍，它正在使用 Flutter 工作。 我希望这个博客将提供您尝试在您的 Flutter 项目探索，SnackBar 小工具充分的信息。 如果我做错了什么，请在评论中告诉我，我很乐意改进。 鼓掌如果这篇文章对你有帮助的话。 GitHub Link:链接:找到 Flutter SnackBar Demo 的源代码: https://github.com/flutter-devs/flutter_snackbar_demo © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Dart 2.14 发布 新增语言特性","date":"2021-09-10T16:00:00.000Z","path":"2021/09/11/translation/announcing-dart-2-14/","text":"原文 https://medium.com/dartlang/announcing-dart-2-14-b48b9bb2fb67 正文Dart 2.14 的发布对 Apple Silicon 处理器提供了更好的支持，并新增了更多提升生产力的功能，例如通过代码样式分析捕获 lint 错误、更快的发布工具、更好的级联代码格式以及一些细小的语言特性更新。 Dart SDK 对 Apple Silicon 支持自从在 2020 年末 Apple 发布了新的 Apple Silicon 处理器以来， Dart SDK 一直致力于增加对该处理器上的 Native 执行支持。 现在从 Dart 2.14.1 正式增加了对 Apple Silicon 的支持，当 下载 MacOS 的 Dart SDK 时，一定要选择 ARM64 选项，这里需要额外注意， Flutter SDK 中的 Dart SDK 还没有绑定这一项改进。 本次更新支持在 Apple Silicon 上运行 SDK/Dart VM 本身，以及对 dart compile 编译后的可执行文件在 Apple Silicon 上运行的支持，由于 Dart 命令行工具使用原生 Apple Silicon ，因此它们的启动速度会快得多 。 Dart 和 Flutter 共享的标准 lint开发人员通常会需要他们的代码遵循某种风格，其中许多规则不仅仅是风格偏好（如众所周知的制表符与空格的问题），还涵盖了可能导致错误或引入错误的编码风格。 比如 Dart 风格指南要求对所有控制流结构使用花括号，例如 if-else 语句，这可以防止经典的 dangling else 问题，也就是在多个嵌套的 if-else 语句上会存在解释歧义。 另一个例子是类型推断，虽然在声明具有初始值的变量时使用类型推断没有问题，但在声明未初始化的变量 时指定类型很重要，因为这可以确保类型安全。 良好代码风格的通常是通过代码审查来维持，但是通过在编写代码时，运行静态分析来强制执行规则通常会更有效得多。 在 Dart 中，这种静态分析规则是高度可配置的，Dart 提供了有数百条样式规则（也称为lints），有了如此丰富的选项，选择启用这些的规则时，一开始可能会有些不知所措。 配置支持： dart.dev/guides/lang… lint 规则： dart.dev/tools/linte… Dart 团队维护了一个 Dart 风格指南，它描述了 Dart 团队认为编写和设计 Dart 代码的最佳方式。 风格指南: dart.dev/guides/lang… 许多开发人员以及 pub.dev 站点评分引擎都使用了一套叫 Pedantic 的 lint 规则， Pedantic 起源于 Google 内部的 Dart 风格指南，由于历史原因它不同于一般的 Dart 风格指南，此外 Flutter 框架也从未使用过 Pedantic 的规则集，而是拥有自己的一套规范规则。 这听起来可能有点混乱，但是在本次的 2.14 发布中，Dart 团队很高兴地宣布现在拥有一套全新的 lint 集合来实现代码样式指南，并且 Dart 和 Flutter SDK 默认情况下将这些规则集用于新项目： package:lints/core.yaml： 所有 Dart 代码都应遵循的 Dart 风格指南中的主要规则，pub.dev 评分引擎已更新为 lints/core 而不是 Pedantic。 package:lints/recommended.yaml ：核心规则之外加上推荐规则，建议将它用于所有通用 Dart 代码。 package:flutter_lints/flutter.yaml：核心和推荐之外的 Flutter 特定推荐规则，这个集合推荐用于所有 Flutter 代码。 如果你已经存在现有的 Dart 或者 Flutter 项目，强烈建议升级到这些新规则集，从 pedantic 升级只需几步：github.com/dart-lang/l… 。 Dart 格式化程序和级联Dart 2.14 对 Dart 格式化程序如何使用级联 格式化代码进行了一些优化。 以前格式化程序在某些情况下出现一些令人困惑的格式，例如 doIt() 在这个例子中调用了什么？ 12var result = errorState ? foo : bad..doIt();复制代码 它看起来像是被 bad 调用 ，但实际上级联适是用于整个 ? 表达式上的，因此级联是在该表达式的结果上调用的，而不仅仅是在 false 子句上，新的格式化程序清晰地描述了这一点： 123 var result = errorState ? foo : bad..doIt();复制代码 Dart 团队还大大提高了格式化包含级联的代码的速度；在协议缓冲区生成的 Dart 代码中，可以看到格式化速度提高了 10 倍。 Pub 支持忽略文件目前当开发者将包发布到pub.dev社区时，pub 会抓取该文件夹中的所有文件，但是会跳过隐藏文件（以 . 开头的文件）和.gitignore 文件。 Dart 2.14 中更新的 pub 命令支持新 .pubignore 文件，开发者可以在其中列出不想上传到 pub.dev 的文件，此文件使用与 .gitignore 文件相同的格式。 有关详细信息，请参阅包发布文档 dart.dev/tools/pub/p… Pub and “dart test” 性能虽然 pub 最常用于管理代码依赖项，但它还有第二个重要的用途：驱动工具。 比如 Dart 测试工具通过 dart test 命令运行，而它实际上只是 command pub run test:test 命令的包装， package:test 在调用该 test 入口点之前，pub 首先将其编译为可以更快运行的本机代码。 在 Dart 2.14 之前对 pubspec 的任何更改（包括与 package:test 无关的更改）都会使此测试构建无效，并且还会看到一堆这样的输出，其中包含“预编译可执行文件”： 12345$ dart testPrecompiling executable... (11.6s)Precompiled test:test.00:01 +1: All tests passed!复制代码 在 Dart 2.14 中，pub 在构建步骤方面更加智能，让构建仅在版本更改时发生，此外还使用并行化改进了执行构建步骤的方式，因此可以完成得更快。 新的语言功能Dart 2.14 还包含一些语言特性变化。 首先添加了一个新的 三重移位 运算符 ( &gt;&gt;&gt;)，这类似于现有的移位运算符 ( &gt;&gt;)，但 &gt;&gt; 执行算术移位，&gt;&gt;&gt; 执行逻辑或无符号移位，其中零位移入最高有效位，而不管被移位的数字是正数还是负数。 此次还删除了对类型参数的旧限制，该限制不允许使用泛型函数类型作为类型参数，以下所有内容在 2.14 之前都是无效的，但现在是允许的： 1234late List&lt;T Function&lt;T&gt;(T)&gt; idFunctions;var callback = [&lt;T&gt;(T value) =&gt; value];late S Function&lt;S extends T Function&lt;T&gt;(T)&gt;(S) f;复制代码 最后对注释类型进行了小幅调整，（诸如 @Deprecated 在 Dart 代码中常用来捕获元数据的注解）以前注解不能传递类型参数，因此 @TypeHelper&lt;int&gt;(42, &quot;The meaning&quot;) 不允许使用诸如此类的代码，而现在此限制现已取消。 包和核心库更改对核心 Dart 包和库进行了许多增强修改，包括： dart:core： 添加了静态方法 hash、hashAll 和 hashAllUnordered。 dart:core： DateTime 类现在可以更好地处理本地时间。 package:ffi：添加了对使用 arena 分配器管理内存的支持（示例）。Arenas 是一种基于区域的内存管理形式，一旦退出 arena/region 就会自动释放资源。 package:ffigen：现在支持从 C 类型定义生成 Dart 类型定义。 重大变化Dart 2.14 还包含一些重大更改，预计这些变化只会影响一些特定的用例。 #46545：取消对 ECMAScript5 的支持所有浏览器都支持最新的 ECMAScript 版本，因此两年前 Dart 就宣布 计划弃用对 ECMAScript 5 (ES5) 的支持，这使 Dart 能够利用最新 ECMAScript 中的改进并生成更小的输出，在 Dart 2.14 中，这项工作已经完成，Dart Web 编译器不再支持 ES5。因此不再支持较旧的浏览器（例如 IE11）。 #46100：弃用 stagehand、dartfmt 和 dart2native在 2020 年 10 月的 Dart 2.10 博客文章中 宣布了将所有 Dart CLI 开发人员工具组合成一个单一的组合dart工具（类似于该flutter工具），而现在 Dart 2.14 弃用了 dartfmt 和 dart2native 命令，并停止使用 stagehand ，这些工具在统一在 dart-tool 中都有等价的替代品。 #45451：弃用 VM Native 扩展Dart SDK 已弃用 Dart VM 的 Native 扩展，这是从 Dart 代码调用 Native 代码的旧机制，Dart FFI（外来函数接口）是当前用于此用例的新机制，正在积极发展 以使其功能更加强大且易于使用。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 2.5 的新功能","date":"2021-09-09T16:00:00.000Z","path":"2021/09/10/translation/whats-new-in-flutter-2-5-6/","text":"原文 https://medium.com/flutter/whats-new-in-flutter-2-5-6f080c3f3dc 正文您好，欢迎来到 Flutter 2.5！这是一个大版本，在 Flutter 版本历史上排名第二：关闭了 4600 个问题，从 252 个贡献者和 216 个审阅者合并了 3932 个 PR。如果我们回顾过去一年，我们会看到 1337 位贡献者创建了 21,072 个巨大的 PR，其中 15,172 个被合并。虽然“Flutter 中的新功能”博客文章重点介绍了新功能，但我们在 Flutter 方面的第一项工作始终是确保您拥有所需的功能，并达到最高的质量水平。 事实上，此版本继续了许多重要的性能和工具改进，以跟踪您自己的应用程序中的性能问题。同时，还有许多新功能，包括对 Android 的全屏支持、更多 Material You（也称为 v3）支持、更新的文本编辑以支持可切换的键盘快捷键、在 Widget Inspector，对在 Visual Studio Code 项目中添加依赖项的新支持，对从 IntelliJ/Android Studio 中的测试运行获取覆盖率信息的新支持，以及一个全新的应用程序模板，为您的真实 Flutter 应用程序提供更好的基础。此版本充满了令人兴奋的新更新，让我们开始吧。 性能：iOS 着色器预热、异步任务、GC 和消息传递此版本带来了多项性能改进。此列表中的第一个 PR 用于从离线训练运行 ( #25644 ) 中连接 Metal 着色器预编译，它（如我们的基准测试所示）将最坏情况的帧光栅化时间减少了 2/3 秒，将第 99 个百分位帧减少了一半。我们继续在减少 iOS 卡顿方面取得进展，这是沿着这条道路迈出的又一步。然而，着色器预热只是卡顿的来源之一。以前，处理来自网络、文件系统、插件或其他隔离的异步事件可能会中断动画，这是另一个卡顿的来源。以下改进调度策略 ( #25789) 在此版本的 UI 隔离的事件循环中，帧处理现在优先于处理其他异步事件，从而在我们的测试中消除了此源的卡顿。 image.png 由于前后处理异步事件结果导致的帧滞后 另一个导致卡顿的原因是垃圾收集器 (GC) 暂停 UI 线程以回收内存。以前，某些图像的内存只会延迟回收以响应 Dart VM 执行的 GC。作为早期版本中的解决方法，Flutter 引擎会向 Dart VM 暗示图像内存可以通过 GC 回收，这在理论上可以导致更及时的内存回收。不幸的是，在实践中，这导致了太多的主要 GC，并且有时仍然无法足够快地回收内存以避免内存受限设备上的低内存情况。在这个版本中，未使用的图像的内存被急切地回收（#26219、#82883、#84740），大大减少了 GC。 image.png 添加修复程序之前和之后的 GC 以急切地回收未使用的大图像内存 例如，在我们的一项测试中，播放 20 秒动画 GIF 从需要 400 多次 GC 变为只需要 4 次。更少的主要 GC 意味着涉及图像出现和消失的动画将减少卡顿，并消耗更少的 CPU 和功率。 Flutter 2.5 的另一个性能改进是在 Dart 和 Objective-C/Swift (iOS) 或 Dart 和 Java/Kotlin (Android) 之间发送消息时的延迟。通常作为调整消息频道的一部分，从消息编解码器中删除不必要的副本可将延迟减少多达 50%，具体取决于消息大小和设备（#25988，#26331）。 image.png 之前和之后的 iOS 消息延迟 您可以在Aaron Clarke撰写的提高 Flutter中的平台通道性能博客文章中阅读有关这项工作的详细信息。 如果您的目标是 iOS，那么最后一个性能更新：在此版本中，在 Apple Silicon M1 Mac 上构建的 Flutter 应用程序在 ARM iOS 模拟器 ( #pull/85642 )上本地运行。这意味着 Intel x86_64 指令和 ARM 之间没有 Rosetta 转换，这会提高您的 iOS 应用程序测试期间的性能，并允许您避免一些微妙的 Rosetta 问题（#74970、#79641）。这是全面支持 Flutter for Apple Silicon 的又一步。请继续关注更多。 Dart 2.14：格式、语言特性、发布和 linting 开箱即用当然，如果没有 Dart 语言和构建它的运行时，Flutter 就不是 Flutter。此版本的 Flutter 随 Dart 2.14 一起发布。新版本的 Dart带有新的格式，使级联更加清晰，新的 pub 支持忽略文件，以及新的语言功能，包括传奇的三重移位运算符的回归。此外，也是 Dart 2.14 最好的事情之一，是此版本创建了一组标准的 lint，在新的 Dart 和 Flutter 项目之间共享，开箱即用。 image.png _flutter create 开箱即用，带有一个 analysis_options.yaml 文件，其中预先填充了推荐的 Flutter lints_ 您不仅会在创建新的 Dart 或 Flutter 项目时获得这些 lint，而且只需几个步骤，您也可以将相同的分析添加到现有应用程序中。有关这些 lint 的详细信息、新语言功能等，请查看Dart 2.14 的发布公告。 框架：Android 全屏、Material You &amp; 文本编辑快捷方式Flutter 2.5 版本包括对该框架的许多修复和改进。从Android开始，我们修复了一系列与全屏模式相关的问题，在它们之间有近 100 次竖起大拇指。模式本身的名称使其成为我们最喜欢的新功能之一：向后倾斜、粘性、粘性沉浸和边缘到边缘。此更改还添加了一种在其他模式下收听全屏更改的方法。例如，如果用户与应用互动，当系统 UI 返回时，开发人员现在可以编写代码以返回全屏或执行其他操作。 image.png 新的 Android 边到边模式：普通模式（左）、边到边模式（中）、带有自定义 SystemUIOverlayStyle 的边到边（右） 在此版本中，我们继续构建对新 Material You（又名 v3）规范的支持，包括对浮动操作按钮大小和主题的更新（#86441），以及 MaterialState.scrolledUnder 您可以使用示例代码中的示例代码查看的新状态公关 ( #79999 )。 image.png 新材料您的 FAB 尺寸 01.gif 新的 MaterialState.scrolledUnder 状态在起作用 当我们谈论滚动时，另一个改进是添加了滚动指标通知（#85221、#85499），即使用户没有滚动，它也会提供可滚动区域的通知。例如，下面显示了滚动条根据 的基础大小适当地出现或消失 ListView： 02.gif 新的滚动指标通知使滚动条无需滚动即可自动出现和消失 在这种情况下，您不必编写任何代码，但如果您想捕获ScrollMetricNotification更改，则可以。特别感谢社区贡献者xu-baoolin，他为此付出了努力并提出了一个很好的解决方案。 社区的另一个出色贡献是为 ScaffoldMessenger. 你可能还记得 ScaffoldMessenger 从 Flutter 2.0 发布公告作为一个更强大的方式来显示 SnackBars 在屏幕的底部为用户提供通知。在 Flutter 2.5 中，您现在可以在脚手架的顶部添加一个 banner ，该 banner 会一直保持到用户关闭它为止。 03.gif 您的应用程序可以通过调用以下 showMaterialBanner 方法来获得此行为 ScaffoldMessenger： banner 的Material 指南规定您的应用一次只能显示一个，因此如果您的应用调用 showMaterialBanner 多次，ScaffoldMessenger 它将维护一个队列，显示每个新 banner ，因为前一个 banner 已被关闭。感谢Calamity210对 Flutter 中的 Material 支持做出了如此出色的补充！ 在 Flutter 2.0 及其新的文本编辑功能的基础上进一步构建，例如文本选择枢轴点以及能够在处理后停止键盘事件的传播，在此版本中，我们添加了使文本编辑键盘快捷键可覆盖的功能（#85381）。如果您希望Ctrl-A执行一些自定义操作而不是选择所有文本，您可以这样做。本DefaultTextEditingShortcuts类包含每个平台上受支持扑每键盘快捷键列表。如果您想覆盖任何内容，请使用 Flutter 的现有Shortcuts小部件将任何快捷方式重新映射到现有或自定义意图。您可以将该小部件放置在小部件树中要应用覆盖的任何位置。查看API 参考中的一些示例。 插件：相机、图像选择器和插件另一个有很多改进的插件是相机插件： 3795 [相机] android-rework 第 1 部分：支持 Android 相机功能的基类 3796 [相机] android-rework 第 2 部分：Android 自动对焦功能 3797 [camera] android-rework part 3：Android 曝光相关功能 3798 [相机] android-rework 第 4 部分：Android 闪光和变焦功能 3799 [相机] android-rework 第 5 部分：Android FPS 范围、分辨率和传感器方向功能 4039 [相机] android-rework 第 6 部分：Android 曝光和焦点功能 4052 [camera] android-rework part 7：Android 降噪功能 4054 [相机] android-rework 第 8 部分：最终实现的支持模块 4010 [camera] 在 iOS 上不触发平面设备方向 4158 [相机] 修复坐标旋转以在 iOS 上设置焦点和曝光点 4197 [相机] 修复相机预览并不总是在方向改变时重建 3992 [camera] 设置不受支持的 FocusMode 时防止崩溃 4151 [camera] 引入 camera_web 包 image_picker 插件也做了很多工作，专注于端到端的相机体验： 3898 [image_picker] 图像选择器修复相机设备 3956 [image_picker] 将相机捕获的存储位置更改为 Android 上的内部缓存，以符合新的 Google Play 存储要求 4001 [image_picker] 删除了对相机权限的冗余请求 4019 [image_picker] 当相机是源时修复旋转 这项工作改进了适用于 Android 的相机和 image_picker 插件的功能和稳健性。此外，您会注意到摄像头插件的早期版本可用于网络支持 ( #4151 )。此预览为在 Web 上查看相机预览、拍照、使用闪光灯和缩放控件提供基本支持。它目前不是认可的插件，因此您需要明确添加它以在您的网络应用程序中使用。 最初的 Android 相机重写工作由acoutts贡献。相机和 image_picker 工作是由降落基流，一家咨询公司，专门从事 Flutter 和知名的上 pub.dev 自己的包。camera_web 的工作主要由总部位于美国的 Flutter 咨询公司Very Good Ventures完成。非常感谢大家对 Flutter 社区的贡献！ 另一个有价值的社区贡献是 Flutter 社区组织，以“plus”插件而闻名。在此版本的 Flutter 中，Flutter 团队的每个相应插件现在都带有一个类似电池的建议： image.png 此外，由于这些插件不再被积极维护，它们不再被标记为 Flutter 最喜欢的插件。如果您还没有这样做，我们建议您使用以下插件的 plus 版本： image.png Flutter DevTools：性能、小部件检查器和润色此版本的 Flutter 对 Flutter DevTools 进行了许多改进。首先也是最重要的是 DevTools 中增加的支持以利用引擎更新（#26205、#26233、#26237、#26970、#27074、#26617）。其中一组更新使 Flutter 能够更好地将跟踪事件与特定框架相关联，这有助于开发人员确定框架可能超出预算的原因。您可以在 DevTools Frames 图表中看到这一点，该图表已被重建为“实时”；框架在您的应用程序中呈现时填充在此图表中。从此图表中选择一个帧导航到该帧的时间线事件： 04.gif Flutter 引擎现在还可以识别时间线中的着色器编译事件。Flutter DevTools 使用这些事件来帮助您诊断应用程序中的着色器编译卡顿。 05.png DevTools 检测由于着色器编译而丢失的帧 借助这项新功能，DevTools 会检测您何时因着色器编译丢失帧，以便您可以解决问题。要像第一次一样运行您的应用程序（在填充着色器缓存之前，就像为任何用户一样），请 flutter run 与–purge-persistent-cache 标志一起使用。这会清除缓存以确保您重现用户在“首次运行”或“重新打开”(iOS) 体验中看到的环境。此功能仍在开发中，因此请提交您发现的问题的问题，或者我们可以做出的任何改进以帮助调试着色器编译卡顿。 此外，当您跟踪应用程序中的 CPU 性能问题时，您可能会被来自 Dart 和 Flutter 库和/或引擎本机代码的分析数据淹没。如果您想关闭其中任何一个以专注于您自己的代码，您可以使用新的 CPU Profiler 功能 ( #3236 ) 来实现，该功能使您能够从任何这些来源中隐藏分析器信息。 06.png](https://ducafecat.oss-cn-beijing.aliyuncs.com/podcast/18f169bfdc53e483e4979abc3a66fa03e5e4b65f4d7076824ca2db7d99a7d9dc.png) 对于您没有过滤掉的任何类别，它们现在已经进行了颜色编码（[#3310](https://github.com/flutter/devtools/pull/3310 \"https://github.com/flutter/devtools/pull/3310\")、[#3324](https://github.com/flutter/devtools/pull/3324 \"https://github.com/flutter/devtools/pull/3324\")），以便您可以轻松查看 CPU 帧图表的哪些部分来自系统的哪些部分。 ![07.png 彩色框架图，用于识别应用中的应用、原生、Dart 和 Flutter 代码活动 性能并不是您想要调试的唯一因素。此版本的 DevTools 附带了对 Widget Inspector 的更新，允许您将鼠标悬停在小部件上以评估对象、视图属性、小部件状态等。 08.png 而且，当您选择一个小部件时，它会自动填充在新的小部件检查器控制台中，您可以在其中浏览小部件的属性。 09.png 在断点处暂停时，您还可以从控制台计算表达式。 除了新功能外，Widget Inspector 还进行了翻新。为了让 DevTools 成为了解和调试 Flutter 应用程序的更有用的目的地，我们与芬兰的一家创意技术机构Codemate合作进行了一些更新。 10.png Flutter DevTools 优化了 UX 以提高易用性 在此屏幕截图中，您可以看到以下更改： 更好地传达调试切换按钮的作用——这些按钮具有新图标、面向任务的标签，以及描述它们的作用和何时使用它们的丰富工具提示。每个工具提示进一步链接到该功能的详细文档。 更容易扫描和定位感兴趣的小部件——Flutter 框架中常用的小部件现在在检查器左侧的小部件树视图中显示图标。它们根据类别进一步进行颜色编码。例如，布局小部件显示为蓝色，而内容小部件显示为绿色。此外，每个文本小部件现在显示其内容的预览。 对齐布局资源管理器和小部件树的配色方案- 现在可以更轻松地从布局资源管理器和小部件树中识别相同的小部件。例如，下面屏幕截图中的“列”小部件位于布局浏览器中的蓝色背景上，并且在小部件树视图中具有蓝色图标。 我们很想听听您对由这些更新或我们可以做出的任何其他改进引起的任何问题的想法，以确保 DevTools 运行良好。而这些亮点仅仅是个开始。有关此版本 Flutter 的 DevTools 新功能的完整列表，请查看发行说明： Flutter DevTools 2.3.2 发行说明 Flutter DevTools 2.4.0 发行说明 Flutter DevTools 2.6.0 发行说明 IntelliJ/Android Studio：集成测试、测试覆盖率和图标预览Flutter 的 IntelliJ/Android Studio 插件在此版本中也进行了许多改进，首先是运行集成测试的能力 ( #5459 )。集成测试是在设备上运行的整个应用程序测试，位于 integration_test 目录中，并使用与 testWidgets()小部件单元测试相同的功能。 11.png 在 IntelliJ/Android Studio 中集成测试您的 Flutter 应用程序 要将集成测试添加到您的项目，请按照 flutter.dev 上的说明进行操作。要将测试与 IntelliJ 或 Android Studio 连接，请添加启动集成测试的运行配置并连接设备以供测试使用。运行配置可以让你运行测试，包括设置断点、步进等。 此外，Flutter 最新的 IJ/AS 插件允许您查看单元测试和集成测试运行的覆盖率信息。您可以从“调试”按钮旁边的工具栏按钮访问它： 12.png 覆盖信息在编辑器的装订线中使用红色和绿色条显示。在这个例子中，第 9-13 行被测试，但第 3 和 4 行没有被测试。 13.png 最新版本还包括预览来自 pub.dev 包中使用的图标的新功能，这些包是围绕 TrueType 字体文件（#5504、#5595、#5677、#5704）构建的，就像 Material 和 Cupertino 图标支持预览一样。 14.png IntelliJ/Android Studio 中的图标预览 要启用图标预览，您需要告诉插件您正在使用哪些软件包。插件设置/首选项页面中有一个新的文本字段： 15.png 请注意，这适用于在类中定义为静态常量的图标，如屏幕截图中的示例代码所示。它不适用于表达式，例如 LineIcons.addressBook()or LineIcons.values[‘code’]。如果您是不使用此功能的图标包的作者，请创建一个问题。 这是 Flutter 的 IntelliJ/Android Studio 插件的更多更新，您可以在发行说明中阅读： Flutter IntelliJ 插件 M57 发布 Flutter IntelliJ 插件 M58 发布 Flutter IntelliJ 插件 M59 发布 Flutter IntelliJ 插件 M60 发布 Visual Studio Code：依赖项、Fix All 和 Test RunnerFlutter 的 Visual Studio Code 插件也在此版本中得到了改进，从两个新命令“Dart：添加依赖项”和“Dart：添加开发依赖项”（#3306，#3474）开始。 16.gif 在 Visual Studio Code 中添加 Dart 依赖项 这些命令提供的功能类似于Jeroen Meijer 的 Pubspec Assist 插件已经提供了一段时间。这些新命令开箱即用，并提供定期从 pub.dev 获取的包类型过滤列表。 您可能还对适用于 Dart 文件的“全部修复”命令（#3445、#3469）感兴趣，并且可以一步修复所有与dart fix相同的问题。 17.gif 使用 Flutter Fix 规则修复代码中的所有已知问题 这也可以通过添加 source.fixAll 到 editor.codeActionsOnSaveVS Code 设置来设置为在保存时运行。 或者，如果您想尝试预览功能，您可以启用该 dart.previewVsCodeTestRunner 设置并查看通过新的 Visual Studio Code 测试运行程序运行的 Dart 和 Flutter 测试。 18.png 使用新的 Visual Studio Code 测试运行程序测试您的 Dart 和 Flutter 代码 Visual Studio Code 测试运行器看起来与当前的 Dart 和 Flutter 测试运行器略有不同，它将跨会话保留结果。Visual Studio Code 测试运行器还添加了新的装订线图标，显示测试的最后状态，可以单击以运行测试（或右键单击以获取上下文菜单）。 19.png 在即将发布的版本中，现有的 Dart 和 Flutter 测试运行器将被移除，以支持新的 Visual Studio Code 测试运行器。 这只是 Visual Studio Code 新功能和修复的冰山一角。有关所有详细信息，请查看发行说明： v3.26 VS Code Test Runner 集成，Flutter 创建设置，… v3.25额外的依赖管理改进，修复所有文件/保存时，…… v3.24依赖树改进，更容易启动配置，编辑器改进 v3.23 Profile Mode 改进，改进的依赖关系树，LSP 改进 工具：例外、新应用模板和 Pigeon 1.0在之前的 Flutter 版本中，您可能对期望未处理的异常感到沮丧，因此您可以触发调试器并找出它们的来源，结果却发现 Flutter 框架没有让异常通过以触发“未处理的调试器中的 expectation”处理程序。在此版本中，调试器现在可以在未处理的异常上正确中断，而这些异常以前刚刚被框架捕获 ( #17007 )。这改善了调试体验，因为您的调试器现在可以将您直接指向他们代码中的抛出行，而不是指向框架深处的随机行。一个相关的新功能使您能够决定 FutureBuilder 是否应该重新抛出或吞下错误 (# 84308）。这应该会为您提供大量额外的例外情况，以帮助您追踪 Flutter 应用程序中的问题。 自 Flutter 诞生以来，就出现了 Counter 应用模板，它具有许多优点：它展示了 Dart 语言的许多特性，展示了几个关键的 Flutter 概念，并且它足够小，可以放入单个文件中，即使有很多的解释性评论。然而，它没有为现实世界的 Flutter 应用程序提供一个特别好的起点。在此版本中，通过以下命令提供了一个新模板 ( #83530 )： $ flutter create -t skeleton myapp 20.gif 新的 Flutter 骨架模板在起作用_ 骨架模板生成一个遵循社区最佳实践的两页列表视图 Flutter 应用程序（带有详细信息视图）。它的开发经过大量内部和外部审查，为构建生产质量应用程序提供了更好的基础，并支持以下功能： 用于 ChangeNotifier 协调多个小部件 默认情况下使用 arb 文件生成本地化 包括示例图像并为图像资产建立 1x、2x 和 3x 文件夹 使用“功能优先”的文件夹组织 支持共享首选项 支持明暗主题 支持多页面间导航 随着时间的推移，随着 Flutter 最佳实践的发展，预计这个新模板也会随之发展。 另一方面，如果您正在开发插件而不是应用程序，那么您可能会对 Pigeon 的 1.0 版本感兴趣。Pigeon 是一个代码生成工具，用于在 Flutter 及其主机平台之间生成类型安全的互操作代码。它允许您定义插件 API 的描述，并为 Dart、Java 和 Objective-C（分别可用于 Kotlin 和 Swift）生成框架代码。 21.png 示例生成的 Pigeon 代码 Flutter 团队的一些插件中已经使用了 Pigeon。在此版本中，它提供了更多有用的错误消息，增加了对泛型、原始数据类型作为参数和返回类型以及多个参数的支持，预计将来会更频繁地使用它。如果您想在自己的插件或添加到应用程序项目中利用 Pigeon，可以在Pigeon 插件页面找到更多信息。 重大更改和弃用以下是 Flutter 2.5 版本中的重大变化： 默认拖动滚动设备 在 v2.2 之后删除了弃用的 API 引入包：flutter_lints ThemeData 的重音属性已被弃用 手势识别器清理 用 collate 替换 AnimationSheetBuilder.display 使用 HTML 插槽在 Web 中呈现平台视图 将 LogicalKeySet 迁移到 SingleActivator 有关自 1.17 版本以来重大更改的完整列表，请参阅 flutter.dev。 随着我们继续更新 Flutter Fix（在您的 IDE 中和通过 dart fix 命令可用），我们总共有 157 条规则来自动迁移受这些或过去的重大更改以及任何弃用影响的代码。一如既往，非常感谢社区贡献测试，他们帮助我们识别这些重大变化。要了解更多信息，请查看我们的重大变更政策。 此外，随着 Flutter 2.5 的发布，我们将弃用2020 年 9 月宣布的对 iOS 8 的支持。放弃对市场份额不到 1% 的 iOS 8 的支持，使 Flutter 团队能够专注于更广泛使用的新平台。弃用意味着这些平台可以工作，但我们不会在这些平台上测试 Flutter 的新版本或插件。您可以在 flutter.dev 上查看当前支持的 Flutter 平台列表。 概括最后，一如既往地感谢世界各地的 Flutter 社区让这一切成为可能。对于在此更新中贡献和审查了 1000 个 PR 的数百名开发人员，这里是您每项努力的成果。我们正在共同努力为世界各地的开发人员转变应用程序开发流程，以便您可以从单个代码库中交付更多、更快、部署到您关心的平台。 请继续关注 Google Flutter 团队的更多更新。今年还没有结束！ 原文链接： What’s new in Flutter 2.5 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter HeroMode Widget 动画转场组件","date":"2021-09-08T16:00:00.000Z","path":"2021/09/09/translation/heromode-widget-in-flutter/","text":"原文 https://medium.com/flutterdevs/heromode-widget-in-flutter-9fac046fbf86 代码https://github.com/flutter-devs/flutter_heromode_demo 参考 https://flutter.dev 正文 在 Flutter 中，Flutter 应用程序屏幕上的每个组件都是一个小工具。屏幕的透视图完全依赖于用于构建应用程序的小部件的选择和分组。此外，应用程序代码的结构是一个小部件树。 在本博客中，我们将了解 HeroMode 小部件及其在 flutter 中的功能。我们将在这个 HeroMode 小部件的演示程序的实现中看到。 “ Flutter 是谷歌的 UI 工具包，它可以帮助你在创纪录的时间内用一个代码库为移动设备、网络和桌面构建漂亮的本地组合应用程序。” 它是免费和开源的。它最初是由谷歌发展而来，目前由 ECMA 标准监管。 Flutter 应用程序利用达特编程语言来制作应用程序。这个 dart 编程和其他编程语言有一些相同的亮点，比如 Kotlin 和 Swift，并且可以被转换成 JavaScript 代码。 如果你想探索更多关于 Flutter ，请访问 Flutter 的官方网站，以获得更多的信息。 Flutter’s official website 以下这些公司和产品正在使用 Flutter —— Flutter 展示 HeroMode 小部件Hero 小部件是一个伟大的开箱即用的动画，用于通信小部件从一个页面飞到另一个页面的导航动作。英雄动画是两个不同页面之间共享的元素过渡(动画)。现在来看看这个，想象一个超级英雄在行动中飞行。例如，您必须有一个图像列表。当我们用英雄标签包装它的时候。现在我们点击一个项目清单。而且当被敲击时。然后图像列表项目的土地其位置在详细页面。当我们取消它并返回到列表页面，然后 hero 小部件返回到它的页面。 HeroMode 小部件具有动画功能，可以在两个屏幕之间启用或禁用元素。基本上，当你想禁用 Hero 小部件的动画功能时，这个小部件是必需的。如果您想了解 Hero 模式小部件，那么首先您需要了解 Hero 小部件。 是 Hero 小部件的一部分，引入这个小部件的目的是启用和禁用 Hero 小部件的动画—- 如果你不想在两个屏幕之间动画元素，然后用 HeroMode 小部件包装 Hero 小部件，我们可以通过使用它们的静态属性或动态地启用和禁用它们，然后通过包装这个小部件，当你仔细看下面的例子视频时发生了什么，那么你就可以看到这个动画中的可衡量的区别。 演示模块: 如何实现 dart 文件中的代码: 你需要分别在你的代码中实现它: 首先，我为集合创建了一个 ViewModel 类，并在开关按钮上获得一个布尔值。这是我在 HeroMode Widget 中通过的。 1234bool _isHeroModeEnable= true;bool get isHeroModeEnable =&gt; _isHeroModeEnable;set isHeroModeEnable(bool value) &#123; _isHeroModeEnable = value;&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 然后，我必须添加一个文本和开关按钮来显示 HeroMode 小部件的启用和禁用功能。 123456789101112131415161718192021222324Widget buildCategoriesSection() &#123; return Container( padding: EdgeInsets.only(left: 20), child: Row( _//mainAxisAlignment: MainAxisAlignment.center,_ children: [ Container( child: Text(\"Hero Mode\", style: TextStyle( color: Colors._white_, fontSize: 18, fontWeight: FontWeight._bold_ ),), ), Switch( value: model!=null &amp;&amp; model!.isHeroModeEnable, onChanged:(value)&#123; print(\"value:$value\"); model!.isHeroModeEnable=value; &#125;, activeTrackColor: Color(ColorConstants._light_blue_), activeColor: Color(ColorConstants._pure_white_), ), ], ), );&#125; 然后，我用电影标题 API 创建了一个列表视图，但是您可以根据需要为测试目的使用一个虚拟图像列表。在此之后，我用 Hero 小部件包装图像，用 HeroMode 小部件包装 Hero 小部件。禁用 Hero 小部件的动画。基本上，这是一个媒介，以启用和禁用动画的英雄小部件。您不能直接从 Hero Widget 禁用动画。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Widget _buildPopularSection() &#123; return Container( height: 300, padding: EdgeInsets.only(left: 20, top: 5), width: MediaQuery._of_(context).size.width, child: model != null &amp;&amp; model!.isPopularLoading ? Center(child: CircularProgressIndicator()) : Provider.value( value: Provider._of_&lt;HomeViewModel&gt;(context), child: Consumer( builder: (context, value, child) =&gt; Container( child: ListView.builder( shrinkWrap: true, itemCount: model != null &amp;&amp; model!.popularMovies != null ? model!.popularMovies!.results!.length : 0, scrollDirection: Axis.horizontal, itemBuilder: (context, index) &#123; return _buildPopularItem( index, model!.popularMovies!.results![index]); &#125;, ), ), ), ), );&#125;Widget _buildPopularItem(int index, Results result) &#123; return GestureDetector( onTap: () &#123; Navigator._push_( context, MaterialPageRoute( builder: (context) =&gt; MovieDetailView(movieDataModel: result)), ); &#125;, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( height: 200, width: 150, margin: EdgeInsets.only(right: 16), child: HeroMode( child: Hero( tag: '$&#123;result.id&#125;', child: ClipRRect( borderRadius: BorderRadius.circular(25.0), child: Image.network( Constants._IMAGE_BASE_URL_ + Constants._IMAGE_SIZE_1_ + '$&#123;result.posterPath&#125;', fit: BoxFit.cover, ), ), ), enabled: true, _//enabled:model.isHeroModeEnabled,_ ), ), SizedBox( height: 18, ), Container( child: Text( result.title!, style: TextStyle(color: Colors._white_, fontSize: 15), ), ), SizedBox( height: 5, ), Container( child: GFRating( value: _rating, color: Color(ColorConstants._orange_), size: 16, onChanged: (value) &#123; setState(() &#123; _rating = value; &#125;); &#125;, ), ) ], ), );&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 最后，我创建了第二个省道文件，在这个文件中，我制作了一个方法来显示图像动画。然后使用相同标记的 Hero 小部件包装图像。当您有多个图像时，然后传递图像列表 id。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Widget _buildMovieBanner(Results movieItems) &#123; return Container( height: 380, child: Stack( children: [ Positioned( top: 20, child: Container( height: 350, width: 240, margin: EdgeInsets.only(left: 28, right: 30), decoration: BoxDecoration( borderRadius: BorderRadius.circular(22), color: Color(ColorConstants._saphire_blue2_), ), ), ), Positioned( top: 10, child: Container( height: 350, width: 250, margin: EdgeInsets.only(left: 22, right: 25), decoration: BoxDecoration( borderRadius: BorderRadius.circular(22), color: Color(ColorConstants._cobaltBlue_), ), ), ), Container( height: 350, width: 260, margin: EdgeInsets.only(left: 16, right: 16), decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), ), child: ClipRRect( borderRadius: BorderRadius.circular(24), child: Hero( tag: '$&#123;widget.movieDataModel.id&#125;', child: Image.network( Constants._IMAGE_BASE_URL_ + Constants._IMAGE_SIZE_1_ + widget.movieDataModel.posterPath!, fit: BoxFit.cover, ), ), ), ), ], ), );&#125; 结语:In this article, I have explained the basic overview of the HeroMode Widget in a flutter, you can modify this code according to your choice. This was a small introduction to HeroMode Widget On User Interaction from my side, and it’s working using Flutter. 在本文中，我已经简单介绍了 HeroMode 小部件的基本概况，您可以根据自己的选择修改这段代码。这是一个小的介绍 HeroMode 小部件用户交互从我这边，它的工作使用 Flutter。 I hope this blog will provide you with sufficient information on Trying up the Explore, HeroMode Widget in your flutter projects. 我希望这个博客将提供您尝试在您的 Flutter 项目的探索，HeroMode 小部件充足的信息。 ❤ ❤ Thanks for reading this article ❤❤ ❤ Thanks for reading this article ❤❤ If I got something wrong\\? Let me know in the comments. I would love to improve. 如果我做错了什么，请在评论中告诉我，我很乐意改进。 Clap 👏 If this article helps you. 鼓掌如果这篇文章对你有帮助的话。 GitHub 链接https://github.com/flutter-devs/flutter_heromode_demo © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Windows Flutter 开发环境的建立","date":"2021-09-07T16:00:00.000Z","path":"2021/09/08/translation/setting-up-flutter-development-environment-for-windows-vs-code/","text":"原文 https://srihari-sundaramurugan.medium.com/setting-up-flutter-development-environment-for-windows-vs-code-93820f4caa57 正文 作为一个开发人员，我一直想尝试 flutter 已经很久了。当我开始使用 Flutter 时，设置它花费了我大量的时间，我不得不通过各种教程和文章来设置开发环境。我写这篇博客是因为我不想让我的开发同事们在这个过程中面对我不得不面对的错误。 系统要求:要安装和运行 Flutter，您的开发环境必须满足以下最低要求: Operating Systems 操作系统: Windows 7 SP1 或更高版本(64 位) ，基于 x86-64 Disk Space 磁盘空间: 1.64 GB (不包括 IDE/工具的磁盘空间) Tools 工具 : Flutter 取决于这些工具在您的环境中是否可用 Windows PowerShell 5.0 or newer (this is pre-installed with Windows 10) 或更新(这是预装 Windows 10) Git for Windows 适用于 Windows 的 Git 2. x, with the 2. x，加上Use Git from the Windows Command Prompt 使用命令提示符的 Git option. 选择 如果已经安装了 Git for Windows，请确保您可以运行git 命令来自命令提示符或 PowerShell 需要下载/安装的东西:以下是您在此过程中将要下载/安装的内容: Flutter Flutter SDK 软件开发软件开发工具包 Andriod Studio Java SE Development Kit 开发工具包 Git 饭桶for windows 为了窗户 VS Code VS 代码 (Visual Studio Code) 我们开始吧？ Flutter SDK (软件开发工具包) : A clip from 一个剪辑自https://flutter.dev/docs/get-started/install/windows 您可以从正式的 Flutter 安装文档中下载 Flutter SDK 的最新稳定版本。目前 windows 的稳定版本是 2.2.3-stable，当你阅读这篇博客时可能会有所不同。下载当时可用的最新版本。 . zip 中提取 Flutter SDK 在你的 c 盘中创建一个文件夹C:\\src 并粘贴提取的 Flutter SDK C 驱动下的 Flutter SDK 现在进入 Flutter 文件夹，然后进入垃圾箱 复制垃圾桶的路径 打开窗口搜索并键入env. 现在打开“编辑环境变量为您的帐户” 双击path Click 点击New 并粘贴的路径flutter\\bin 然后按「确定」 现在，打开 cmd (或任何终端窗口)并输入以下命令 dart where flutter dart 如果您得到了 Flutter 和省道文件的位置，您已经成功地安装了 Flutter SDK 并设置了它的路径。 Java SE 开发工具包: 如果您的 pc 上已经安装了 JDK，请确保将其设置为“ JAVA.home”路径。 现在，让我们设置 java se: Download “Java SE 8” from 从网站下载「 javase8」JDK SE 8 DOWNLOAD 8 DOWNLOAD. Under “Java SE Development Kit 8u301”, you’ll see this 在“ javase 开发工具包 8u301”下，您将看到这个 https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 下载并安装 x64/x86 w.r.t. 您的 PC 的规范 安装后，导航到 \\bin : 在我的案例中: dart C:Program FilesJavajdk1.8.0_301bin 复制路径，打开“编辑环境变量为您的帐户” 创建一个新变量JAVA_HOME . JAVA_HOME Environment Variable 环境变量 您已经完成了 JDK 的设置 Andriod Studio: 我们正在下载 andriod studio 来建立 andriod 模拟器。 下载 Andriod StudioANDRIOD STUDIO. Install it. 安装它 现在，打开 CMD/Terminal，运行以下命令: dart flutter doctor 你可能不会得到绿蜱的一切，检查只有 andriod 工作室，因为现在。 如果 Flutter 找不到它，就跑 flutter config --android-studio-dir &lt;directory&gt; 设置 Android Studio 安装的目录 打开 Andriod Studio 如果你想在 Andriod Studio 开发应用程序, - Go to plugins, search for “Dart” and “Flutter”. - 下载它们，并重新启动 andriod studio。现在你可以在仪表板上看到一个“创建新的 Flutter 项目”。 Select 选择 More Actions. Andriod Studio Choose 选择AVD Manager . AVD Manager — Andriod Studio Click 点击+ Create Virtual Device… . Create Virtual Device — AVD Manager — Andriod Studio 选择一个你喜欢的 Andriod 设备，然后点击下一步 Create Virtual Device — AVD Manager — Andriod Studio 点击下载你想要的 Andriod 版本Download (blue), under (蓝色) ，在下面Release Name . 一旦下载完毕，点击下一步 Create Virtual Device — AVD Manager — Andriod Studio Now, Finish. 现在，完成 🍻Cheers to you, you’re almost done!. 🥳 为你干杯，你就快完成了 Visual Studio 代码: 向我最喜欢的 IDE 问好！ Download VS Code from 下载 VS 代码VS CODE DOWNLOAD VS 代码下载. 安装并打开 VS 代码 开放式扩展 Extensions — VS Code Search for 搜寻Flutter in the extensions, and install this: 然后安装这个: VS Code Flutter 扩展 好了，一切都结束了。现在，是时候给心房 Flutter 医生做检查了。 打开 CMD/终端，然后运行 dart flutter doctor 您可能仍然有一个未检查的框 Flutter Doctor Flutter 在你的终端上运行这个命令, dart flutter doctor \\--andriod-licenses Now, run 现在，跑吧flutter doctor again. 再一次 Flutter Doctor Flutter Yipieee，现在你已经准备好开发 Flutter 应用程序了。 写博客会让我感到快乐，并鼓励我写更多这样的博客。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 的 keyboard_actions 插件","date":"2021-09-05T16:00:00.000Z","path":"2021/09/06/translation/keyboard-actions-in-flutter/","text":"原文 https://medium.com/flutterdevs/keyboard-actions-in-flutter-ae4781286806 代码https://github.com/flutter-devs/KeyboardAction 参考 https://pub.dev/packages/keyboard_actions 正文了解如何在您的 Flutter 应用程序自定义默认键盘 Flutter 中的键盘动作 安卓/IoS 提供的键盘没有隐藏键盘的按钮，这给用户带来了很多不便。当我们的应用程序有许多需要在工具栏上显示操作键和处理定义为字段的函数的 textfield 时。键盘操作是当用户点击当前字段时指示该字段操作的键。 在这篇文章中，我将演示如何使用包含字段的表单输入在应用程序中显示键盘操作。我们还将实现一个演示程序，并使用包 keyboard action 来演示这些特性。我试图用一种简单的方式来解释我的项目 简介:KEYBOARD_ACTION 提供了几个软件包，使您的设备键盘可定制。今天，我们讨论 KEYBOARD action。在 iOS 中有一个众所周知的问题，当我们使用数字输入字段时，它不会显示键盘内部/上方的完成按钮。因此，键盘操作提供了各种功能，有助于克服用户和开发人员目前面临的问题。 https://pub.dev/packages/keyboard_actions 特点: 完成键盘按钮(您可以自定义按钮) 在文本字段之间上下移动(可以隐藏设置)nextFocus: false). 键盘栏定制 键盘栏下方的自定义页脚小部件 用简单的方法创建你自己的键盘 你可以在安卓、 iOS 或者两个平台上使用它 与对话框兼容 设立项目:第一步: 使用包装 keyboard_actions | Flutter Package键盘操作 | Flutter Package以一种简单的方式为 Android/iOS 键盘添加特性。因为安卓/iOS 提供的键盘..pub.dev https://pub.dev/packages/keyboard_actions 在 pubspec.yaml 文件的依赖关系中添加 youtube player_iframe 插件，然后运行 \\$flutter pub get 命令。 12dependencies: keyboard_actions: ^3.4.4 步骤 2: 将包导入为 1import 'package:keyboard_actions/keyboard_actions.dart'; Code Implementation:代码实施:1. 创建一个新的 dart 文件，名为home_screen.dart . 文件夹来设计用户界面，并编写您希望在项目中实现的逻辑 2. 我在 flutter demo 项目中构建了长长的 Forms，并在 Android 上运行了这个应用程序。如果我们使用的是 IOS 设备，那么它不会显示done 完成 在 iOS 系统中，当我们使用数字输入字段时，在 Android 系统中，键盘内/上方的按钮不会显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Card( shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(10.0), ), elevation: 8.0, child: Container( padding: EdgeInsets.only(left: 12), child: Form( key: _formKey, child: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ TextFormField( decoration: InputDecoration( labelText: 'Input Number with Custom Footer'), controller: _customController, focusNode: _nodeText6, keyboardType: TextInputType._number_, ), TextFormField( decoration: InputDecoration(labelText: 'Input Number'), focusNode: _nodeText1, keyboardType: TextInputType._number_, textInputAction: TextInputAction.next ), TextFormField( decoration: InputDecoration( labelText: 'Custom cross Button'), focusNode: _nodeText2, keyboardType: TextInputType._text_, ), TextFormField( decoration: InputDecoration( labelText: 'Input Number with Custom Action'), focusNode: _nodeText3, keyboardType: TextInputType._number_, ), TextFormField( decoration: InputDecoration( labelText: 'Input Text without Done button'), focusNode: _nodeText4, keyboardType: TextInputType._text_, ), TextFormField( decoration: InputDecoration( labelText: 'Input Number with Toolbar Buttons'), focusNode: _nodeText5, keyboardType: TextInputType._number_, ), ], ), ), ), ),); 3. 现在，要在项目中添加键盘操作，您需要将所有 TextFormField 包装在 Widget KeyboardAction 下，这个 Widget KeyboardAction 需要 keyboardactivesconfig 配置才能在键盘上添加配置。 12345678910111213141516171819202122return KeyboardActions( tapOutsideBehavior: TapOutsideBehavior.translucentDismiss, _//autoScroll: true,_ config: _buildConfig(context), child: Card( shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(10.0), ), elevation: 8.0, child: Container( padding: EdgeInsets.only(left: 12), child: Form( key: _formKey, child: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ TextFormField( decoration: InputDecoration( labelText: 'Input Number with Custom Footer'), controller: _customController, focusNode: _nodeText6, keyboardType: TextInputType._number_, ), 4. 提供了一个功能，当我们按下设备屏幕上键盘以外的任何地方时，可以关闭键盘。所以，我们需要加上这一行 1tapOutsideBehavior: TapOutsideBehavior.translucentDismiss, 5. 我们应该初始化分配给不同文本字段的 FocusNode 对象。因此，开发人员进行定制，因为它允许键盘将焦点集中在这个小部件上。 123456final FocusNode _nodeText1 = FocusNode();//Add In TextFormField TextFormField( decoration: InputDecoration( labelText: 'Input Number with Toolbar Buttons'), focusNode: _nodeText1, keyboardType: TextInputType._number_, ) 6. 我们将定义 keyboardansconfig。包装器为单个配置键盘的动作栏。在 keyboardansconfig 中，我们根据您的需求为每个 TextFormField 单独定义由键盘执行的操作。我们可以自定义键盘颜色，键盘和内容之间的分隔线颜色，显示箭头前/后移动输入之间的焦点。 1234567KeyboardActionsConfig _buildConfig(BuildContext context) &#123; return KeyboardActionsConfig( keyboardActionsPlatform: KeyboardActionsPlatform.ALL, keyboardBarColor: Colors._grey_[200], keyboardSeparatorColor: Colors._redAccent_, nextFocus: true, actions: [ 7. 现在，我们将根据不同的 TextFormField 中的需求定义动作。 1234actions: [ KeyboardActionsItem( focusNode: _nodeText1, ), 8. 要在应用程序中显示带有自定义页脚的输入，您需要在您的 KeyboardActionsItem 中实现下面的代码，在这里我们必须在 Text 小部件中传递 TextController。 12345678910KeyboardActionsItem( focusNode: _nodeText6, footerBuilder: (_) =&gt; PreferredSize( child: SizedBox( height: 40, child: Center( child: Text(_customController.text), )), preferredSize: Size.fromHeight(40)),), 9. 为了在你的应用程序中显示自定义对话框，将这个逻辑添加到 KeyboardActionsItem 中指定的焦点节点。 123456789101112131415161718KeyboardActionsItem( focusNode: _nodeText3, onTapAction: () &#123; showDialog( context: context, builder: (context) &#123; return AlertDialog( content: Text(\"Show Custom Action\"), actions: &lt;Widget&gt;[ FlatButton( child: Text(\"OK\"), onPressed: () =&gt; Navigator._of_(context).pop(), ) ], ); &#125;); &#125;,), 当我们运行应用程序时，我们得到屏幕的输出视频，如下所示，用户可以观察输出。 结语:在本文中，我已经简单地介绍了 KeyboardAction 包的基本结构; 您可以根据自己的选择修改这段代码，也可以根据自己的需求使用这个包。这是一个小的介绍键盘定制用户交互从我这边，它的工作使用 Flutter 。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 Flutter 中探索 GetIt","date":"2021-09-01T16:00:00.000Z","path":"2021/09/02/translation/explore-getit-in-flutter/","text":"原文 https://medium.com/flutterdevs/explore-getit-in-flutter-8db723e9d7cf 参考 https://pub.dev/packages/get_it 正文它的 Flutter 小部件是建立使用一个现代框架。这就像是一种反应。在这里，我们从小部件开始创建任何应用程序。屏幕中的每个组件都是一个小部件。这个小部件描述了根据他目前的配置和状态，他的前景应该是什么样的。使您的小部件不具有直接依赖关系，可以使您的代码更好地组织，更容易测试和维护。但是现在您需要一种从 UI 代码访问这些对象的方法。当我来到 Flutter 从。小部件展示类似于它的想法和当前的设置和状态。Flutter 是一个免费的开源工具，用于开发移动、桌面、 web 应用程序，只需要一个代码库。 在本文中，我们将用 Flutter 获得它的包装来说明什么是 Flutter 获得它。在包的帮助下，以及如何使用他们在您的 Flutter 应用程序。那么让我们开始吧。 Flutter :Flutter 是谷歌的用户界面工具包，它可以帮助你在创纪录的时间内为移动设备、网络和桌面构建漂亮的、本地组合的应用程序。 Flutter 提供了很棒的开发工具，具有惊人的 hot reload 性能 返回文章页面搞定它:软件包就是这样一种简单的服务定位器，在这个服务定位器中，你有一个中央注册中心，通过注册类，我们可以得到一个类的实例，我们使用它来代替继承的小部件或提供者来访问对象 Is。从你的用户界面。 服务定位器和依赖注入都是控制反转的一种形式。IOC 允许来自任何地方的请求，从注册其类类型到访问容器。 实施方案:第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 依赖性: 12dependencies: get_it: ^7.2.0 第二步: 进口 1import 'package:get_it/get_it.dart'; 第三步: 启用 AndriodX 1234org.gradle.jvmargs=-Xmx1536Mandroid.enableR8=trueandroid.useAndroidX=trueandroid.enableJetifier=true 代码实施:在解释 GetIt 之前，我们将在下面的参考文献中给出一个在我们的代码中使用的 GitIt 方法。 这是我们的服务定位器。 1GetIt getIt = GetIt._instance_; 接下来，我们创建了一个名为 getappmodel 的抽象类，它扩展了 ChangeNotifier。 1234abstract class GetItAppModel extends ChangeNotifier &#123; void incrementCounter(); int get counter;&#125; 现在我们已经创建了一个名为 getappmodelimplementation 的类，它从 getappmodel 类中扩展，我们已经创建了 incrementCounter ()方法，该方法增加计数器值。 1234567891011121314151617class GetItAppModelImplementation extends GetItAppModel &#123; int _counter = 0; GetItAppModelImplementation() &#123; Future.delayed(Duration(seconds: 3)).then((_) =&gt; getIt.signalReady(this)); &#125; @override int get counter =&gt; _counter; @override void incrementCounter() &#123; _counter++; notifyListeners(); &#125;&#125; 在这之后，我们将创建一个计数器应用程序，在这个程序中，我们已经在内部获取了两个文本部件，外部是 floatingActionButton，点击它将调用 getappmodel ()类，在计数器应用程序中，该值将在上面的列部件中增加，该列部件由 FutureBuilder 和 getIt.allReady ()包装，在未来的属性中定义。 12345678910111213141516171819202122232425262728293031323334353637383940FutureBuilder( future: getIt.allReady(), builder: (context, snapshot) &#123; if (snapshot.hasData) &#123; return Scaffold( body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( getIt&lt;GetItAppModel&gt;().counter.toString(), style: Theme._of_(context).textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: getIt&lt;GetItAppModel&gt;().incrementCounter, tooltip: 'Increment', child: Icon(Icons._add_), ), ); &#125; else &#123; return Column( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize: MainAxisSize.min, children: [ Text('Initialisation'), SizedBox( height: 16, ), CircularProgressIndicator(), ], ); &#125; &#125;) 全部代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import 'package:flutter/material.dart';import 'package:flutter_getit_exm/app_model.dart';import 'package:flutter_getit_exm/main.dart';class GetItExm extends StatefulWidget &#123; GetItExm(&#123;Key? key, required this.title&#125;) : super(key: key); final String title; @override _GetItExmState createState() =&gt; _GetItExmState();&#125;class _GetItExmState extends State&lt;GetItExm&gt; &#123; @override void initState() &#123; getIt .isReady&lt;GetItAppModel&gt;() .then((_) =&gt; getIt&lt;GetItAppModel&gt;().addListener(update)); super.initState(); &#125; @override void dispose() &#123; getIt&lt;GetItAppModel&gt;().removeListener(update); super.dispose(); &#125; void update() =&gt; setState(() =&gt; &#123;&#125;); @override Widget build(BuildContext context) &#123; return Material( child: FutureBuilder( future: getIt.allReady(), builder: (context, snapshot) &#123; if (snapshot.hasData) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( getIt&lt;GetItAppModel&gt;().counter.toString(), style: Theme._of_(context).textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: getIt&lt;GetItAppModel&gt;().incrementCounter, tooltip: 'Increment', child: Icon(Icons._add_), ), ); &#125; else &#123; return Column( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize: MainAxisSize.min, children: [ Text('Waiting for initialisation'), SizedBox( height: 16, ), CircularProgressIndicator(), ], ); &#125; &#125;), ); &#125;&#125; 结语:在本文中，我解释了 Explore GetIt In Flutter，你可以根据自己的修改和实验，这个小介绍来自 Explore GetIt In Flutter 从我们这边的演示。 我希望这个博客将为您提供充分的信息，在尝试在您的 Flutter 项目探索 GetIt 在 Flutter 。我们向你展示了什么是探索和 Flutter 是在您的 Flutter 应用的工作，所以请尝试它。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 Flutter 中探索 StreamBuilder","date":"2021-08-31T16:00:00.000Z","path":"2021/09/01/translation/exploring-streambuilder-in-flutter/","text":"原文 https://medium.com/flutterdevs/exploring-streambuilder-in-flutter-5958381bca67 正文异步交互可能需要一个理想的机会来进行总结。偶尔，在周期结束之前可能会发出一些值。在 Dart 中，您可以创建一个返回 Stream 的容量，该容量可以在异步进程处于活动状态时发射一些值。假设您需要根据一个 Stream 的快照在 Flutter 中构造一个小部件，那么有一个名为 StreamBuilder 的小部件。 在这个博客中，我们将探索 Flutter 中的 StreamBuilder。我们还将实现一个演示程序，并向您展示如何在您的 Flutter 应用程序中使用 StreamBuilder。 介绍:StreamBuilder 可以监听公开的流，并返回小部件和捕获获得的流信息的快照。造溪者提出了两个论点。 A stream 构建器，它可以将流中的多个组件更改为小部件 Stream 像一条线。当您从一端输入值而从另一端输入侦听器时，侦听器将获得该值。一个流可以有多个侦听器，这些侦听器的负载可以获得流水线，流水线将获得等价值。如何在流上放置值是通过使用流控制器实现的。流构建器是一个小部件，它可以将用户定义的对象更改为流。 建造者: 要使用 StreamBuilder，需要调用下面的构造函数: 123456const StreamBuilder(&#123;Key? key,Stream&lt;T&gt;? stream,T? initialData,required AsyncWidgetBuilder&lt;T&gt; builder,&#125;) 实际上，您需要创建一个 Stream 并将其作为流争用传递。然后，在这一点上，您需要传递一个 AsyncWidgetBuilder，该 AsyncWidgetBuilder 可用于构造依赖于 Stream 快照的小部件。 参数: 下面是 StreamBuilderare 的一些参数: Key? key: 小部件的键，用于控制小部件如何被另一个小部件取代 Stream&lt;T&gt;? stream: 一个流，其快照可以通过生成器函数获得 T? initialData: 将利用这些数据制作初始快照 required AsyncWidgetBuilder&lt;T&gt; builder: 生成过程由此生成器使用 如何实现 dart 文件中的代码:你需要分别在你的代码中实现它: 让我们创建一个流: 下面的函数返回一个每秒生成一个数字的 Stream。你需要使用 async * 关键字来创建一个流。若要发出值，可以使用 yield 关键字后跟要发出的值。 12345678Stream&lt;int&gt; generateNumbers = (() async* &#123; await Future&lt;void&gt;.delayed(Duration(seconds: 2)); for (int i = 1; i &lt;= 10; i++) &#123; await Future&lt;void&gt;.delayed(Duration(seconds: 1)); yield i; &#125;&#125;)(); From that point onward, pass it as the stream argument 从那一点开始，把它作为流参数传递下去 1234StreamBuilder&lt;int&gt;(stream: generateNumbers,// other arguments) 让我们创建一个 AsyncWidgetBuilder 构造函数期望您传递一个类型为 AsyncWidgetBuilder 的命名争用构建器。这是一个有两个参数的函数，它们的类型都是 BuildContext 和 AsyncSnapshot \\&lt; t &gt; 。后续的边界(包含当前快照)可以用来确定应该呈现的内容。 要创建这个函数，首先需要了解 AsyncSnapshot。AsyncSnapshot 是使用异步计算的最新通信的不变描述。在这种独特的情况下，它解决了与 Stream 的最新通信。可以通过 AsyncSnapshot 属性获取流的最新快照。您可能需要使用的属性之一是 connectionState，这个枚举将当前关联状态转换为异步计算，在这种特殊情况下，这种异步计算就是 Steam。 12345678910111213141516171819202122232425StreamBuilder&lt;int&gt;( stream: generateNumbers, builder: ( BuildContext context, AsyncSnapshot&lt;int&gt; snapshot, ) &#123; if (snapshot.connectionState == ConnectionState.waiting) &#123; return CircularProgressIndicator(); &#125; else if (snapshot.connectionState == ConnectionState.active || snapshot.connectionState == ConnectionState.done) &#123; if (snapshot.hasError) &#123; return const Text('Error'); &#125; else if (snapshot.hasData) &#123; return Text( snapshot.data.toString(), style: const TextStyle(color: Colors._red_, fontSize: 40) ); &#125; else &#123; return const Text('Empty data'); &#125; &#125; else &#123; return Text('State: $&#123;snapshot.connectionState&#125;'); &#125; &#125;,), AsyncSnapshot 还有一个名为 hasError 的属性，可用于检查快照是否包含非空错误值。如果异步活动的最新结果失败，hasError 值将有效。为了获取信息，首先，您可以通过获取其 hasData 属性来检查快照是否包含信息，如果 Stream 有效地释放了任何非空值，那么 hasData 属性将是有效的。然后，在这一点上，您可以从 AsyncSnapshot 的数据属性获取信息。 由于上面属性的值，您可以计算出应该在屏幕上呈现什么。在下面的代码中，当 connectionState 值正在等待时，将显示一个 CircularProgressIndicator。当 connectionState 更改为 active 或 done 时，可以检查快照是否有错误或信息。建造函数称为 Flutter 管道的检测。因此，它将获得一个与时间相关的快照子组。这意味着，如果在实际上相似的时间里，Stream 发出了一些值，那么一部分值可能没有传递给构建器。 枚举有一些可能的值: > none: 无: 不与任何异步计算关联。如果流为空，则可能发生 > waiting: 等待: 与异步计算关联并等待协作。在这个上下文中，它暗示流还没有完成 > active: 活跃的: 与活动的异步计算相关联。例如，如果一个 Stream 已经返回了任何值，但此时还没有结束 > done: &gt; 完成: 与结束的异步计算相关联。在这个上下文中，它暗示流已经完成 设置初始数据: 您可以选择传递一个 worth 作为 initialData 参数，这个参数将被利用，直到 Stream 发出 a。如果传递的值不为空，那么当 connectionState 在等待时，hasData 属性在任何事件中首先都将为 true 1234StreamBuilder&lt;int&gt;(initialData: 0,// other arguments) 要在 connectionState 等待时显示初始数据，应该调整 if snapshot.connectionState = = connectionState.waiting，然后调整上面代码中的块。 12345678910111213141516if (snapshot.connectionState == ConnectionState.waiting) &#123; return Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: [ CircularProgressIndicator(), Visibility( visible: snapshot.hasData, child: Text( snapshot.data.toString(), style: const TextStyle(color: Colors._black_, fontSize: 24), ), ), ], );&#125; 当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 Code File:密码档案:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import 'package:flutter/material.dart';import 'package:flutter_steambuilder_demo/splash_screen.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Splash(), debugShowCheckedModeBanner: false, ); &#125;&#125;Stream&lt;int&gt; generateNumbers = (() async* &#123; await Future&lt;void&gt;.delayed(Duration(seconds: 2)); for (int i = 1; i &lt;= 10; i++) &#123; await Future&lt;void&gt;.delayed(Duration(seconds: 1)); yield i; &#125;&#125;)();class StreamBuilderDemo extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return _StreamBuilderDemoState (); &#125;&#125;class _StreamBuilderDemoState extends State&lt;StreamBuilderDemo&gt; &#123; @override initState() &#123; super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( automaticallyImplyLeading: false, title: const Text('Flutter StreamBuilder Demo'), ), body: SizedBox( width: double._infinity_, child: Center( child: StreamBuilder&lt;int&gt;( stream: generateNumbers, initialData: 0, builder: ( BuildContext context, AsyncSnapshot&lt;int&gt; snapshot, ) &#123; if (snapshot.connectionState == ConnectionState.waiting) &#123; return Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: [ CircularProgressIndicator(), Visibility( visible: snapshot.hasData, child: Text( snapshot.data.toString(), style: const TextStyle(color: Colors._black_, fontSize: 24), ), ), ], ); &#125; else if (snapshot.connectionState == ConnectionState.active || snapshot.connectionState == ConnectionState.done) &#123; if (snapshot.hasError) &#123; return const Text('Error'); &#125; else if (snapshot.hasData) &#123; return Text( snapshot.data.toString(), style: const TextStyle(color: Colors._red_, fontSize: 40) ); &#125; else &#123; return const Text('Empty data'); &#125; &#125; else &#123; return Text('State: $&#123;snapshot.connectionState&#125;'); &#125; &#125;, ), ), ), ); &#125;&#125; 结语:在本文中，我已经简单介绍了 StreamBuilder 的基本结构; 您可以根据自己的选择修改这段代码。这是我对 StreamBuilder On User Interaction 的一个小小介绍，它正在使用 Flutter 工作。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 自定义单选按钮","date":"2021-08-23T16:00:00.000Z","path":"2021/08/24/translation/exploring-custom-radio-button-in-flutter/","text":"原文 https://medium.com/flutterdevs/exploring-custom-radio-button-in-flutter-4a93a7892185 正文 了解如何创建一个自定义单选按钮在您的 Flutter 应用程序 单选按钮则称为选择按钮，它保存布尔值。它允许客户从一组预定义的选择中选择一个选择。这个组件使它不完全相同于一个复选框，我们可以选择一个以上的替代和未选择的状态重新建立。我们可以组织至少两个单选按钮的集合，并在屏幕上显示为带有白色区域的圆形孔用于未选择或圆点用于选择。 我们同样可以给每个相关的单选按钮一个标签，描绘单选按钮地址的决定。一个单选按钮可以选择通过点击鼠标在圆形孔或利用控制台备用方式。 在这个博客，我们将探索自定义 Flutter 单选按钮。我们将看到如何实现一个自定义单选按钮演示程序，以及如何在您的颤振应用程序创建。 简介Flutter 允许我们利用 Radio 小部件制作单选按钮。用这个小部件制作的单选按钮由一个空白的外部圆和一个强内部圆组成，最后一个按钮显示在选择状态。时不时地，你可能需要制作一个 radio gathering，其替代方案利用自定义设计，而不是传统的 radio gathering 。本文举例说明了如何使用定制 catches 进行 radio gathering。 Demo Module : 演示模块: 这个演示视频显示了如何创建一个自定义单选按钮在 Flutter。它显示了如何自定义单选按钮将工作在您的 Flutter 应用程序。它展示了当用户点击按钮时，单选组将如何使用自定义按钮。动画的。它会显示在你的设备上。 如何实现 dart 文件中的代码:你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 radio_opton.dart 的新 dart 文件。 因为单选按钮包含一个标签，所以我们不能使用单选按钮。综上所述，我们将创建一个自定义类，它可以用于做出称为 MyRadioOption 的选择。受 Flutter 的 Radio 小部件的激励，该类具有 value、 groupValue 和 onChanged 属性。该属性的价值解决了替代品的价值，在类似群体的所有选择中，它应该是非同寻常的。 groupValue 属性是当前选定的值。如果选项值与 groupvalue 匹配，则该选项处于选定状态。onChanged 属性存储当用户选择一个选项时将调用的回调函数。当用户选择一个选项时，回调函数负责更新 groupValue。此外，我们还添加了标签和文本属性，因为我们需要在按钮上显示标签，并在按钮的右侧显示文本。 groupValue 属性是目前选择的值。如果选择值与 groupvalue 匹配，则替换处于选择状态。onChanged 属性存储回调函数，客户机选择时将考虑该函数。当客户机选择一个替代方案时，回调函数有义务更新 groupValue。此外，我们还添加了标签和文本属性，因为我们需要在按钮上显示名称，并在按钮的右侧显示内容。 下面是类的属性和构造函数。我们利用一个常规的类 T，理由是这个值可以是任何类型。 123456789101112131415161718192021class MyRadioOption&lt;T&gt; extends StatelessWidget &#123; final T value; final T? groupValue; final String label; final String text; final ValueChanged&lt;T?&gt; onChanged; const MyRadioOption(&#123; required this.value, required this.groupValue, required this.label, required this.text, required this.onChanged, &#125;); @override Widget build(BuildContext context) &#123; // TODO implement &#125;&#125; 然后，我们将制作布局。按钮是一个圆圈，里面有名字。为了制作圆形，使用一个圆形边框作为形状的图形装饰容器。名称可以使用 Text 作为容器的子部件。然后，在这一点上，我们可以创建一个由按钮和文本小部件组成的 Row。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';class MyRadioOption&lt;T&gt; extends StatelessWidget &#123; final T value; final T? groupValue; final String label; final String text; final ValueChanged&lt;T?&gt; onChanged; const MyRadioOption(&#123; required this.value, required this.groupValue, required this.label, required this.text, required this.onChanged, &#125;); Widget _buildLabel() &#123; final bool isSelected = value == groupValue; return Container( width: 30, height: 30, decoration: ShapeDecoration( shape: CircleBorder( side: BorderSide( color: Colors.black, ), ), color: isSelected ? Colors.cyan : Colors.white, ), child: Center( child: Text( value.toString(), style: TextStyle( color: isSelected ? Colors.white : Colors.cyan, fontSize: 20, ), ), ), ); &#125; Widget _buildText() &#123; return Text( text, style: const TextStyle(color: Colors.black, fontSize: 24), ); &#125; @override Widget build(BuildContext context) &#123; return Container( margin: EdgeInsets.all(8), child: InkWell( onTap: () =&gt; onChanged(value), splashColor: Colors.cyan.withOpacity(0.5), child: Padding( padding: EdgeInsets.all(5), child: Row( children: [ _buildLabel(), const SizedBox(width: 10), _buildText(), ], ), ), ), ); &#125;&#125; 在 lib 文件夹中创建一个名为 custom_radio_demo.dart 的新 dart 文件。 下面是一个类，其中我们使用 MyRadioOption 作为选择的无线电组。有一个状态变量 _ groupValue 和一个 ValueChanged 函数，这是当客户机选择一个备选方案时要考虑的回调函数。 12345String? _groupValue;ValueChanged&lt;String?&gt; _valueChangedHandler() &#123; return (value) =&gt; setState(() =&gt; _groupValue = value!);&#125; 在主体中，如何调用 MyRadioOption 的构造函数。 1234567891011121314MyRadioOption&lt;String&gt;( value: '1', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '1', text: 'Phone Gap',),MyRadioOption&lt;String&gt;( value: '2', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '2', text: 'Appcelerator',), 当我们运行应用程序时，我们应该获得屏幕输出，就像下面的屏幕截图一样。 Final Output 最终输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import 'package:flutter/material.dart';import 'package:flutter_custom_radio_button/radio_option.dart';class CustomRadioDemo extends StatefulWidget &#123; @override State createState() =&gt; new _CustomRadioDemoState();&#125;class _CustomRadioDemoState extends State&lt;CustomRadioDemo&gt; &#123; String? _groupValue; ValueChanged&lt;String?&gt; _valueChangedHandler() &#123; return (value) =&gt; setState(() =&gt; _groupValue = value!); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: AppBar( automaticallyImplyLeading: false, title: const Text('Flutter Custom Radio Button Demo'), backgroundColor: Colors.cyan, ), body: Column( children: [ Padding( padding: const EdgeInsets.all(10.0), child: Text(\"Best Cross-Platform Mobile App Development Tools for 2021\", style: TextStyle(fontWeight: FontWeight.bold,fontSize: 18),), ), SizedBox(height: 10,), MyRadioOption&lt;String&gt;( value: '1', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '1', text: 'Phone Gap', ), MyRadioOption&lt;String&gt;( value: '2', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '2', text: 'Appcelerator', ), MyRadioOption&lt;String&gt;( value: '3', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '3', text: 'React Native', ), MyRadioOption&lt;String&gt;( value: '4', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '4', text: 'Native Script', ), MyRadioOption&lt;String&gt;( value: '5', groupValue: _groupValue, onChanged: _valueChangedHandler(), label: '5', text: 'Flutter', ), ], ), ); &#125;&#125; 结语在本文中，我已经解释了自定义单选按钮的基本结构，您可以根据自己的选择修改这段代码。这是一个小的介绍自定义单选按钮对用户交互从我这边，它的工作使用 Flutter。 我希望这个博客将提供您尝试在您的 Flutter 项目的自定义单选按钮充足的信息。我们将向您展示介绍是什么？.这是一个如何制作自定义单选按钮的例子。从根本上说，每一种选择都应该具有价值和集团价值。组值应该是类似组中所有备选项中非常相似的东西。当客户选择一个替代方案时，组值会更新，所以请尝试一下。 如果我做错了什么，请在评论中告诉我，我很乐意改进。 鼓掌如果这篇文章对你有帮助。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter 采用 BlurHash 算法实现图像缩略图","date":"2021-08-18T16:00:00.000Z","path":"2021/08/19/translation/exploring-blurhash-image-placeholder-in-flutter/","text":"原文 https://medium.com/flutterdevs/exploring-blurhash-image-placeholder-in-flutter-24dad611c487 代码https://github.com/ducafecat/getx_quick_start 参考 https://pub.dev/packages/flutter_blurhash https://blurha.sh/ https://github.com/woltapp/blurhash 正文 根据联想速度的不同，从网络中叠加一张图片可能需要几分钟时间。在获取图片时，完全可以预期它会显示一个占位符。有一些显示占位符的策略。例如，您可以显示一个彩色框。在任何情况下，如果占位符可以像真实的图片一样，那就更令人愉快了。因此，你可以使用 BlurHash。 在这个博客中，我们将探索 Flutter 图片占位符。我们将看到如何实现 blur hash 的演示程序，以及如何使用 BlurHash 作为图像占位符，在您的 flutter 应用程序中使用 flutter_blurhash 包。 https://pub.dev/packages/flutter_blurhash 简介BlurHash 是图片占位符的保守描述。它的工作原理是从图片生成一个散列字符串。生成的散列字符串将用于传递占位符。本文介绍了在 Flutter 应用程序中解析要作为图片占位符交付的 BlurHash 字符串的最佳方法。 演示 这个演示视频展示了如何在 Flutter 中使用 blurhash。它展示了 blurhash 如何在您的 Flutter 应用程序中使用 flutter_blurhash 包工作。它显示了图像占位符的紧凑表示形式。它会显示在你的设备上。 构造函数这里有 BlurHash 的构造函数: 1234567891011121314const BlurHash(&#123; required this.hash, Key? key, this.color = Colors.blueGrey, this.imageFit = BoxFit.fill, this.decodingWidth = _DEFAULT_SIZE, this.decodingHeight = _DEFAULT_SIZE, this.image, this.onDecoded, this.onReady, this.onStarted, this.duration = const Duration(milliseconds: 1000), this.curve = Curves.easeOut,&#125;) 构造函数期望您传递一个边界散列，它是利用 BlurHash 算法得到的散列字符串。万一你现在没有散列字符串，你可以利用他们的权威站点 blurha。Sh 来创建您需要利用的图片的散列字符串。 参数BlurHash 的一些参数是: hash: 需要此参数。要解码的散列 onDecoded: 此参数用于在对哈希进行解码时回调 image: 此参数用于远程下载资源 imageFit: 此参数用于如何适应解码和下载的图像 color: 此参数用于在解码前显示背景颜色 duration: 此参数用于动画持续时间。默认值为 const Duration(milliseconds: 1000). curve: 此参数用于动画曲线。默认为 Curves.easeOut. onStarted: 此参数用于在下载开始时调用的回调 onReady: 此参数用于在下载映像时回调 实施 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 1flutter_blurhash: ^0.6.0 第二步: 导入 1import 'package:flutter_blurhash/flutter_blurhash.dart'; 第三步: 在应用程序的根目录中运行 flutter 软件包。 1$ flutter packages get 如何实现 dart 文件中的代码你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 main.dart 的新 dart 文件。 下面是一个只传递散列参数的模型。因为没有传递 Image 参数，它将显示占位符直到时间结束。 123BlurHash( hash: 'LHA-Vc_4s9ad4oMwt8t7RhXTNGRj',), 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 在主体中，我们将添加 BlurHash() 方法。在此方法中，我们将添加 imageFit，这意味着您可以通过将 BoxFit 枚举作为 imageFit 参数传递给构造函数来设置如何将图像适配到可访问空间。如果没有传递参数，值默认为 BoxFit.fill。imageFit 竞争的使用类似于 FittedBox 的合适属性。目前，我们将增加持续时间意味着图片已有效下载后，图片将活跃一个给定的期限之前完全显示。持续时间可以通过传递持续时间尊重作为持续时间争用来设置。如果没有传递参数，默认值是 1 秒 1234567BlurHash( imageFit: BoxFit.fitWidth, duration: const Duration(seconds: 4), curve: Curves.bounceInOut, hash: 'LHA-Vc_4s9ad4oMwt8t7RhXTNGRj', image: 'https://images.unsplash.com/photo-1486072889922-9aea1fc0a34d?ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8bW91dGFpbnxlbnwwfHwwfHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60',), 现在，我们将设置曲线意味着动画曲线可以通过设置曲线参数。默认值是 Curves.easeOut。最后，我们将添加 image 表示图像参数传递的位置，图像的远程 URL 作为值。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 现在，我们将设置曲线意味着动画曲线可以通过曲线参数设置。默认值是 Curves.easeOut。最后，我们将添加一个图像，这意味着图像参数是以图片的远端 URL 作为值传递的。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 完整代码123456789101112131415161718192021222324252627282930313233343536import 'package:flutter/material.dart';import 'package:flutter_blur_hash_demo/splash_screen.dart';import 'package:flutter_blurhash/flutter_blurhash.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( debugShowCheckedModeBanner: false, home: Splash(), ); &#125;&#125;class BlurHashDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( backgroundColor: Colors.teal, automaticallyImplyLeading: false, title: Text(\"Flutter BlurHash Demo\") ), body: Center( child: BlurHash( imageFit: BoxFit.fitWidth, duration: const Duration(seconds: 4), curve: Curves.bounceInOut, hash: 'LHA-Vc_4s9ad4oMwt8t7RhXTNGRj', image: 'https://images.unsplash.com/photo-1486072889922-9aea1fc0a34d?ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8bW91dGFpbnxlbnwwfHwwfHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60', ), ), );&#125; 结语在这篇文章中，我简单地解释了 BlurHash 图像占位符的基本结构; 您可以根据自己的选择修改这段代码。这是一个小的介绍 BlurHash 图片占位符用户交互从我这边，它的工作使用 Flutter。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 可拖动的悬浮动作按钮","date":"2021-08-15T16:00:00.000Z","path":"2021/08/16/translation/draggable-floating-action-button-in-flutter/","text":"原文 https://medium.com/flutterdevs/draggable-floating-action-button-in-flutter-2149a7e47f06 参考 https://pub.flutter-io.cn/packages/get#reactive-state-manager https://dart.dev/guides/language/extension-methods 正文 Flutter 允许您使用 FloatingActionButton 小部件添加一个浮动操作按钮。尽管如此，它不允许你拖动按钮。考虑一下你需要让它可拖动的可能性。本文有一个模型，它公开了制作一个浮动操作按钮需要做的事情，这个按钮可以在屏幕的任何地方拖动，只要它在父窗口小部件中。 在这个博客中，我们将探索 Flutter 的拖动浮动按钮。我们将看到如何实现一个演示程序的拖曳浮动行动按钮，并显示如何创建您的 Flutter 应用程序。 简介下面的演示视频显示了如何创建一个可拖动的漂浮动作按钮在 Flutter。它显示了如何拖动浮动行动按钮将在您的 Flutter 应用程序的工作。它显示当代码成功运行时，用户将一个浮动操作按钮拖动到屏幕周围的任何地方，只要它在父窗口小部件中。它会显示在你的设备上。 如何实现 dart 文件中的代码你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 main.dart 的新 dart 文件。 首先，我们将创建一个 Globalkey，并将其命名为 _parentKey 1final GlobalKey _parentKey = GlobalKey(); 在正文中，我们将添加一个具有高度和宽度的 Container 小部件。它是子属性，我们将添加 Stack 小部件。在这个小部件中，我们将添加一个键、文本和一个 DraggableFloatingActionButton ()。在按钮内部，我们将添加一个具有高度和宽度的容器。在其子属性中添加图像。此外，我们还将添加 initialOffset、父键和 onPressed。我们将深入定义下面的代码。 123456789101112131415161718192021222324252627282930Container( width: 300, height: 300, child: Stack( key: _parentKey, children: [ Container(color: Colors.cyan), Center( child: const Text( \"FlutterDev's.com\", style: const TextStyle(color: Colors.white, fontSize: 24), ), ), DraggableFloatingActionButton( child: Container( width: 60, height: 60, decoration: ShapeDecoration( shape: CircleBorder(), color: Colors.white, ), child: Image.asset(\"assets/logo.png\"), ), initialOffset: const Offset(120, 70), parentKey: _parentKey, onPressed: () &#123;&#125;, ), ], ),) 创建一个名为 draggable_floating_action_button.dart 的代码文件。 我们将为这样的小部件创建一个类。我们需要处理的主要问题是使按钮在指针之后可拖动的能力。可以使用的小部件之一是监听器，它可以识别指针移动事件并给出移动细节。基本上，按钮应该作为侦听器的子级进行包装。 Listener 小部件具有 onPointerMove 争用，可以利用该争用来传递一个回调，该回调在指针移动时将被考虑。回调函数应该有一个边界 PointerMoveEvent，其中包含 x 和 y 标题中的开发增量(增量)。Dx 和 delta。).捕获物的偏移量应该通过移动三角洲来刷新。 下面是制作可拖动浮动操作按钮的类。它有几个争论，包括子，initialOffset，和 onPressed。子小部件是利用依赖于当前偏移量的定位小部件交付的。此外，它还被包装为监听器小部件的子部件。此外，还有一个策略 _updatePosition ，根据移动的增量刷新当前的偏移量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class DraggableFloatingActionButton extends StatefulWidget &#123; final Widget child; final Offset initialOffset; final VoidCallback onPressed; DraggableFloatingActionButton(&#123; required this.child, required this.initialOffset, required this.onPressed, &#125;); @override State&lt;StatefulWidget&gt; createState() =&gt; _DraggableFloatingActionButtonState();&#125;class _DraggableFloatingActionButtonState extends State&lt;DraggableFloatingActionButton&gt; &#123; bool _isDragging = false; late Offset _offset; @override void initState() &#123; super.initState(); _offset = widget.initialOffset; &#125; void _updatePosition(PointerMoveEvent pointerMoveEvent) &#123; double newOffsetX = _offset.dx + pointerMoveEvent.delta.dx; double newOffsetY = _offset.dy + pointerMoveEvent.delta.dy; setState(() &#123; _offset = Offset(newOffsetX, newOffsetY); &#125;); &#125; @override Widget build(BuildContext context) &#123; return Positioned( left: _offset.dx, top: _offset.dy, child: Listener( onPointerMove: (PointerMoveEvent pointerMoveEvent) &#123; _updatePosition(pointerMoveEvent); setState(() &#123; _isDragging = true; &#125;); &#125;, onPointerUp: (PointerUpEvent pointerUpEvent) &#123; print('onPointerUp'); if (_isDragging) &#123; setState(() &#123; _isDragging = false; &#125;); &#125; else &#123; widget.onPressed(); &#125; &#125;, child: widget.child, ), ); &#125;&#125; 您需要向父部件添加一个键，并将其传递给 DraggableFloatingActionButton 部件。您可以从 currentContext 属性中获得 RenderBox，该属性具有 findRenderObject 策略。然后，在这一点上，您可以从 RenderBox 的 size 属性获得父级的大小。您应该谨慎，因为应该在构建树之后调用 findRenderObject 技术。随后，您需要利用 WidgetsBinding 的 addPostFrameCallback 来调用它。 技术的 _updatePosition 也应该改变。如果新的偏移量小于最小偏移量，则该值必须设置为最小偏移量。如果新的偏移量比最大偏移量更值得注意，则该值必须设置为最大偏移量。对于 x 轴和 y 轴都需要这样做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class DraggableFloatingActionButton extends StatefulWidget &#123; final Widget child; final Offset initialOffset; final VoidCallback onPressed; DraggableFloatingActionButton(&#123; required this.child, required this.initialOffset, required this.onPressed, &#125;); @override State&lt;StatefulWidget&gt; createState() =&gt; _DraggableFloatingActionButtonState();&#125;class _DraggableFloatingActionButtonState extends State&lt;DraggableFloatingActionButton&gt; &#123; final GlobalKey _key = GlobalKey(); bool _isDragging = false; late Offset _offset; late Offset _minOffset; late Offset _maxOffset; @override void initState() &#123; super.initState(); _offset = widget.initialOffset; WidgetsBinding.instance?.addPostFrameCallback(_setBoundary); &#125; void _setBoundary(_) &#123; final RenderBox parentRenderBox = widget.parentKey.currentContext?.findRenderObject() as RenderBox; final RenderBox renderBox = _key.currentContext?.findRenderObject() as RenderBox; try &#123; final Size parentSize = parentRenderBox.size; final Size size = renderBox.size; setState(() &#123; _minOffset = const Offset(0, 0); _maxOffset = Offset( parentSize.width - size.width, parentSize.height - size.height ); &#125;); &#125; catch (e) &#123; print('catch: $e'); &#125; &#125; void _updatePosition(PointerMoveEvent pointerMoveEvent) &#123; double newOffsetX = _offset.dx + pointerMoveEvent.delta.dx; double newOffsetY = _offset.dy + pointerMoveEvent.delta.dy; if (newOffsetX &lt; _minOffset.dx) &#123; newOffsetX = _minOffset.dx; &#125; else if (newOffsetX &gt; _maxOffset.dx) &#123; newOffsetX = _maxOffset.dx; &#125; if (newOffsetY &lt; _minOffset.dy) &#123; newOffsetY = _minOffset.dy; &#125; else if (newOffsetY &gt; _maxOffset.dy) &#123; newOffsetY = _maxOffset.dy; &#125; setState(() &#123; _offset = Offset(newOffsetX, newOffsetY); &#125;); &#125; @override Widget build(BuildContext context) &#123; return Positioned( left: _offset.dx, top: _offset.dy, child: Listener( onPointerMove: (PointerMoveEvent pointerMoveEvent) &#123; _updatePosition(pointerMoveEvent); setState(() &#123; _isDragging = true; &#125;); &#125;, onPointerUp: (PointerUpEvent pointerUpEvent) &#123; print('onPointerUp'); if (_isDragging) &#123; setState(() &#123; _isDragging = false; &#125;); &#125; else &#123; widget.onPressed(); &#125; &#125;, child: Container( key: _key, child: widget.child, ), ), ); &#125;&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 全部代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:flutter_draggable_floating/draggable_floating_action_button.dart';import 'package:flutter_draggable_floating/splash_screen.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( debugShowCheckedModeBanner: false, home: Splash(), ); &#125;&#125;class DraggableFloatingActionButtonDemo extends StatelessWidget &#123; final GlobalKey _parentKey = GlobalKey(); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: AppBar( automaticallyImplyLeading: false, title: const Text('Flutter Draggable Floating Action Button'), backgroundColor: Colors.cyan, ), body: Column( children: [ Container( height: 150, ), Container( width: 300, height: 300, child: Stack( key: _parentKey, children: [ Container(color: Colors.cyan), Center( child: const Text( \"FlutterDev's.com\", style: const TextStyle(color: Colors.white, fontSize: 24), ), ), DraggableFloatingActionButton( child: Container( width: 60, height: 60, decoration: ShapeDecoration( shape: CircleBorder(), color: Colors.white, ), child: Image.asset(\"assets/logo.png\"), ), initialOffset: const Offset(120, 70), parentKey: _parentKey, onPressed: () &#123;&#125;, ), ], ), ) ], ), ); &#125;&#125; 结语在这篇文章中，我已经解释了可拖动浮动按钮的基本结构，您可以根据自己的选择修改这个代码。这是一个小的介绍可拖动浮动操作按钮对用户交互从我这边，它的工作使用 Flutter。 我希望这个博客将提供给您充分的信息，尝试在您的 Flutter 项目的拖曳浮动行动按钮。我们将向您展示介绍是什么？.这就是在 Flutter 制作一个可拖动的浮动按钮的方法。从根本上讲，您可以利用 Listener 小部件来区分指针移动事件，并根据开发增量更新按钮偏移量。监听器小部件同样支持区分指针事件，除非按钮最近被拖动，否则应该在这些事件上执行按钮的活动。同样，您需要获得父按钮和按钮的大小，以防止按钮超出父按钮的范围。所以请尝试一下。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 动画转场欢迎屏 concentric_transition","date":"2021-08-09T16:00:00.000Z","path":"2021/08/10/translation/explore-concentric-transition-in-flutter/","text":"原文 https://medium.com/flutterdevs/explore-concentric-transition-in-flutter-82ef4194d3d9 代码https://github.com/tiamo/flutter-concentric-transition/tree/master/example 参考 https://pub.flutter-io.cn/packages/concentric_transition 正文 Flutter 小部件是使用现代框架构建的。这就像是一种反应。在这里，我们从小部件开始创建任何应用程序。屏幕中的每个组件都是一个小部件。这个小部件描述了根据他目前的配置和状态，他的前景应该是什么样的。小部件展示类似于它的想法和当前的设置和状态。 Flutter 自动化测试使您能够满足您的应用程序的高响应性，因为它有助于在您的应用程序中发现 bug 和各种问题。Flutter 是一个工具，开发移动，桌面，网络应用程序与代码 &amp; 是一个免费和开放源码的工具。 在本文中，我们将用 Flutter concentric_transition 探索 Concentric Transition 在 Flutter。利用该软件包，可以很容易地实现 Flutter 向心过渡。那么让我们开始吧。 https://pub.dev/packages/concentric_transition Concentric TransitionConcentric Transition 插件是一个非常好的 Flutter 插件。用户可以使用这个插件创建一个动画类型的入门屏幕，并创建自定义动画屏幕，如同心页面路由器，自定义剪刀，等等，就像我们使用同心页面，然后为我们提供动画类型的页面路线，将我们从一个屏幕到另一个屏幕。 特点 Concentric PageView 页面 Concentric Clipper 剪切图 Concentric PageRoute 转场路由 依赖包你需要分别在你的代码中实现它: 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 12dependencies: concentric_transition: ^1.0.1+1 第二步: 导入包 1import 'package:concentric_transition/concentric_transition.dart'; 第三步: 运行 Run flutter package get 加入代码 你需要分别在你的代码中实现它: 在定义 ConcentricPageView 之前，我们将创建一个类，在这个类中，我们将定义其标题、图像、颜色等，如下面的代码引用所示。 12345678910111213class OnboardingData &#123; final String? title; final Image? icon; final Color bgColor; final Color textColor; OnboardingData(&#123; this.title, this.icon, this.bgColor = Colors.white, this.textColor = Colors.black, &#125;);&#125; 在此之后，我们将在一个列表中定义入职类数据，该列表将在屏幕上显示给我们的数据。让我们用下面的代码来理解一下。 12345678910111213141516171819final List&lt;OnboardingData&gt; onBoardingData = [ OnboardingData( icon:Image.asset('assets/images/melon.png'), title: \"Fresh Lemon\\nfruits\", //textColor: Colors.white, bgColor: Color(0xffCFFFCE), ), OnboardingData( icon:Image.asset('assets/images/orange.png'), title: \"Fresh Papaya\\nfruits\", bgColor: Color(0xffFFE0E1), ), OnboardingData( icon:Image.asset('assets/images/papaya.png'), title: \"Fresh Papaya\\nfruits\", bgColor: Color(0xffFCF1B5), //textColor: Colors.white, ),]; 现在，我们将在动画的颜色和持续时间所在的主体中使用 ConcentricPageView 小部件。使用列小部件，我们将在一个框中显示图像，并在图像下方显示其标题。让我们用下面的代码来理解一下。 123456789101112131415161718192021222324252627282930ConcentricPageView( colors: colors, radius: 30, curve: Curves.ease, duration: Duration(seconds: 2), itemBuilder: (index, value) &#123; OnboardingData page = onBoardingData[index % onBoardingData.length]; return Container( child: Theme( data: ThemeData( textTheme: TextTheme( headline6: TextStyle( color: page.textColor, fontWeight: FontWeight.w600, fontFamily: 'Helvetica', letterSpacing: 0.0, fontSize: 17, ), subtitle2: TextStyle( color: page.textColor, fontWeight: FontWeight.w300, fontSize: 18, ), ), ), child: OnBoardingPage(onboardingDataPage: page), ), ); &#125;,), 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import 'dart:ui';import 'package:concentric_transition/concentric_transition.dart';import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:flutter/painting.dart';class ConcentricPageViewDemo extends StatelessWidget &#123; final List&lt;OnboardingData&gt; onBoardingData = [ OnboardingData( icon:Image.asset('assets/images/melon.png'), title: \"Fresh Lemon\\nfruits\", //textColor: Colors.white, bgColor: Color(0xffCFFFCE), ), OnboardingData( icon:Image.asset('assets/images/orange.png'), title: \"Fresh Papaya\\nfruits\", bgColor: Color(0xffFFE0E1), ), OnboardingData( icon:Image.asset('assets/images/papaya.png'), title: \"Fresh Papaya\\nfruits\", bgColor: Color(0xffFCF1B5), //textColor: Colors.white, ), ]; List&lt;Color&gt; get colors =&gt; onBoardingData.map((p) =&gt; p.bgColor).toList(); @override Widget build(BuildContext context) &#123; return MaterialApp( debugShowCheckedModeBanner: false, home: Scaffold( body: ConcentricPageView( colors: colors, radius: 30, curve: Curves.ease, duration: Duration(seconds: 2), itemBuilder: (index, value) &#123; OnboardingData page = onBoardingData[index % onBoardingData.length]; return Container( child: Theme( data: ThemeData( textTheme: TextTheme( headline6: TextStyle( color: page.textColor, fontWeight: FontWeight.w600, fontFamily: 'Helvetica', letterSpacing: 0.0, fontSize: 17, ), subtitle2: TextStyle( color: page.textColor, fontWeight: FontWeight.w300, fontSize: 18, ), ), ), child: OnBoardingPage(onboardingDataPage: page), ), ); &#125;, ), ), ); &#125;&#125;class OnBoardingPage extends StatelessWidget &#123; final OnboardingData onboardingDataPage; const OnBoardingPage(&#123; Key? key, required this.onboardingDataPage, &#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container( margin: EdgeInsets.symmetric( horizontal: 30.0, ), child: Column(// mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ _buildPicture(context), SizedBox(height: 30), _buildText(context), ], ), ); &#125; Widget _buildText(BuildContext context) &#123; return Text( onboardingDataPage.title!, style: Theme.of(context).textTheme.headline6, textAlign: TextAlign.center, ); &#125; Widget _buildPicture( BuildContext context, &#123; double size = 190, double iconSize = 170, &#125;) &#123; return Container( width: size, height: size, decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(60.0)), color: onboardingDataPage.bgColor// .withBlue(page.bgColor.blue - 40) .withGreen(onboardingDataPage.bgColor.green + 20) .withRed(onboardingDataPage.bgColor.red - 100) .withAlpha(90), ), padding:EdgeInsets.all(15), margin: EdgeInsets.only( top: 140, ), child:onboardingDataPage.icon, ); &#125;&#125;class OnboardingData &#123; final String? title; final Image? icon; final Color bgColor; final Color textColor; OnboardingData(&#123; this.title, this.icon, this.bgColor = Colors.white, this.textColor = Colors.black, &#125;);&#125; Conclusion在这篇文章中，我解释了探索 Concentric Transition Flutter，你可以根据自己的修改和实验，这个小介绍是从探索 Concentric Transition Flutter 从我们这边演示。 我希望这个博客将提供您尝试在您的 Flutter 项目探索 Concentric Transition 充分的信息。我们向您展示了什么探索 Concentric Transition 在 Flutter 是和工作在您的 Flutter 应用，所以请尝试它。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 微信群 ducafecat b 站 https://space.bilibili.com/404904528 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 定制时间简化组件 time_planner","date":"2021-08-05T16:00:00.000Z","path":"2021/08/06/translation/explore-customizable-time-planner-in-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/explore-customizable-time-planner-in-flutter-c8108218b52c 参考 https://pub.dev/packages/time_planner 正文 从一开始，Flutter 就是一次伟大的邂逅。建造迷人的用户界面从来没有这么快。不管你是一个业余爱好者还是一个有教养的开发者，要无可救药地迷恋上 Flutter 并不难。所有的软件开发人员都明白，日期是最棘手的事情。同样，时间表也不是特例。 在移动应用程序中，有很多情况下用户需要输入出生日期、预订机票、安排会议等等。 在这个文章，我们将探索定制的时间规划 Flutter。我们还将实现一个演示程序，并创建一个可定制的时间计划使用时间规划器包在您的 Flutter 应用程序。 https://pub.dev/packages/time_planner Introduction一个愉快的，简单的利用，定制的时间规划为 Flutter 移动，桌面和网络。这是一个按时间表向客户显示任务的小部件。每行显示一个小时，每列显示一天，但是您可以更改该部分的标题并显示您需要的任何其他内容。 这个演示视频显示了如何创建一个可定制的时间计划在 Flutter。它展示了如何定制的时间计划将工作，使用您的 Flutter 应用程序的时间计划包。它显示当用户点击任何行和列时，将创建一个随机的时间计划器。动画的。它会显示在你的设备上。 属性时间计划器有以下几个属性: startHour: 这属性是用来时间从这个开始，它将从 1 开始 endHour: 这属性用于此时间结束，最大值为 24 headers: 这属性用于创建天数，每天是一个 TimePlannerTitle。你应该至少创造一天 tasks: 这属性用于在时间计划器上列出小部件 style: 这属性用于时间计划程序的样式 currentTimeAnimation: 这属性用于小部件加载滚动到动画的当前时间。默认值为 true Implementation 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 1time_planner: ^0.0.3 第二步: 导入 1import 'package:time_planner/time_planner.dart'; 第三步: 在应用程序的根目录中运行 flutter 软件包。 1flutter packages get 代码你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 main.dart 的新 dart 文件。 首先，我们创建一个名为变量任务的 TimePlannerTask 列表。 1List&lt;TimePlannerTask&gt; tasks = []; 我们将创建一个 _addobject ()方法。 12345678910111213141516171819202122232425262728293031323334void _addObject(BuildContext context) &#123; List&lt;Color?&gt; colors = [ Colors.purple, Colors.blue, Colors.green, Colors.orange, Colors.cyan ]; setState(() &#123; tasks.add( TimePlannerTask( color: colors[Random().nextInt(colors.length)], dateTime: TimePlannerDateTime( day: Random().nextInt(10), hour: Random().nextInt(14) + 6, minutes: Random().nextInt(60)), minutesDuration: Random().nextInt(90) + 30, daysDuration: Random().nextInt(4) + 1, onTap: () &#123; ScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text('You click on time planner object'))); &#125;, child: Text( 'this is a demo', style: TextStyle(color: Colors.grey[350], fontSize: 12), ), ), ); &#125;); ScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text('Random task added to time planner!')));&#125; 在函数中，我们将添加 tasks.add ()方法。在内部，我们将添加 TimePlannerTask ()小部件。在这个小部件中，我们将添加颜色、日期时间、 minutesDuration 和 daysDuration。我们还将在用户点击时间计划器时显示 snackBar 消息。 在正文中，我们将添加 TimePlanner ()小部件。在内部，我们将添加 startHour、 endHour 和 header。在头文件中，我们将添加一些 TimePlannerTitle ()。此外，我们还将添加任务和样式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758TimePlanner( startHour: 2, endHour: 24, headers: [ TimePlannerTitle( date: \"7/20/2021\", title: \"tuesday\", ), TimePlannerTitle( date: \"7/21/2021\", title: \"wednesday\", ), TimePlannerTitle( date: \"7/22/2021\", title: \"thursday\", ), TimePlannerTitle( date: \"7/23/2021\", title: \"friday\", ), TimePlannerTitle( date: \"7/24/2021\", title: \"saturday\", ), TimePlannerTitle( date: \"7/25/2021\", title: \"sunday\", ), TimePlannerTitle( date: \"7/26/2021\", title: \"monday\", ), TimePlannerTitle( date: \"7/27/2021\", title: \"tuesday\", ), TimePlannerTitle( date: \"7/28/2021\", title: \"wednesday\", ), TimePlannerTitle( date: \"7/29/2021\", title: \"thursday\", ), TimePlannerTitle( date: \"7/30/2021\", title: \"friday\", ), TimePlannerTitle( date: \"7/31/2021\", title: \"Saturday\", ), ], tasks: tasks, style: TimePlannerStyle( showScrollBar: true ),), 现在，我们将创建一个漂浮的 actionbutton ()。 12345floatingActionButton: FloatingActionButton( onPressed: () =&gt; _addObject(context), tooltip: 'Add random task', child: Icon(Icons.add),), 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 Code File123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import 'dart:math';import 'package:flutter/material.dart';import 'package:flutter_customizable_time_plan/splash_screen.dart';import 'package:time_planner/time_planner.dart';void main() &#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( debugShowCheckedModeBanner: false, theme: ThemeData.dark(), home: Splash() ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key? key, required this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; List&lt;TimePlannerTask&gt; tasks = []; void _addObject(BuildContext context) &#123; List&lt;Color?&gt; colors = [ Colors.purple, Colors.blue, Colors.green, Colors.orange, Colors.cyan ]; setState(() &#123; tasks.add( TimePlannerTask( color: colors[Random().nextInt(colors.length)], dateTime: TimePlannerDateTime( day: Random().nextInt(10), hour: Random().nextInt(14) + 6, minutes: Random().nextInt(60)), minutesDuration: Random().nextInt(90) + 30, daysDuration: Random().nextInt(4) + 1, onTap: () &#123; ScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text('You click on time planner object'))); &#125;, child: Text( 'this is a demo', style: TextStyle(color: Colors.grey[350], fontSize: 12), ), ), ); &#125;); ScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text('Random task added to time planner!'))); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( automaticallyImplyLeading: false, title: Text(widget.title), centerTitle: true, ), body: Center( child: TimePlanner( startHour: 2, endHour: 24, headers: [ TimePlannerTitle( date: \"7/20/2021\", title: \"tuesday\", ), TimePlannerTitle( date: \"7/21/2021\", title: \"wednesday\", ), TimePlannerTitle( date: \"7/22/2021\", title: \"thursday\", ), TimePlannerTitle( date: \"7/23/2021\", title: \"friday\", ), TimePlannerTitle( date: \"7/24/2021\", title: \"saturday\", ), TimePlannerTitle( date: \"7/25/2021\", title: \"sunday\", ), TimePlannerTitle( date: \"7/26/2021\", title: \"monday\", ), TimePlannerTitle( date: \"7/27/2021\", title: \"tuesday\", ), TimePlannerTitle( date: \"7/28/2021\", title: \"wednesday\", ), TimePlannerTitle( date: \"7/29/2021\", title: \"thursday\", ), TimePlannerTitle( date: \"7/30/2021\", title: \"friday\", ), TimePlannerTitle( date: \"7/31/2021\", title: \"Saturday\", ), ], tasks: tasks, style: TimePlannerStyle( showScrollBar: true ), ), ), floatingActionButton: FloatingActionButton( onPressed: () =&gt; _addObject(context), tooltip: 'Add random task', child: Icon(Icons.add), ), ); &#125;&#125; 结语在这篇文章中，我已经简单地解释了 Customizable Time Planner 的基本结构; 您可以根据自己的选择修改这段代码。这是一个小规模的介绍定制时间计划对用户交互从我这边，它的工作使用 Flutter。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 新人指导插件 onboarding_overlay","date":"2021-08-04T16:00:00.000Z","path":"2021/08/05/translation/explore-onboarding-overlay-in-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/explore-onboarding-overlay-in-flutter-5ed882e123ac 参考 https://pub.flutter-io.cn/packages/onboarding_overlay 正文 Flutter 是一个开源的用户界面软件开发软件开发工具包。Flutter 是一个开源项目，由 Google 负责维护。目前，在 2021 年 3 月。谷歌已经发布了另一个新版本的 Flutter 2。作为一个软件开发工具包应用程序的 Flutter 是很好的，但是当构建一个大的应用程序时，在代码中会有一些问题或者 bug 需要调试。 Flutter 提供了多种调试工具，如时间轴检查器、内存和性能检查器等。这些工具简化了开发者的调试过程，下面列出了调试 Flutter 应用程序的不同工具。 你好朋友，我将谈论我的新博客上探索上板扑覆盖。我们还将实现一个探索 Onboarding 覆盖小部件演示，并使用它们在您的 Flutter 应用程序。那么让我们开始吧。 FlutterFlutter 是谷歌的用户界面工具包，它可以帮助你在创纪录的时间内用一个代码库为移动、网络和桌面构建漂亮的本地组合应用程序。这意味着你可以使用一种编程语言和一个代码库来创建两个不同的应用程序(iOS 和 Android)。 Onboarding Overlay 按照自定义的设计指南，Onboarding Overlay Package 动画包实现了 Onboarding 覆盖，在这里，我们可以使用任何 Onboarding 覆盖中的小部件，我们使用它向用户介绍一个他们不知道的功能。Onboarding overlay 是一个灵活的 Onboarding 小部件，可以通过任意数量的步骤和任意起始点启动和停止。 https://pub.flutter-io.cn/packages/onboarding_overlay Implementation你需要分别在你的代码中实现它: 第一步: 添加依赖项。 将依赖项添加到 pubspec.yaml 文件。 12dependencies: onboarding_overlay: ^2.1.0 步骤 2: 导入包: 1import 'package:onboarding_overlay/onboarding_overlay.dart'; 第三步: 在应用程序的根目录中运行 flutter 软件包。 Implementation在 libfolder 中创建一个名为 onboarding_overlay_demo.dart 的新 dart 文件。 首先，我们必须定义 GlobalKey 和它的内部，它的名字是 onBoardingKey 和 scaffoldKey。 12final GlobalKey&lt;OnboardingState&gt; onboardingKey = GlobalKey&lt;OnboardingState&gt;();final GlobalKey&lt;ScaffoldState&gt; scaffoldKey = GlobalKey&lt;ScaffoldState&gt;(); 现在我们将使用 Onboarding Widget，其中我们将使用 Steps 属性，其中我们已经使用了一些不同类型的属性，如标题，titleTextColor，labelBoxPadding，labelBoxDecoration，bodyText 等，我们已经使用了下面的代码，可以在参考的帮助下理解。 1234567891011121314151617181920OnboardingStep( focusNode: focusNodes[0], title: 'Tap anywhere to continue Tap anywhere to continue', titleTextColor: Colors.black, bodyText: 'Tap anywhere to continue Tap anywhere to continue', labelBoxPadding: const EdgeInsets.all(16.0), labelBoxDecoration: BoxDecoration( shape: BoxShape.rectangle, borderRadius: const BorderRadius.all(Radius.circular(8.0)), color: const Color(0xFF00E1FF), border: Border.all( color: const Color(0xFF1E05FB), width: 1.0, style: BorderStyle.solid, )), arrowPosition: ArrowPosition.bottomCenter, hasArrow: true, hasLabelBox: true, fullscreen: true,), Code File12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import 'package:flutter/material.dart';import 'package:onboarding_overlay/onboarding_overlay.dart';class OnBoardingOverlayDemo extends StatefulWidget &#123; const OnBoardingOverlayDemo(&#123; Key? key, required this.focusNodes, &#125;) : super(key: key); final List&lt;FocusNode&gt; focusNodes; @override _OnBoardingOverlayDemoState createState() =&gt; _OnBoardingOverlayDemoState();&#125;class _OnBoardingOverlayDemoState extends State&lt;OnBoardingOverlayDemo&gt; &#123; late int _counter; @override void initState() &#123; super.initState(); _counter = 0; &#125; @override void dispose() &#123; super.dispose(); &#125; void _increment(BuildContext context) &#123; setState(() &#123; _counter++; Onboarding.of(context)!.show(); &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: IconButton( focusNode: widget.focusNodes[4], icon: const Icon(Icons.menu), onPressed: () &#123;&#125;, ), title: Focus( focusNode: widget.focusNodes[3], child: const Text('Title'), ), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Focus( focusNode: widget.focusNodes[0], child: const Text('You have pushed the button this many times:'), ), Focus( focusNode: widget.focusNodes[2], child: Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), ), ], ), ), floatingActionButton: FloatingActionButton( focusNode: widget.focusNodes[1], onPressed: () &#123; _increment(context); &#125;, child: const Icon(Icons.add), ), ); &#125;&#125; Conclusion在这篇文章中，我已经解释了在 Flutter 探索在板上覆盖，你可以根据自己的修改和实验，这个小介绍是从我们这边的 Flutter 探索在板上覆盖演示。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 中的响应式框架","date":"2021-07-26T16:00:00.000Z","path":"2021/07/27/translation/responsive-framework-in-flutter/","text":"猫哥说这是个自动管理响应界面处理的组件，比较适合在 flutter web 的项目中。 自动管理了你的 Resizing、最大、最小尺寸、Scaling 缩放比例，但是我没有发现布局的控制，但是这已经很不错了，又可以少写代码了。 最小尺寸效果 https://gallery.codelessly.com/flutterwebsites/minimal/?utm_medium=link&amp;utm_campaign=demo#/ Flutter.dev 官网 https://gallery.codelessly.com/flutterwebsites/flutterwebsite/?utm_medium=link&amp;utm_campaign=demo 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/responsive-framework-in-flutter-74b8b2a360a9 代码https://github.com/ducafecat/getx_quick_start 参考 https://pub.dev/packages/responsive_framework 正文 Flutter 是 Google 的用户界面工具宝库，用于从一个代码库生成优秀的、本地编译的 iOS 和 Android 应用程序。为了构建任何应用程序，我们从小部件开始ー Flutter 应用程序的构建方块。窗口小部件根据当前的设计和状态描述他们的视图应该类似的内容。它整合了一个文本小部件、行小部件、列小部件、容器小部件等等。 本文利用 Flutter 响应框架软件包对 Flutter 响应框架进行了研究。有了软件包的帮助，我们可以很容易地实现一个响应屏幕。那么让我们开始吧。 响应式框架响应式框架会自动调整你的用户界面以适应不同的屏幕尺寸。创建您的用户界面一次，并有它显示像素完美的移动，平板电脑和桌面！ 支持多种显示大小通常意味着多次重新创建相同的布局。在传统的 Bootstrap 方法下，构建响应式 UI 是耗时、令人沮丧和重复的。此外，让一切像素完美几乎是不可能的，简单的编辑需要几个小时。 实施方案 第一步: 添加依赖项 将依赖项添加到 pubspec.yaml 文件。 依赖性: 12dependencies: responsive_framework: ^0.1.4 第二步: 导入 1import 'package:responsive_framework/responsive_framework.dart'; 第三步: 启用 AndriodX 1234org.gradle.jvmargs=-Xmx1536Mandroid.enableR8=trueandroid.useAndroidX=trueandroid.enableJetifier=true 代码实现 你需要分别在你的代码中实现它 在创建类似于响应式框架的 UI 之前，我们在 main 的 Material 应用部件中添加了 ResponsiveWrapper.builder() 。文件中初始化 MaxWith，MinWith 和 Breakpoints 的 List 类型，在它内部调整设备的大小，如移动设备，平板电脑，桌面，并且自动缩放值是定义的，让我们理解它与下面的代码引用。 123456789101112131415ResponsiveWrapper.builder( BouncingScrollWrapper.builder(context, widget!), maxWidth: 1200, minWidth: 450, defaultScale: true, breakpoints: [ ResponsiveBreakpoint.resize(450, name: MOBILE), ResponsiveBreakpoint.autoScale(800, name: MOBILE), ResponsiveBreakpoint.autoScale(800, name: TABLET), ResponsiveBreakpoint.autoScale(1000, name: TABLET), ResponsiveBreakpoint.resize(1200, name: DESKTOP), ResponsiveBreakpoint.autoScale(2460, name: \"4K\"), ], background: Container(color: Color(0xFFF5F5F5)) ), 自动缩放按比例缩小和扩展布局，保持 UI 的精确外观。这就消除了手动调整布局以适应移动设备、平板电脑和桌面的需要。 在此之后，我们创建了一个用户配置文件屏幕，其中是用户的图像，以及两种不同类型的列表，其中图像和一些文本已经给出。 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394import 'package:flutter/material.dart';import 'package:responsive_framwork_demo/Constants/Constants.dart';import 'package:responsive_framwork_demo/device_size.dart';import 'package:responsive_framwork_demo/model/popular_course_model.dart';import 'package:responsive_framwork_demo/model/result_model.dart';class ProfileScreen extends StatefulWidget &#123; @override _ProfileScreenState createState() =&gt; _ProfileScreenState();&#125;class _ProfileScreenState extends State&lt;ProfileScreen&gt; &#123; late List&lt;PopularCourseModel&gt; popularCourseModel; late List&lt;ResultModel&gt; resultModel; @override void initState() &#123; popularCourseModel = Constants.getPopularCourseModel(); resultModel = Constants.getResultModel(); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors.white, appBar: AppBar( backgroundColor: Colors.white, elevation: 0.0, title: Text( 'PROFILE', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 15, fontWeight: FontWeight.bold, letterSpacing: 0.5), ), centerTitle: true, ), body: SingleChildScrollView( child: Container( padding: EdgeInsets.only(top: 20), child: Column( children: [ ClipOval( child: CircleAvatar( maxRadius: 50, child: Image.asset( 'assets/images/mans_img.jpeg', width: DeviceSize.width(context), fit: BoxFit.fill, ), ), ), SizedBox( height: 30, ), Text( 'Crowley Singer', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 15, fontWeight: FontWeight.bold, letterSpacing: 0.3), ), Container( margin: EdgeInsets.only(top: 25, left: 20, right: 20), child: Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: [ Column( children: [ Text( '22', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 15, fontWeight: FontWeight.bold, letterSpacing: 0.5), ), SizedBox( height: 10, ), Text( 'Courses', style: TextStyle( fontFamily: 'Poppins Regular', color: Colors.black45, fontSize: 11, fontWeight: FontWeight.bold, letterSpacing: 0.3), ), ], ), Container( height: 32, width: 1, color: Colors.black12, ), Column( children: [ Text( '32', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 15, fontWeight: FontWeight.bold, letterSpacing: 0.5), ), SizedBox( height: 10, ), Text( 'Mentors', style: TextStyle( fontFamily: 'Poppins Regular', color: Colors.black45, fontSize: 11, fontWeight: FontWeight.bold, letterSpacing: 0.3), ), ], ), Container( height: 32, width: 1, color: Colors.black12, ), Column( children: [ Text( '48', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 15, fontWeight: FontWeight.bold, letterSpacing: 0.5), ), SizedBox( height: 10, ), Text( 'Friends', style: TextStyle( fontFamily: 'Poppins Regular', color: Colors.black45, fontSize: 11, fontWeight: FontWeight.bold, letterSpacing: 0.3), ), ], ), ], ), ), Container( margin: EdgeInsets.only(top: 30, left: 20, right: 20), height: 1, color: Colors.black12, width: DeviceSize.width(context), ), Container( margin: EdgeInsets.only(top: 30, left: 20, right: 20), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Text( 'YOUR COURSES', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 12, fontWeight: FontWeight.w700, letterSpacing: 0.5), ), Icon(Icons.more_horiz), ], ), ), Container( margin: EdgeInsets.only(top: 10, left: 20, right: 20), height: DeviceSize.height(context) / 7, // color:Colors.purple, child: ListView.separated( separatorBuilder: (BuildContext context, int index) &#123; return SizedBox(width: 10); &#125;, scrollDirection: Axis.horizontal, // padding:EdgeInsets.only(left:10), //shrinkWrap: true, itemCount: popularCourseModel.length, itemBuilder: (BuildContext context, int index) &#123; return _buildYourCourseModel( popularCourseModel[index], index); &#125;, ), ), Container( margin: EdgeInsets.only(top: 30, left: 20, right: 20), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Text( 'YOUR PROGRESS', style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 12, fontWeight: FontWeight.w700, letterSpacing: 0.5), ), Icon(Icons.more_horiz), ], ), ), Container( // height:DeviceSize.height(context), width: DeviceSize.width(context), margin: EdgeInsets.only(top: 20), child: ListView.separated( separatorBuilder: (BuildContext context, int index) &#123; return SizedBox(height: 10); &#125;, scrollDirection: Axis.vertical, // padding:EdgeInsets.only(left:10), physics: NeverScrollableScrollPhysics(), shrinkWrap: true, itemCount: resultModel.length, itemBuilder: (BuildContext context, int index) &#123; return _buildResultModel(resultModel[index], index); &#125;, ), ), ], ), ), ), ); &#125; Widget _buildYourCourseModel(PopularCourseModel items, int index) &#123; return Container( width: 70, child: Column( //mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ Container( decoration: BoxDecoration( shape: BoxShape.circle, color: Colors.white, boxShadow: [ BoxShadow( color: Colors.blueGrey.shade50, offset: const Offset( 5.0, 5.0, ), blurRadius: 10.0, spreadRadius: 2.0, ), //BoxShadow BoxShadow( color: Colors.white, offset: const Offset(0.0, 0.0), blurRadius: 0.0, spreadRadius: 0.0, ), //BoxShadow ], ), child: ClipOval( child: CircleAvatar( backgroundColor: Colors.white, maxRadius: 30, // child:Image.asset('assets/images/earth.png',height:45,color:Colors.blueAccent,) , child: Padding( padding: EdgeInsets.all(4), child: Image.asset( items.img, fit: BoxFit.cover, scale: 7, ), ), ), ), ), Expanded( child: Container( padding: EdgeInsets.only(top: 0), alignment: Alignment.center, child: Text( items.title, style: TextStyle( fontFamily: 'Poppins Medium', fontWeight: FontWeight.w700, letterSpacing: 0.3, fontSize: 11, color: Colors.black), ), ), ), ], ), ); &#125; Widget _buildResultModel(ResultModel items, int index) &#123; return Container( margin: EdgeInsets.only(left: 20, right: 20), height: DeviceSize.height(context) / 9,// / color:Colors.pink, child: Row( children: [ Container( decoration: BoxDecoration( shape: BoxShape.circle, color: Colors.white, boxShadow: [ BoxShadow( color: Colors.blueGrey.shade50, offset: const Offset( 5.0, 5.0, ), blurRadius: 10.0, spreadRadius: 2.0, ), //BoxShadow BoxShadow( color: Colors.white, offset: const Offset(0.0, 0.0), blurRadius: 0.0, spreadRadius: 0.0, ), //BoxShadow ], ), child: ClipOval( child: CircleAvatar( backgroundColor: Colors.white, maxRadius: 28, // child:Image.asset('assets/images/earth.png',height:45,color:Colors.blueAccent,) , child: Padding( padding: EdgeInsets.all(4), child: Image.asset( items.img, fit: BoxFit.cover, scale: 7, ), ), ), ), ), SizedBox( width: 20, ), Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( items.title, style: TextStyle( fontFamily: 'Poppins Medium', color: Colors.black, fontSize: 11.5, fontWeight: FontWeight.w700, letterSpacing: 0.5), ), SizedBox( height: 5, ), Text( items.subTitle, style: TextStyle( fontFamily: 'Poppins Regular', color: Colors.black45, fontSize: 11, fontWeight: FontWeight.w700, letterSpacing: 0.5), ), ], ), ], ), ); &#125;&#125; 总结在这篇文章中，我解释了在 Flutter 响应框架，你可以根据自己的修改和实验，这个小介绍是从我们这边的 Flutter 响应框架演示。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter fvm 版本控制","date":"2021-07-21T16:00:00.000Z","path":"2021/07/22/translation/version-management-in-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/version-management-in-flutter-c232b04f1919 参考 https://github.com/leoafarias/fvm https://fvm.app/ 正文 Flutter 是一个可移植的 UI 工具包。换句话说，它是一个全面的应用软件开发工具包(SDK) ，包括小部件和工具。Flutter 是一个免费的开源工具，用于开发移动、桌面和 web 应用程序。Flutter 是一种跨平台的开发工具。这意味着用同样的代码，我们可以同时创建 ios 和 android 应用程序。这是在整个过程中节省时间和资源的最佳方式。在这方面，hot reload 正在获得移动开发者的支持。允许我们通过热重装快速查看在代码中实现的更改。 Flutter 管理版本允许不同类型的 Flutter 版本可在项目的基础上。这意味着我们可以为不同类型的项目定义特定类型的 Flutter 版本，它允许我们释放多个通道，在本地缓存它，因此切换版本。那我们就不用等安装好了。 在本文中，我们将学习 Flutter 版本管理。在这里，我们将看到如何建立工作版本管理抖动。我们开始吧。我们开始吧。 版本管理(FVM)在进行 Flutter 项目时，需要发布更新的 Flutter 和应用程序，并进行验证，切换不同类型的软件开发工具包进行测试，这需要时间。为了避免这一点，我们使用 Flutter 版本管理，它为我们提供了不同类型的 Flutter 版本我们的机器。因此，每次 Flutter 可以测试应用程序对更新 Flutter 版本没有等待安装，将能够切换到 Flutter 版本相应。 安装首先需要确定 Flutter 是否已经安装，以及 Flutter 是否是稳定通道。如果没有，则在命令行中键入以下代码。 12345678// set flutter to stable channelflutter channel stable// check flutter channelflutter channel// outputFlutter channels: master dev beta* stable 在这之后，我们必须确定我们的 Flutter 是否已经安装或没有，如果没有，那么首先我们将安装 FVM 1$ pub global activate fvm step 现在我们将看到在安装过程结束时给出了一些警告，因此我们需要将 fvm 路径添加到 shell 配置文件(。在进行下一个步骤之前，请使用 bashrc、 bash_profile 等 123export PATH=”$PATH:`pwd`/flutter/bin”$ fvm installexport PATH=”$PATH:`pwd`/bin/cache/dart-sdk/bin”export PATH=”$PATH:`pwd`/.pub-cache/bin” SDK 版本说明DVM 允许我们安装多种类型的 Flutter 释放或通道安装通道使用稳定和安装 Flutter 释放版本我们将使用 v2.0.5 或 1.17.0-dev. 3.1 和一旦我们运行-跳过-安装，它将跳过安装 1$ fvm install stable or fvm install 2.0.5 Project Config SDK Version在此之后，我们将看到，无论项目是否配置为使用特定的版本，如果没有，我们将在没有参数的适当版本上安装它。 1$ fvm install 已安装的 Flutter 版本列表现在，通过输入以下命令，我们可以通过使用下面的命令 FVM 将存储 SDK 版本来列出我们机器上已安装的版本。 1$ fvm list 升级 SDK 版本使用升级 SDK 版本命令时，我们需要升级我们目前的 SDK 版本，所以你必须调用您的 Flutter SDK 命令作为正常的 Flutter 安装。 1$ fvm flutter upgrade 设置 IDE现在我们来看看如何配置 IDE，下面我们展示了如何在 android studio 和 VS Code 中进行配置，现在让我们来看看。 Android Studio 在根项目目录中复制下面的绝对符号链接。 1Example: /absolute/path-to-your-project/.fvm/flutter_sdk 然后我们将在 Android Studio 的菜单中打开 Languages and Frameworks-&gt; Now search for flutter or flutter and change the path to flutter SDK。然后实施改变。现在您可以使用选定的 Flutter 版本运行它并调试它。如果你想看到新的设置，然后我们可以使用 Android 工作室将重新启动。 VS Code 现在我们将在这里配置 VS Code，我们将看到如何完成 VS Code 过程。 目录的路径，我们可以在代码中看到 FVM 安装的所有版本 1\"dart.flutterSdkPaths\": [\"$YOUR_PATH/fvm/versions\",], 为了获得上面的路径，我们将执行 fvm list 命令 12// copy this pathVersions path: $YOUR_PATH/fvm/versions 输入 cmd + shift + p 来使用 sdk，然后输入 change sdk，现在你可以选择你喜欢的版本了。 总结在这篇文章中，我对版本管理做了一个简单的解释，你可以根据自己的需要对其进行修改和实验，这个简单的介绍来自于版本管理的 Flutter。 我希望这个博客将提供您尝试在 Flutter 版本管理充分的信息。我们向您展示了 Flutter 探索版本管理和工作在您的 Flutter 应用程序，所以请尝试它。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 dart fluter 中使用 typedef","date":"2021-07-19T16:00:00.000Z","path":"2021/07/20/translation/explore-typedef-in-dart-fluter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/explore-typedef-in-dart-fluter-6dd102fdf5f9 参考 https://dart.dev/guides/language/language-tour#typedefs 正文 在这个博客中，我们将探索 TypeDef In Dart &amp; Fluter。它告诉你在 Dart 中使用 typedef 的最好方法。它同样工程在 Flutter 和有一个利用例子在您的 Flutter 应用程序。 在 Dart 中，您可以使用 typedef 关键字创建类型别名来使用某种类型。本文介绍了如何制作函数型和非函数型的 typedef，以及如何利用所制作的 typedef。 如何为函数使用 typedefTypedef 关键字最初是在 Dart 1 中使用的，用来暗示函数。在 Dart 1 中，如果需要将函数用作变量、字段或边界，则需要首先使用 typedef。 要使用类型别名，只需将函数标记降级为 typedef。从那时起，您可以使用 typedef 作为变量、字段或边界，如下面的模型所示。 1234567891011121314151617181920212223242526typedef IntOperation&lt;int&gt; = int Function(int a, int b);int processTwoInts (IntOperation&lt;int&gt; intOperation, int a, int b) &#123; return intOperation(a, b);&#125;class MyClass &#123; IntOperation&lt;int&gt; intOperation; MyClass(this.intOperation); int doIntOperation(int a, int b) &#123; return this.intOperation(a, b); &#125;&#125;void main() &#123; IntOperation&lt;int&gt; sumTwoNumbers = (int a, int b) =&gt; a + b; print(sumTwoNumbers(2, 2)); print(processTwoInts(sumTwoNumbers, 2, 1)); MyClass myClass = MyClass(sumTwoNumbers); print(myClass.doIntOperation(4, 4));&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像屏幕下方的最终输出一样: 123438 下面是函数具有泛型参数类型的另一个模型。 12345678910111213141516typedef Compare&lt;T&gt; = bool Function(T a, T b);bool compareAsc(int a, int b) =&gt; a &lt; b;int compareAsc2(int a, int b) =&gt; a - b;bool doComparison&lt;T&gt;(Compare&lt;T&gt; compare, T a, T b) &#123; assert(compare is Compare&lt;T&gt;); return compare(a, b);&#125;void main() &#123; print(compareAsc is Compare&lt;int&gt;); print(compareAsc2 is Compare&lt;int&gt;); doComparison(compareAsc, 1, 2); doComparison(compareAsc2, 1, 2);&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像屏幕下方的最终输出一样: 123truefalsetrue 自从 Dart 2 之后，你可以在任何地方使用函数类型的标点符号。因此，再使用 typedef 并不重要。另外还表示喜欢内联函数类型。这是因为阅读代码的个人可以直接看到函数类型。下面是可以与没有 typedef 的主体模型进行比较的内容。 123456789101112131415161718192021222324int processTwoInts (int Function(int a, int b) intOperation, int a, int b) &#123; return intOperation(a, b);&#125;class MyClass &#123; int Function(int a, int b) intOperation; MyClass(this.intOperation); int doIntOperation(int a, int b) &#123; return this.intOperation(a, b); &#125;&#125;void main() &#123; int Function(int a, int b) sumTwoNumbers = (int a, int b) =&gt; a + b; print(sumTwoNumbers(2, 2)); print(processTwoInts(sumTwoNumbers, 2, 1)); MyClass myClass = MyClass(sumTwoNumbers); print(myClass.doIntOperation(4, 4));&#125; 尽管如此，如果函数很长而且大部分时间被利用，那么使用 typedef 很有价值。 对 Non-Functions 使用 typedef:在 Dart 2.13 之前，你可以使用 typedef 来处理函数类型。自从 Dart 2.13 以来，你同样可以使用 typedefs 来创建暗示非函数的类型别名。使用基本上是相同的，你只需要允许类型作为一个 typedef。 首先，你的 Dart 表格应该是 2.13 或以上版本。为 Flutter，你需要利用版本 2.2 或以上。此外，您还需要在 pubspec 中刷新基本 SDK 表单。Yaml to 2.13.0 and run bar get (for Dart)或 Flutter pub get (for Flutter)。 12environment: sdk: \"&gt;=2.13.0 &lt;3.0.0\" 例如，您需要描述存储整数数据列表的类型。由于这个原因，您可以创建一个 typedef，其类型是 List &lt;int&gt; 。之后，如果需要描述用于放置信息显示的变量，可以使用 typedef 作为类型。在下面的模型中，我们刻画了一个类型为 List &lt;int&gt; 的被认为是 DataList 的 typedef。正如您可以在下面的代码中找到的，利用 typedef 可以给您提供与利用实际类型相似的操作。您可以直接降级列表值，并访问 List 的技术和属性。如果你检查 runtimeType，你会得到 List &lt;int&gt; 作为结果。 123456789typedef DataList = List&lt;int&gt;;void main() &#123; DataList data = [50, 60]; data.add(100); print('length: $&#123;data.length&#125;'); print('values: $data'); print('type: $&#123;data.runtimeType&#125;');&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像屏幕下方的最终输出一样: 123length: 3values: [50,60,100]type: List&lt;int&gt; 与变量不同，类型别名同样可以用作技术的字段、参数和返回值。 12345678910111213141516171819202122232425262728293031typedef DataList = List&lt;int&gt;;class MyClass &#123; DataList currentData; MyClass(&#123;required this.currentData&#125;); set data(DataList currentData) &#123; this.currentData = currentData; &#125; ScoreList getMultipliedData(int multiplyFactor) &#123; DataList result = []; currentData.forEach((element) &#123; result.add(element * multiplyFactor); &#125;); return result; &#125;&#125;void main() &#123; MyClass myClass = MyClass(currentData: [50, 60, 70]); myClass.data = [60, 70]; print(myClass.currentData); print(myClass.getMultipliedData(3));&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像屏幕下方的最终输出一样: 12[70, 90][180, 210] 下面是另一种模式。例如，您需要一个用于存储请求正文的类型，该类型的键和值类型对于每种类型都可能不同。对于这种情况，Map &lt;String，dynamic&gt; data type 是合理的。尽管如此，每次您需要声明一个请求主体变量时，您可以为该类型创建 typedef，而不是使用 Map &lt;String，dynamic&gt; 。 12345678910111213141516typedef RequestBody = Map&lt;String, dynamic&gt;;void main() &#123; final RequestBody requestBody1 = &#123; 'type': 'BUY', 'itemId': 2, 'amount': 200, &#125;; final RequestBody requestBody2 = &#123; 'type': 'CANCEL_BUY', 'orderId': '04567835', &#125;; print(requestBody1); print(requestBody2);&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像屏幕下方的最终输出一样: 12&#123;type: BUY, itemId: 2, amount: 200&#125;&#123;type: CANCEL_BUY, orderId: 04567835&#125; 还可以定义具有泛型类型参数的类型别名。下面的 ValueList 类型别名有一个泛型类型参数 t。使用类型别名定义变量时，可以传递要使用的泛型类型。 类似地，您可以表示具有泛型类型参数的类型别名。下面的 NumberList 类型别名具有一个非独占类型参数 t。在利用类型别名对变量进行特征化时，可以传递常规类型以进行利用。 123456789typedef NumberList&lt;T&gt; = List&lt;T&gt;;void main() &#123; NumberList&lt;String&gt; numbers = ['1', '2', '3']; numbers.add('4'); print('length: $&#123;numbers.length&#125;'); print('numbers: $numbers'); print('type: $&#123;numbers.runtimeType&#125;');&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像屏幕下方的最终输出一样: 123length: 4numbers: [1, 2, 3, 4]type: List&lt;String&gt; Usage in Flutter下面的代码是一个 Flutter 模型，它为 List &lt;widget&gt; 类型定义了 typedef。 12345678910111213141516171819202122232425262728293031323334353637383940414243import 'package:flutter/material.dart';typedef WidgetList = List&lt;Widget&gt;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', home: TypedefExample(), debugShowCheckedModeBanner: false, ); &#125;&#125;class TypedefExample extends StatelessWidget &#123; WidgetList buildMethod() &#123; return &lt;Widget&gt;[ const FlutterLogo(size: 60), const Text('FlutterDevs.com', style: const TextStyle(color: Colors.blue, fontSize: 24)), ]; &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: const Text('Flutter Demo'), ), body: SizedBox( width: double.infinity, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: buildMethod(), ), ), ); &#125;&#125; Conclusion在这篇文章中，我解释了在 Dart &amp; Fluter 中 TypeDef 的基本结构，您可以根据自己的选择修改这个代码。这是一个小型介绍 TypeDef 在 Dart 和 Fluter 对用户交互从我这边，它的工作使用 Flutter。 我希望这个博客能够为你提供足够的信息，帮助你在你的项目中尝试使用 TypeDef In Dart &amp; Fluter。这就是如何制作和利用 Dart/Flutter 中的 typedef。您需要允许 typedef 的类型或函数签名。然后，在这一点上，可以将所生成的 typedef 用作策略的变量、字段、参数或返回值。所以请尝试一下。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 Flutter 中实现文字动画","date":"2021-07-18T16:00:00.000Z","path":"2021/07/19/translation/exploring-text-animations-in-flutter/","text":"微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/exploring-text-animations-in-flutter-9b74103940d2 参考 https://pub.dev/packages/animated_text_kit 正文 动画期望在更新您的应用程序的整体客户机体验从视觉分析，运动，和自定义动画的巨大的一部分，你真的可以想象！.就像协调到应用程序中的一些不同的东西一样，动画应该是有帮助的，而不是基本上是一个正常的复杂格式。 在 Flutter，动画是直接做到的，而且很多古怪的东西可以用比原生 Android 更少的努力来完善。 在本帖中，我们将探索 Flutter 文本动画。我们还将实现一个演示程序的文本动画，并显示一个冷静和美丽的文本动画收集使用的动画工具包在您的 Flutter 应用程序。 https://pub.dev/packages/animated_text_kit 简介一个 Flutter 小工具包，包含一些很酷的和伟大的内容动画分类。我们将制作非凡的和优秀的内容动画利用动画 animated_text_kit 工具包包。 属性以下是 AnimatedTextKit 的一些属性: animatedTexts: 动画文本: 此属性用于列出[ AnimatedText ] ，以便随后在动画中显示 isRepeatingAnimation: 重复动画: 此属性用于设置动画是否应该通过将其值更改为 false 来重复。默认情况下，它被设置为 true totalRepeatCount: 累计重复计数: 此属性用于设置动画应重复的次数。默认情况下，设置为 3 repeatForever: 此属性用于设置动画是否会永远重复。如果你想永远重复，还需要将动画设置为 true onFinished: 此属性用于将 onFinished [ VoidCallback ]添加到动画小部件。只有当[ isrepetinganimation ]设置为 false 时，此方法才会运行 onTap: 此属性用于将 onTap [ VoidCallback ]添加到动画小部件 stopPauseOnTap: 此属性用于暂停，是否需要点击删除剩余的暂停时间？.默认情况下，它被设置为 false 安装 第一步: 添加依赖项 将依赖项添加到 pubspec.yaml 文件。 1animated_text_kit: ^4.2.1 第二步: 导入 1import 'package:animated_text_kit/animated_text_kit.dart'; 第三步: 在应用程序的根目录中运行 flutter 软件包。 1flutter packages get 如何实现 dart 文件中的代码你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 home_page_screen.dart 的新 dart 文件。 我们将在主页屏幕上创建九个不同的按钮，当用户点击按钮时，动画将工作。所有按钮都有不同的动画效果。我们将在下面深入讨论这个问题。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 旋转动画文字在正文中，我们将添加一个列小部件。在这个小部件中，添加一个具有高度和宽度的 Container。其子属性，添加一个 _rotate() 小部件。 12345678910111213141516Center( child: Column( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.center, children: [ Container( decoration: BoxDecoration(color: Colors.red), height: 300.0, width: 350.0, child: Center( child: _rotate(), ), ), ], ),) 在 _rotate() 小部件中。我们将返回 Row 小部件。在内部，添加文本和 defaultextstyle()。它是子属性，我们将添加 AnimatedTextKit()小部件。在里面，我们将添加 repeatForever 是真实的，isRepeatingAnimation 也是真实的，并添加 animatedtext。在 animatedtext 中，我们将添加三个 RotateAnimatedText()。用户还可以添加持续时间，旋转。 1234567891011121314151617181920212223242526Widget _rotate()&#123; return Row( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ const SizedBox(width: 10.0, height: 100.0), const Text( 'Flutter', style: TextStyle(fontSize: 40.0), ), const SizedBox(width: 15.0, height: 100.0), DefaultTextStyle( style: const TextStyle( fontSize: 35.0, ), child: AnimatedTextKit( repeatForever: true, isRepeatingAnimation: true, animatedTexts: [ RotateAnimatedText('AWESOME'), RotateAnimatedText('Text'), RotateAnimatedText('Animation'), ]), ), ], );&#125; 当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 打字机动画文字在正文中，我们将添加与上面相同的方法。但是在子属性中的更改，添加一个 _typer 小部件。 123456789101112131415161718192021222324Widget _typer()&#123; return SizedBox( width: 250.0, child: DefaultTextStyle( style: const TextStyle( fontSize: 30.0, fontFamily: 'popin', ), child: AnimatedTextKit( isRepeatingAnimation: true, animatedTexts: [ TyperAnimatedText('When you talk, you are only repeating' ,speed: Duration(milliseconds: 100)), TyperAnimatedText('something you know.But if you listen,' ,speed: Duration(milliseconds: 100)), TyperAnimatedText(' you may learn something new.' ,speed: Duration(milliseconds: 100)), TyperAnimatedText('– Dalai Lama' ,speed: Duration(milliseconds: 100)), ] ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 DefaultTextStyle()并添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。在内部，我们将添加四个带有速度持续时间的 TyperAnimatedText()。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 淡出动画文本在正文中，我们将添加与上面相同的方法。但是如果改变子属性，添加一个 _fade 小部件。 1234567891011121314151617181920212223242526Widget _fade()&#123; return SizedBox( child: DefaultTextStyle( style: const TextStyle( fontSize: 32.0, fontWeight: FontWeight.bold, ), child: Center( child: AnimatedTextKit( repeatForever: true, animatedTexts: [ FadeAnimatedText('THE HARDER!!', duration: Duration(seconds: 3),fadeOutBegin: 0.9,fadeInEnd: 0.7), FadeAnimatedText('YOU WORK!!', duration: Duration(seconds: 3),fadeOutBegin: 0.9,fadeInEnd: 0.7), FadeAnimatedText('THE LUCKIER!!!', duration: Duration(seconds: 3),fadeOutBegin: 0.9,fadeInEnd: 0.7), FadeAnimatedText('YOU GET!!!!', duration: Duration(seconds: 3),fadeOutBegin: 0.9,fadeInEnd: 0.7), ], ), ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 DefaultTextStyle()并添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。在内部，我们将添加 4 个 FadeAnimatedText() ，其中包括速度持续时间、 fadeOutBegin 和 fadeInEnd。比 fadeInEnd 要好。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 缩放动画文字在正文中，我们将添加与上面相同的方法。但是在子属性中的更改，添加一个 _scale 小部件。 123456789101112131415161718192021Widget _scale()&#123; return SizedBox( child: DefaultTextStyle( style: const TextStyle( fontSize: 50.0, fontFamily: 'SF', ), child: Center( child: AnimatedTextKit( repeatForever: true, animatedTexts: [ ScaleAnimatedText('Eat',scalingFactor: 0.2), ScaleAnimatedText('Code',scalingFactor: 0.2), ScaleAnimatedText('Sleep',scalingFactor: 0.2), ScaleAnimatedText('Repeat',scalingFactor: 0.2), ], ), ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 DefaultTextStyle()并添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。在内部，我们将添加四个带有 scalingFactor 的 ScaleAnimatedText()。scalingFactor 设置了动画文本的缩放因子。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 TextLiquidFill 动画在正文中，我们将添加与上面相同的方法。但是如果更改子属性，则添加一个 _textLiquidFillAnimation 小部件。 12345678910111213141516Widget _textLiquidFillAnimation()&#123; return SizedBox( child: Center( child: TextLiquidFill( text: 'Flutter Devs', waveDuration: Duration(seconds: 5), waveColor: Colors.blue, boxBackgroundColor: Colors.green, textStyle: TextStyle( fontSize: 50.0, fontWeight: FontWeight.bold, ), ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 TextLiquidFill()小部件。在这个小部件中，我们将添加文本、 waveDuration、 waveColor 和 boxBackgroundColor。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 动画文字在正文中，我们将添加与上面相同的方法。但是如果改变子属性，添加一个 _wave 小部件。 1234567891011121314151617Widget _wavy()&#123; return DefaultTextStyle( style: const TextStyle( fontSize: 25.0, ), child: AnimatedTextKit( animatedTexts: [ WavyAnimatedText(\"Flutter is Google's UI toolkit,\", speed: Duration(milliseconds: 200)), WavyAnimatedText('for building beautiful Apps', speed: Duration(milliseconds: 200)), ], isRepeatingAnimation: true, repeatForever: true, ), );&#125; 在这个小部件中，我们将返回 DefaultTextStyle()。在内部，我们将添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。在内部，我们将添加两个 WavyAnimatedText()和文本的速度持续时间。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 闪烁动画文字在正文中，我们将添加与上面相同的方法。但是在子属性中的更改，添加一个 _flicker 小部件。 123456789101112131415161718192021Widget _flicker()&#123; return SizedBox( width: 250.0, child: DefaultTextStyle( style: const TextStyle( fontSize: 30, ), child: AnimatedTextKit( repeatForever: true, animatedTexts: [ FlickerAnimatedText('FlutterDevs specializes in creating,', speed: Duration(milliseconds: 1000),entryEnd: 0.7), FlickerAnimatedText('cost-effective and', speed: Duration(milliseconds: 1000),entryEnd: 0.7), FlickerAnimatedText(\"efficient applications!\", speed: Duration(milliseconds: 1000),entryEnd: 0.7), ], ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 DefaultTextStyle()并添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。在内部，我们将添加四个具有 entryEnd 和速度的 FlickerAnimatedText()。entryEnd 被标记为文本闪烁输入间隔的结束。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 彩色动画文本在正文中，我们将添加与上面相同的方法。但是在子属性中的更改，添加一个 _colorize 的小部件。 123456789101112131415161718192021222324252627Widget _colorize()&#123; return SizedBox( child: Center( child: AnimatedTextKit( animatedTexts: [ ColorizeAnimatedText( 'Mobile Developer', textStyle: colorizeTextStyle, colors: colorizeColors, ), ColorizeAnimatedText( 'Software Testing', textStyle: colorizeTextStyle, colors: colorizeColors, ), ColorizeAnimatedText( 'Software Engineer', textStyle: colorizeTextStyle, colors: colorizeColors, ), ], isRepeatingAnimation: true, repeatForever: true, ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。在内部，我们将添加三个带有 textStyle 和颜色的 colorizeanmatedtext()。 1234567891011List&lt;MaterialColor&gt; colorizeColors = [ Colors.red, Colors.yellow, Colors.purple, Colors.blue,];static const colorizeTextStyle = TextStyle( fontSize: 40.0, fontFamily: 'SF',); 用户可以根据文本改变颜色。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频 打字机动画文字在正文中，我们将添加与上面相同的方法。但是如果更改子属性，则添加 _typeWriter 小部件。 123456789101112131415161718192021222324252627Widget _typeWriter()&#123; return SizedBox( child: DefaultTextStyle( style: const TextStyle( fontSize: 30.0, ), child: Padding( padding: const EdgeInsets.all(8.0), child: Center( child: AnimatedTextKit( repeatForever: true, animatedTexts: [ TypewriterAnimatedText('FlutterDevs specializes in creating cost-effective', curve: Curves.easeIn,speed: Duration(milliseconds: 80)), TypewriterAnimatedText('and efficient applications with our perfectly crafted,', curve: Curves.easeIn,speed: Duration(milliseconds: 80)), TypewriterAnimatedText('creative and leading-edge flutter app development solutions', curve: Curves.easeIn,speed: Duration(milliseconds: 80)), TypewriterAnimatedText('for customers all around the globe.', curve: Curves.easeIn,speed: Duration(milliseconds: 80)), ], ), ), ), ), );&#125; 在这个小部件中，我们将返回 SizedBox()。在内部，我们将添加 DefaultTextStyle()并添加 AnimatedTextKit()小部件。在这个小部件中，我们将添加 animatedtext。内部，我们将添加四个打字机动画文本()与曲线和速度。当我们运行应用程序，我们应该得到屏幕的输出像下面的屏幕视频。 所有代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import 'package:flutter/material.dart';import 'package:flutter_animation_text/colorize_animation_text.dart';import 'package:flutter_animation_text/fade_animation_text.dart';import 'package:flutter_animation_text/flicker_animation_text.dart';import 'package:flutter_animation_text/rotate_animation_text.dart';import 'package:flutter_animation_text/scale_animation_text.dart';import 'package:flutter_animation_text/text_liquid_fill_animation.dart';import 'package:flutter_animation_text/typer_animation_text.dart';import 'package:flutter_animation_text/typewriter_animated_text.dart';import 'package:flutter_animation_text/wavy_animation_text.dart';class HomePageScreen extends StatefulWidget &#123; @override _HomePageScreenState createState() =&gt; _HomePageScreenState();&#125;class _HomePageScreenState extends State&lt;HomePageScreen&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Color(0xffFFFFFF), appBar: AppBar( backgroundColor: Colors.black, title: Text('Flutter Animations Text Demo'), automaticallyImplyLeading: false, centerTitle: true, ), body: Center( child: Padding( padding: const EdgeInsets.all(16.0), child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.stretch, children: &lt;Widget&gt;[ // ignore: deprecated_member_use RaisedButton( child: Text('Rotate Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; RotateAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Typer Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; TyperAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Fade Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; FadeAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Scale Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; ScaleAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('TextLiquidFill Animation',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; TextLiquidFillAnimation())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Wavy Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; WavyAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Flicker Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; FlickerAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Colorize Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; ColorizeAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), SizedBox(height: 8,), // ignore: deprecated_member_use RaisedButton( child: Text('Typewriter Animation Text',style: TextStyle(color: Colors.black),), color: Colors.tealAccent, onPressed:() &#123; Navigator.of(context).push( MaterialPageRoute(builder:(context) =&gt; TypewriterAnimationText())); &#125;, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(20))), padding: EdgeInsets.all(13), ), ], ), ) ), //center ); &#125;&#125; 总结在这篇文章中，我已经简单地解释了文本动画的基本结构，您可以根据自己的选择修改这个代码。这是一个小的介绍文本动画用户交互从我这边，它的工作使用扑动。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 自动生成json实体类","date":"2021-07-13T16:00:00.000Z","path":"2021/07/14/translation/automatic-generate-json-serializable-in-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/automatic-generate-json-serializable-in-flutter-4c9d2d23ed88 代码参考 https://pub.dev/packages/json_serializable https://pub.dev/packages/json_annotation 正文Flutter 是一个可移植的 UI 工具包。换句话说，它是一个全面的应用软件开发工具包(SDK) ，包括小部件和工具。Flutter 是一个免费的开源工具，用于开发移动、桌面和 web 应用程序。Flutter 是一种跨平台的开发工具。这意味着用同样的代码，我们可以同时创建 ios 和 android 应用程序。这是在整个过程中节省时间和资源的最佳方式。 在本文中，我们将探索使用 json_serializable 包和 json_annotation，并了解如何使用它将我们的模型解析到 JSON 并通过序列化生成我们自己的代码。我们开始吧。 JSON SerializableJSON (JSON)是一种数据格式，它将对象编码成字符串。这种数据可以很容易地在服务器和浏览器之间转换，也可以在服务器和服务器之间转换。序列化是将对象转换为相同字符串的过程。为此，我们使用 json 序列化包，但是它可以根据 json 注释库提供的注释为您生成一个模型类。 Implementation每当我们需要建立模型和工厂的时候。因为模型不会总是改变，所以你不需要总是改变模型。因此，为了使用 JSON，我们必须添加下面解释的一些包。 这是提供给 Dart 构建系统的。当它在用 json_annotation 定义的类中找到带注释的成员时，就会生成代码 它定义了 JSON_serializable 用于创建 JSON 序列化、反序列化类型的代码的注释 我们使用 build_runner 包来生成使用 dart 代码的文件 现在让我们看看如何将所有这些包添加到 pubspec 中。 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 123456789101112131415---dependencies: flutter: sdk: flutter # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons: ^0.1.2 json_annotation: ^4.0.1dev_dependencies: flutter_test: sdk: flutter build_runner: ^2.0.5 json_serializable: ^4.1.3 第二步: Importing 123import 'package:json_annotation/json_annotation.dart';import 'package:build_runner/build_runner.dart';import 'package:json_serializable/json_serializable.dart'; 第三步: 启用 AndriodX 1234org.gradle.jvmargs=-Xmx1536Mandroid.enableR8=trueandroid.useAndroidX=trueandroid.enableJetifier=true 如何实现 dart 文件中的代码 你需要分别在你的代码中实现它 首先，我们将创建一个我们命名为 user.dart 的模型类。 现在我们将看到 Dart 如何使用 Dart: convert 库本机支持手动序列化。用户 dart 文件准备好了，我们将有一个数据 JSON 对象的列表，其中每个对象将有一个用户名，姓氏，和它的地址，我们已经在字符串类型的变量中定义了，你将看到在数据类中我们有两个我们需要创建函数，分别称为 fromJson 和 toJson，它们将 JSON 转换为我们的用户类。 123456789101112131415import 'package:json_annotation/json_annotation.dart';part 'user.g.dart';@JsonSerializable()class User &#123; String name, lastName, add; bool subscription; User(&#123;this.name,this.lastName,this.add,this.subscription,&#125;); factory User.fromJson(Map&lt;String,dynamic&gt; data) =&gt; _$UserFromJson(data); Map&lt;String,dynamic&gt; toJson() =&gt; _$UserToJson(this);&#125; 现在，当我们运行 build_runner 命令时，jsonserializer 将生成这个 `$UserFromJson(json)。我们将从中获得user.g.dart` 文件。 要运行 build_runner 命令，我们将在 Android Studio 中打开一个终端，并输入以下行。 1flutter pub run build_runner build 当我们在构建运行程序中运行这个命令时，会出现一些行，过一段时间后它就成功生成了。 1234INFO] Generating build script...[INFO] Generating build script completed, took 301ms[INFO] Initializing inputs[INFO] Reading cached asset graph...[INFO] Reading cached asset graph completed, took 305ms[INFO] Checking for updates since last build...[INFO] Checking for updates since last build completed, took 1.5s[INFO] Running build...[INFO] Running build completed, took 4.7s[INFO] Caching finalizeddependency graph...[INFO] Caching finalized dependency graph completed, took 44ms[INFO] Succeeded after 4.8s with 0 outputs (1 actions) 在 build_runner 进程完成之后，我们在一个包含序列化代码的用户文件下面添加一个名为 user.g.dart 的新文件。当我们制作一个新的模型，然后我们流过这个过程。 1234567891011121314151617181920212223// GENERATED CODE - DO NOT MODIFY BY HANDpart of 'user.dart';// **************************************************************************// JsonSerializableGenerator// **************************************************************************User _$UserFromJson(Map&lt;String, dynamic&gt; json) &#123; return User( name: json['name'] as String, lastName: json['lastName'] as String, add: json['add'] as String, subscription: json['subscription'] as bool, );&#125;Map&lt;String, dynamic&gt; _$UserToJson(User instance) =&gt; &lt;String, dynamic&gt;&#123; 'name': instance.name, 'lastName': instance.lastName, 'add': instance.add, 'subscription': instance.subscription, &#125;; 在此之后，我们创建了一个类，其中显示了一个列表项，我们已经为该列表项定义了一个未来的生成器列表视图生成器，其中我们已经在文本小部件中定义了用户列表的项。 12345678910111213141516171819202122232425262728293031323334353637FutureBuilder&lt;List&lt;User&gt;&gt;( future: getData(), builder: (context, data) &#123; if (data.connectionState != ConnectionState.waiting &amp;&amp; data.hasData) &#123; var userList = data.data; return ListView.builder( itemCount: userList.length, itemBuilder: (context, index) &#123; var userData = userList[index]; return Container( height: 100, margin: EdgeInsets.only(top: 30, left: 20, right: 20), decoration: BoxDecoration( color: Colors.grey.shade200, borderRadius: BorderRadius.all(Radius.circular(10)), ), padding: EdgeInsets.all(15), child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceAround, children: [ Text( 'First Name: ' + userData.name, style: TextStyle( fontWeight: FontWeight.w600,), ), ], ), ); &#125;); &#125; else &#123; return Center( child: CircularProgressIndicator(), ); &#125; &#125;) 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 Code File123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import 'dart:convert';import 'package:flutter/material.dart';import 'package:flutter_json_serilization_exm/main.dart';import 'package:flutter_json_serilization_exm/model/user.dart';class JsonSerilization extends StatefulWidget &#123; @override _JsonSerilizationState createState() =&gt; _JsonSerilizationState();&#125;class _JsonSerilizationState extends State&lt;JsonSerilization&gt; &#123; Future&lt;List&lt;User&gt;&gt; getData() async &#123; return await Future.delayed(Duration(seconds: 2), () &#123; List&lt;dynamic&gt; data = jsonDecode(JSON); List&lt;User&gt; users = data.map((data) =&gt; User.fromJson(data)).toList(); return users; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"Json Serialization Demo\"), ), body: Container( child: FutureBuilder&lt;List&lt;User&gt;&gt;( future: getData(), builder: (context, data) &#123; if (data.connectionState != ConnectionState.waiting &amp;&amp; data.hasData) &#123; var userList = data.data; return ListView.builder( itemCount: userList.length, itemBuilder: (context, index) &#123; var userData = userList[index]; return Container( height: 100, margin: EdgeInsets.only(top: 30, left: 20, right: 20), decoration: BoxDecoration( color: Colors.grey.shade200, borderRadius: BorderRadius.all(Radius.circular(10)), ), padding: EdgeInsets.all(15), child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.spaceAround, children: [ Text( 'First Name: ' + userData.name, style: TextStyle( fontWeight: FontWeight.w600, fontSize: 15), ), Text( 'Last Name: ' + userData.lastName, style: TextStyle( fontWeight: FontWeight.w600, fontSize: 15), ), Text( 'Add: ' + userData.add, style: TextStyle( fontWeight: FontWeight.w600, fontSize: 15), ), ], ), ); &#125;); &#125; else &#123; return Center( child: CircularProgressIndicator(), ); &#125; &#125;), ), ); &#125;&#125; Conclusion在这篇文章中，我解释了自动生成 JSON 系列化 Flutter，你可以根据自己的修改和实验，这个小介绍是从自动生成 JSON 系列化 Flutter 演示从我们这边。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 自定义聊天气泡","date":"2021-07-12T16:00:00.000Z","path":"2021/07/13/translation/custom-chat-bubble-in-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/custom-chat-bubble-in-flutter-6aa7d24fc683 代码https://github.com/flutter-devs/flutter_custom_chat_bubble 参考 https://pub.flutter-io.cn/packages/get#reactive-state-manager https://dart.dev/guides/language/extension-methods 正文 对话聊天应用程序显示聊天中的消息会在强烈的阴影背景下上升。现代聊天应用程序显示的聊天气泡的斜率取决于气泡在屏幕上的位置。在 flutter 应用中，有时需要使用聊天气泡。然而，将一个库用于一个特别无关紧要的任务并不好。 在这个博客，我们将探索自定义聊天气泡 flutter。我们将看到如何实现一个自定义聊天泡泡的演示程序，以及如何使一个自定义聊天泡泡最简单的不使用任何第三方库在您的 flutter 应用程序。 配置 assets 第一步: 添加 assets 将 assets 添加到 pubspec.yaml 文件。 12assets: - assets/images/ 第二步: 在应用程序的根目录中运行 flutter packages get 。 如何实现 dart 文件中的代码:你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 custom_shape.dart 的新 dart 文件。 首先，创建自定义形状自定义 CustomPainter 类。这将用于在聊天气泡结束时绘制自定义形状。用户可以在自定义形状中添加任何颜色。 1234567891011121314151617181920212223import 'package:flutter/material.dart';class CustomShape extends CustomPainter &#123; final Color bgColor; CustomShape(this.bgColor); @override void paint(Canvas canvas, Size size) &#123; var paint = Paint()..color = bgColor; var path = Path(); path.lineTo(-5, 0); path.lineTo(0, 10); path.lineTo(5, 0); canvas.drawPath(path, paint); &#125; @override bool shouldRepaint(CustomPainter oldDelegate) &#123; return false; &#125;&#125; 在 lib 文件夹中创建一个名为 send_message_screen.dart 的新 dart 文件。 首先，我们将创建一个构造器的最终字符串消息。 12345final String message;const SentMessageScreen(&#123; Key key, @required this.message,&#125;) : super(key: key); 在构建方法中，我们将返回 Padding()。在内部，我们将添加 Row() 小部件。在这个小部件中，我们将添加 mainAxisAlignment 并添加 messageTextGroup。我们将定义下面的代码。 12345678910return Padding( padding: EdgeInsets.only(right: 18.0, left: 50, top: 15, bottom: 5), child: Row( mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ SizedBox(height: 30), messageTextGroup, ], ),); 我们将深入定义 messageTextGroup: 我们将创建一个最终的 messageTextGroup 等于 Flexible ()小部件。在这个小部件中，我们将添加 Row ()小部件。在内部，添加主轴对齐是结束，并启动了跨轴对齐。在儿童内部，我们将添加装饰框的 Conatiner 和添加颜色，边框半径。它的子属性，我们将添加一个可变消息文本。我们将添加 CustomPaint () ，我们将使用上面的画家类是带颜色的 CustomShape。 12345678910111213141516171819202122232425final messageTextGroup = Flexible( child: Row( mainAxisAlignment: MainAxisAlignment.end, crossAxisAlignment: CrossAxisAlignment.start, children: [ Flexible( child: Container( padding: EdgeInsets.all(14), decoration: BoxDecoration( color: Colors.cyan[900], borderRadius: BorderRadius.only( topLeft: Radius.circular(18), bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18), ), ), child: Text( message, style: TextStyle(color: Colors.white, fontSize: 14), ), ), ), CustomPaint(painter: CustomShape(Colors.cyan[900])), ], )); 在 lib 文件夹中创建一个名为 received_message_screen.dart 的新 dart 文件。 类似地，我们现在可以创建一个接收到的消息屏幕。我们只需要翻转定制的形状，并把它放在开始，而不是结束。我们将使用转换小部件翻转自定义形状小部件。在转换小部件中，我们将添加对齐为中心，转换为 Matrix4.rotationY(math. pi)。 12345678910111213141516171819202122232425262728293031final messageTextGroup = Flexible( child: Row( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, children: [ Transform( alignment: Alignment.center, transform: Matrix4.rotationY(math.pi), child: CustomPaint( painter: CustomShape(Colors.grey[300]), ), ), Flexible( child: Container( padding: EdgeInsets.all(14), decoration: BoxDecoration( color: Colors.grey[300], borderRadius: BorderRadius.only( topRight: Radius.circular(18), bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18), ), ), child: Text( message, style: TextStyle(color: Colors.black, fontSize: 14), ), ), ), ], )); 在 lib 文件夹中创建一个名为 home_page.dart 的新 dart 文件。 在正文中，我们将添加一个 Container ()小部件。在里面，添加装饰框和添加图像。它是子属性，我们可以在 ListView ()中同时添加发送和接收消息屏幕。 12345678910111213141516Container( decoration: BoxDecoration( image: DecorationImage( image: AssetImage(\"assets/bg_chat.jpg\"), fit: BoxFit.cover)), child: ListView( children: [ SentMessageScreen(message: \"Hello\"), ReceivedMessageScreen(message: \"Hi, how are you\"), SentMessageScreen(message: \"I am great how are you doing\"), ReceivedMessageScreen(message: \"I am also fine\"), SentMessageScreen(message: \"Can we meet tomorrow?\"), ReceivedMessageScreen(message: \"Yes, of course we will meet tomorrow\"), ], ),), 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940import 'package:flutter/material.dart';import 'package:flutter_custom_chat_bubble/received_message_screen.dart';import 'package:flutter_custom_chat_bubble/send_messsage_screen.dart';class HomePage extends StatefulWidget &#123; HomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( backgroundColor: Colors.cyan[900], automaticallyImplyLeading: false, title: Text(widget.title), ), body: Container( decoration: BoxDecoration( image: DecorationImage( image: AssetImage(\"assets/bg_chat.jpg\"), fit: BoxFit.cover)), child: ListView( children: [ SentMessageScreen(message: \"Hello\"), ReceivedMessageScreen(message: \"Hi, how are you\"), SentMessageScreen(message: \"I am great how are you doing\"), ReceivedMessageScreen(message: \"I am also fine\"), SentMessageScreen(message: \"Can we meet tomorrow?\"), ReceivedMessageScreen(message: \"Yes, of course we will meet tomorrow\"), ], ), ), ); &#125;&#125; Conclusion:在文章中，我已经解释了自定义聊天气泡的基本结构，您可以根据自己的选择修改这个代码。这是一个小的介绍自定义聊天泡泡用户交互从我这边，它的工作使用 flutter。 我希望这个博客将提供您尝试在您的 flutter 项目自定义聊天气泡充分的信息。我们将为工作的演示程序自定义聊天气泡使用任何第三方库在您的 flutter 应用程序。所以请尝试一下。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 如何处理401 未授权的 Dio 拦截器","date":"2021-07-08T16:00:00.000Z","path":"2021/07/09/translation/how-to-handle-401-unauthorised-with-dio-interceptor-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/@wmnkrishanmadushanka/how-to-handle-401-unauthorised-with-dio-interceptor-flutter-60398a914406 代码参考 https://pub.dev/packages/dio/versions/4.0.0 https://pub.dev/packages/flutter_secure_storage https://pub.dev/packages/shared_preferences 正文在本文中，我将解释如何使用 flutter dio (4.0.0)进行网络调用，以及如何在您的 flutter 应用程序中使用刷新令牌和访问令牌来处理授权时处理 401。 在阅读这篇文章之前，我希望你们对颤抖移动应用程序开发有一个基本的了解。 Basic Authentication flow with refresh and access tokens 正如您在上面的图中所看到的，很明显，在身份验证流中使用刷新和访问令牌时的流程是什么。登录后，您将获得两个称为刷新和访问的标记。此访问令牌快速过期(刷新令牌也过期，但是它将比访问令牌花费更多的时间)。当您使用过期的访问令牌发出请求时，响应中会出现状态码 401(未经授权)。在这种情况下，您必须从服务器请求一个新的令牌，并使用有效的访问令牌再次发出上一个请求。如果刷新令牌也已过期，您必须指示用户登录页面并强制再次登录。 Dio class12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class DioUtil &#123; static Dio _instance;//method for getting dio instance Dio getInstance() &#123; if (_instance == null) &#123; _instance = createDioInstance(); &#125; return _instance; &#125; Dio createDioInstance() &#123; var dio = Dio();// adding interceptor dio.interceptors.clear(); dio.interceptors.add(InterceptorsWrapper(onRequest: (options, handler) &#123; return handler.next(options); &#125;, onResponse: (response, handler) &#123; if (response != null) &#123; return handler.next(response); &#125; else &#123; return null; &#125; &#125;, onError: (DioError e, handler) async &#123; if (e.response != null) &#123; if (e.response.statusCode == 401) &#123;//catch the 401 here dio.interceptors.requestLock.lock(); dio.interceptors.responseLock.lock(); RequestOptions requestOptions = e.requestOptions; await refreshToken(); Repository repository = Repository(); var accessToken = await repository.readData(\"accessToken\"); final opts = new Options(method: requestOptions.method); dio.options.headers[\"Authorization\"] = \"Bearer \" + accessToken; dio.options.headers[\"Accept\"] = \"*/*\"; dio.interceptors.requestLock.unlock(); dio.interceptors.responseLock.unlock(); final response = await dio.request(requestOptions.path, options: opts, cancelToken: requestOptions.cancelToken, onReceiveProgress: requestOptions.onReceiveProgress, data: requestOptions.data, queryParameters: requestOptions.queryParameters); if (response != null) &#123; handler.resolve(response); &#125; else &#123; return null; &#125; &#125; else &#123; handler.next(e); &#125; &#125; &#125;)); return dio; &#125; static refreshToken() async &#123; Response response; Repository repository = Repository(); var dio = Dio(); final Uri apiUrl = Uri.parse(BASE_PATH + \"auth/reIssueAccessToken\"); var refreshToken = await repository.readData(\"refreshToken\"); dio.options.headers[\"Authorization\"] = \"Bearer \" + refreshToken; try &#123; response = await dio.postUri(apiUrl); if (response.statusCode == 200) &#123; LoginResponse loginResponse = LoginResponse.fromJson(jsonDecode(response.toString())); repository.addValue('accessToken', loginResponse.data.accessToken); repository.addValue('refreshToken', loginResponse.data.refreshToken); &#125; else &#123; print(response.toString()); //TODO: logout &#125; &#125; catch (e) &#123; print(e.toString()); //TODO: logout &#125; &#125;&#125; 以上是完整的课程，我将解释其中最重要的部分。 主要是，正如您在 createDioInstance 方法中看到的，您必须添加一个拦截器来捕获 401。当 401 发生在 error: (DioError e，handler) async {}被调用时。所以你的内心 Check the error code(401), 检查错误代码(401) , Get new access token 获取新的访问令牌 1await refreshToken(); 上面的代码将调用 refreshToken 方法并在存储库中存储新的刷新和访问令牌。(对于存储库，您可以使用 secure storage or shared preferences) 复制前一个请求并设置新的访问令牌 123456RequestOptions requestOptions = e.requestOptions;Repository repository = Repository();var accessToken = await repository.readData(\"accessToken\");final opts = new Options(method: requestOptions.method);dio.options.headers[\"Authorization\"] = \"Bearer \" + accessToken;dio.options.headers[\"Accept\"] = \"*/*\"; Make the previous call again 123456final response = await dio.request(requestOptions.path, options: opts, cancelToken: requestOptions.cancelToken, onReceiveProgress: requestOptions.onReceiveProgress, data: requestOptions.data, queryParameters: requestOptions.queryParameters); 一旦收到回复，就 call 1handler.resolve(response); 然后响应将被发送到您调用 api 的位置，如下所示。 123456var dio = DioUtil().getInstance();final String apiUrl = (BASE_PATH + \"payments/addNewPayment/\");var accessToken = await repository.readData(\"accessToken\");dio.options.headers[\"Authorization\"] = \"Bearer \" + accessToken;dio.options.headers[\"Accept\"] = \"*/*\";//response will be assigned to response variableresponse = await dio.post(apiUrl, data: event.paymentRequest.toJson()); Thats all. happy coding :) © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"转换 JSON API 用 Chopper 和 JsonSerializable","date":"2021-07-07T16:00:00.000Z","path":"2021/07/08/translation/converting-json-api-response-to-dart-objects-with-chopper-and-jsonserializable/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/teamkraken/converting-json-api-response-to-dart-objects-with-chopper-and-jsonserializable-8ec98b762ac1 代码https://github.com/ErkinKurt/chopper_json_serializable 参考 https://hadrien-lejard.gitbook.io/chopper/ https://github.com/infinum/Japx https://jsonapi.org/ https://github.com/dart-lang/build 正文不过，JSON 响应格式因服务而异; 有一些共享的约定，比如 JSON: API，HAL… 今天，我将尝试展示如何从头开始，将 JSON: API 响应转换为 Flutter 项目中的 Dart 对象。 如果你想跟随源代码，这里是: Chopper _ json _ serializable https://github.com/ErkinKurt/chopper_json_serializable 1. 创建项目并添加依赖项将要使用的软件包: Chopper:使用 source gen 和 Retrofit 的 Dart 和 Flutter 的 Http 客户端生成器 Json Serializable:通过使用它，将自动生成实体的 JSON 转换 Japx:解析器，它将复杂的[ JSON: API ][1]结构变为简单的 JSON，反之亦然 非常感谢这些令人敬畏的包裹！ 由于 JsonSerializable 和 Chopper 使用 meta 编程，他们需要 BuildRunner 来处理代码生成。下面是要使用的 pubspec.yaml 文件: 2. 实现 Mock Http Client 以获得 JSON: API 格式的响应响应模型在 assets 文件夹中提供，因为我们希望使用 mock http 客户机，并且不依赖于任何远程源。响应模型取自 JAPX 资产。 如果你想使用 chopper 与常规的 http 客户端只是忽略这一部分，并沿着以下部分..。 3. 创建模型并使用 JsonSerializable尽管为了简单起见，我们有两个实体 Article 和 People，但是它们将从 Entity 类继承，以演示如何将 JsonSerializable 与继承一起使用。因为每个实体在 JSON: API 中都有一个 type 和 id 值，所以我们创建了一个具有 type 和 id 的基类。 123456abstract class Entity &#123; final String type; final String id; Entity(this.type, this.id);&#125; 让我们用 JsonSerializable 实现两个模型。我们需要编写 part’&lt; model-name &gt; 。在一天结束的时候，json 和 FromJson 构造函数将由这个目录中构建的 runner 生成。 我们正在将 fromJsonFactory 定义为在 JsonTypeConvertor 中使用，稍后我们将看到它的使用。 在完成我们的实现之后，我们需要在项目的根目录中运行 flutter pub run build runner build，这样 build runner 就可以执行它的魔术了。在成功的执行之后，我们看到。G 文件生成，没有错误。 4. 创建 Chopper 服务让我们创建网络层与 Chopper 服务。Chopper Services 使用自动生成来创建底层的 http 客户端实现，因此我们不需要担心 http 客户端请求。 我们提供了一个静态创建方法，将服务注入到 ChopperClients 中。除此之外，我们还有通过 http 客户端获取单个实体的 getArticle 和 getPerson 方法。 正如你所看到的，我们有一些红灯亮着。这是因为 chopper 在 build _ runner 的帮助下使用代码生成。(build _ runner the underlying hero). 让我们像之前一样运行 flutter pub run build _ runner build 命令，如果执行成功，我们不会看到任何错误。请看一下生成的代码，看看 chopper 是如何处理基础 http 客户端请求的。 5. 实现 Chopper Client现在我们需要实现 Chopper 客户端使用我们创建的 Chopper 服务。Chopper Client 提供服务属性，设置多种服务。对于客户端使用，有两个选项，要么创建客户端为单例，并传递所有服务，要么在任何需要的时候创建客户端。 对于这个示例，让我们创建一个 chopper 客户机实例，并将其传递给 widget 树。然而，我们可以使用 getIt 或者 provider 作为依赖注入，为了简单起见，我们将其作为支柱。 下面是一个 ChopperClientBuilder，它为我们的 ChopperClientBuilder 客户端提供了构建方法。 6. 使用用户界面中的 JAPX 解码器使用 Chopper 服务我们有一个带 chopper client 作为 prop 的有状态小部件，我们将实现两个方法 getArticle 和 getPeople。在这一部分中，JAPX 扮演了重要的角色。因为我们的 JSON 响应具有 JSON: API 响应格式，所以我们需要平滑复杂的响应。 然而，上面的例子可以很好地工作; 我们需要进行显式转换: json.decode to get mapped json object Japx.decode to flatten the map. Instantiate dart object with our model’s fromJsonFactory methods. 这种方法有两个问题: 显式转换将导致代码重复 服务方法 Response return type. 让我们看看如何处理这些问题..。 7. 为响应类型规范实现 JsonConvertor以某种方式，我们需要操作 Chopper Responses 来返回我们之前定义的模型类型。由于称为转换器的特殊拦截器，我们可以处理响应、请求和错误的转换。所有我们需要做的是创建转换器，并注入到 Chopper 客户端，我们使用。 让我们为 Chopper Client 创建 jsonserializableeconverter 类。为了做到这一点，我们需要从 Chopper 的 JsonConverter 类扩展我们的类，并重写 convertResponse、 convertRequest 和 convertError 方法。 现在我们在 convertResponse 方法中进行转换，这也解决了代码重复问题，因为每次成功响应都会调用这个方法。但是，仍然有一个类型转换问题需要解决。 1jsonRes.copyWith&lt;ResultType&gt;(body: JsonTypeParser.decode&lt;Item&gt;(flatJson[\"data\"])) 这是解析 Dart 模型响应的关键语句: 实际上是我们希望服务方法使用的返回类型 ResultType 是 List or 或 BuiltList 会是我们的回归类型。为了在服务方法中定义返回类型，我们需要添加我们期望的模型类型 在此更改之后，无论何时触发 convertResponse，ResultType 都将是 People 或 Article。 然而，我们仍然需要调用我们的模型的 fromJsonFactory 方法将响应对象转换为 Dart 对象。为了做到这一点，我们创建 JsonTypeParser 类，它将保存 Dart 对象的转换逻辑 JsonTypeParser 有 Map &lt; Type，JsonFactory &gt; 类型的 factories 属性，其中包含来自 JsonFactory 方法的模型和模型。每当我们有一个新的模型，我们需要添加它的类型和工厂到工厂，以便它可以通过 _ decodeMap 方法解析。JsonSerializableConverter 执行 decode &lt; t &gt; 方法，t 为 ResultType 或 Item，并调用匹配类型的 factory get 来实例化我们的模型。 让我们跟随这个变化和修改用户界面部分，我们消费斩波服务..。 让我们把 jsonserializableeconverter 插入到我们的 chopper 客户端: 根据这些变化，现在我们可以直接使用响应体，具有类型安全性。 总结我知道这有很多东西需要消化，但是，还有很多东西需要讨论，比如 JsonSerializable 和 Chopper 的响应错误的自定义类型转换器。如果我写一篇中等程度的文章，我会把这个话题连接起来。 总而言之，我想要展示的是各种响应模型可以通过斩波和 json 序列化解决，而不会失去类型安全的清洁方式。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"用抽象工厂方法构建 Flutter 主题","date":"2021-07-06T16:00:00.000Z","path":"2021/07/07/translation/flutter-build-theme-with-abstract-factory-method/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://vbacik-10.medium.com/flutter-build-theme-with-abstract-factory-method-e07df8f730e2 代码https://github.com/VB10/flutter-abstract-theme-manager 参考 https://zeplin.io 正文最多的应用程序至少创建了一个主题。也许这对于第一个版本来说已经足够了，但是如果这个项目继续增长呢？让我们来看看怎么做。 我们知道项目设计的主题有多重要，所以我们将为项目创建一个主题管理器。让我们创建一个主题管理器以及这个购物页面。 设计稿https://adobe.ly/xdfreshfooduikit 首先，它需要一个页面设计，如也这个页面可以连接到服务。(我为这个示例页面创建了这个端点) Background 背景 App bar - 应用程式栏 Search Bar - 搜寻栏— Search Icon ー搜寻图示— Search Text ー搜寻文字— Microphone Icon ー麦克风图标 ListView— Product Card ー产品卡 TabBar— TabBar Icons ー TabBar 图标集 因此，我们需要一个调色板使用这个项目。如果你的设计工具包有一个调色板，你可以在设计工具包中得到所有的颜色。 项目必须在需要新小部件时使用这个调色板。实际上，由于有了主题经理，项目会更容易成长。最后，我们准备好了 Hacking 时间，因此我们将同时使用工厂方法模式和页面原子设计。 Hacking Time首先，我更喜欢先写核心特性，这就是为什么我们不会在代码完成时加倍工作的原因: 使用不同颜色和样式的 ITheme 抽象类 用于从一个点管理不同主题的 ThemeFactory 类 工厂设计是创新模式之一。这个模式提供了高级对象，因为客户机什么都不知道。现在，该模式创建了一个自定义对象，以便项目可以使用这个方案。 现在我们知道了这个结构需要什么，因为我们可以编写一个同时包含文本和颜色的界面。这个接口提供了一个中心视点，因此项目需要。让我们写下这些要点。 文本主题界面每个项目都需要这一点，因为大多数用法都指向项目的文本指南。所以我们创建基本样式指南后，非常容易从视图使用。有时我们需要自定义文本样式并不意味着你不使用当前的样式。我们可以使用 copyWith 函数，这样就可以像 headline5 一样使用视图，也可以添加自定义属性，如文本颜色。 12345678910111213141516abstract class ITextTheme &#123; final Color? primaryColor; late final TextTheme data; TextStyle? headline1; TextStyle? headline3; TextStyle? headline4; TextStyle? headline5; TextStyle? headline6; TextStyle? subtitle1; TextStyle? subtitle2; TextStyle? bodyText1; TextStyle? bodyText2; String? fontFamily; ITextTheme(this.primaryColor);&#125; 如果您的项目设计有一个工具包，您可以使用 zeplin 工具。这个工具在样式指南选项卡中获取所有的文本样式。 https://zeplin.io/ 颜色主题界面指向项目是非常重要的，因为你知道颜色无处不在。所以我们如何管理更多的项目很容易控制。每个项目都有一个特定的颜色模式，您必须在代码中使用这个模式。如果你不使用模式和项目有一个静态的颜色代码，你不会添加多主题选项，另外你不能管理颜色问题。 1234567891011abstract class IColors &#123; _AppColors get colors; Color? scaffoldBackgroundColor; Color? appBarColor; Color? tabBarColor; Color? tabbarSelectedColor; Color? tabbarNormalColor; Brightness? brightness; ColorScheme? colorScheme;&#125; 我说像 paragraph 关于 zeplin。再次你可以使用这个和你能够所有的颜色属性。 Abstract Factory Manager为多界面创建的管理器。此管理器将为项目创建 ThemeData 实例。由于这个接口，您可以创建一个新的主题实例。这个新的主题只需要一个配色方案等。 1234abstract class ITheme &#123; ITextTheme get textTheme; IColors get colors;&#125; 是的，它看起来很简单，对任何项目都很有用。最后，我们准备使用核心主题绘制操作，因此项目可以声明这个结构的自定义主题。也许，这些主题接口可以改进得更高级。现在对于这个项目来说已经足够了。 最后需要工厂创建者和我们使用这个项目的主题管理器 123456789101112abstract class ThemeManager &#123; static ThemeData craeteTheme(ITheme theme) =&gt; ThemeData( fontFamily: theme.textTheme.fontFamily, textTheme: theme.textTheme.data, cardColor: theme.colors.colorScheme?.onSecondary, floatingActionButtonTheme: FloatingActionButtonThemeData( foregroundColor: theme.colors.colors.white, backgroundColor: theme.colors.colors.green), appBarTheme: AppBarTheme(backgroundColor: theme.colors.appBarColor), scaffoldBackgroundColor: theme.colors.scaffoldBackgroundColor, colorScheme: theme.colors.colorScheme);&#125; 我计划只有具体的领域，因为它的项目只有两个页面，因为你知道这个样本。你必须创建文本样式和配色方案区域的其他区域。让我们用这个结构创建自定义主题，我们将展示这种使用优势。 Ligh Theme on Project实际上，我们有一个结构和项目，如何创建一个轻的主题。 1234567891011class AppThemeLight extends ITheme &#123; @override late final ITextTheme textTheme; AppThemeLight() &#123; textTheme = TextThemeLight(colors.colors.mediumGrey); &#125; @override IColors get colors =&gt; LightColors();&#125; 当然，暗主题创建这样，因此只是改变风格的指导方针和项目可以直接使用。您可以在这里访问黑暗主题代码。 TextTheme Light 需要绘制文本默认颜色的基本颜色，而浅色已经从 zeplin 样式创建。 12345678910111213141516171819202122232425262728293031323334353637383940414243class TextThemeLight implements ITextTheme &#123; @override late final TextTheme data; @override TextStyle? bodyText1; @override TextStyle? bodyText2; @override TextStyle? headline1; @override TextStyle? headline3; @override TextStyle? headline4; @override TextStyle? headline5; @override TextStyle? headline6; @override TextStyle? subtitle1; @override TextStyle? subtitle2; final Color? primaryColor; TextThemeLight(this.primaryColor) &#123; data = TextTheme( headline6: TextStyle(fontSize: 20, fontWeight: FontWeight.normal), subtitle1: TextStyle(fontSize: 16.0), ).apply(bodyColor: primaryColor); fontFamily = GoogleFonts.arvo().fontFamily; &#125; @override String? fontFamily;&#125; 好的，如果我们想看浅色的主题实例，它显示了这一点。 1234567891011121314151617181920212223242526272829303132333435class LightColors implements IColors &#123; @override final _AppColors colors = _AppColors(); @override ColorScheme? colorScheme; @override Color? appBarColor; @override Color? scaffoldBackgroundColor; @override Color? tabBarColor; @override Color? tabbarNormalColor; @override Color? tabbarSelectedColor; LightColors() &#123; appBarColor = colors.white; scaffoldBackgroundColor = colors.white; tabBarColor = colors.green; tabbarNormalColor = colors.lighterGrey; tabbarSelectedColor = colors.darkerGrey; colorScheme = ColorScheme.light() .copyWith(onPrimary: colors.green, onSecondary: colors.white); brightness = Brightness.light; &#125; @override Brightness? brightness;&#125; 有时需要准备风格，因为没有足够的风格知识。这时你可以为你的项目使用一个配色方案实例，这样你就可以得到材质配色方案，因此可以添加你自定义的业务层。 而 Light 主题就是准备使用的。该项目只需要主题工厂方法，您可以编写这个类实例。对于项目颜色的所有内容，这都是可以接受的。 12345678910class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: '@VB10', theme: ThemeManager.craeteTheme(AppThemeLight()), home: SampleView(), ); &#125;&#125; 是的，我们可以开始在搜索结果屏幕上绘图。特别是不要忘记这个方法，让我们看看如何为这个项目创建一个主题实例。 1234567891011121314151617abstract class ThemeManager &#123; static ThemeData craeteTheme(ITheme theme) =&gt; ThemeData( fontFamily: theme.textTheme.fontFamily, textTheme: theme.textTheme.data, cardColor: theme.colors.colorScheme?.onSecondary, tabBarTheme: TabBarTheme( indicator: BoxDecoration(), labelColor: theme.colors.tabbarSelectedColor, unselectedLabelColor: theme.colors.tabbarNormalColor, ), floatingActionButtonTheme: FloatingActionButtonThemeData( foregroundColor: theme.colors.colors.white, backgroundColor: theme.colors.colors.green), appBarTheme: AppBarTheme(backgroundColor: theme.colors.appBarColor), scaffoldBackgroundColor: theme.colors.scaffoldBackgroundColor, colorScheme: theme.colors.colorScheme);&#125; 现在项目直接依赖于所有的主题实例，因为我们只是改变主题值后，这个项目去一个新的配色方案，另外项目从来不需要任何代码的设计时间。这一点意味着你的项目设计已经完成了所有的工作 Feature Page我们有一个主题实例，所以只需调用这个实例，一切就绪。首先，绘制页面树非常重要，更好地理解。 现在编码非常简单，因为我们知道如何绘制这个。特别是您对编码时间非常注意，因此可以在页面设计中始终使用主题实例。该项目有一个主题设计，因为可以直接调用这个变量。例如，任何页面可以需要背景色，所以我们不需要一遍又一遍地写，因为我们有使用这种情况的主题实例。 是的，我们准备开发另外的主题管理器和小部件树结构。首先，让我们在编码中创建一个 tab 视图结构。 12345678910111213141516171819final List&lt;MapEntry&lt;Widget, IconData&gt;&gt; _pages = [ MapEntry(SampleView(), Icons.search), MapEntry(Container(), Icons.search), MapEntry(Container(), Icons.search), MapEntry(Container(), Icons.search),];@overrideWidget build(BuildContext context) &#123; return DefaultTabController( length: _pages.length, child: Scaffold( floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, floatingActionButton: floatingActionButton(context), bottomNavigationBar: _bottomAppBar(), body: TabBarView(children: _pages.map((e) =&gt; e.key).toList()), ));&#125; 实际上，我们看到了 fab 按钮，我们需要一个自定义颜色，因为这个颜色是为蓝色创建的，但是我们在主题中添加了这个自定义代码，只写了一个浮动的操作按钮。此按钮从上下文中读取主题实例中的 own 属性。 我说你不需要额外的代码，直接调用这个小部件。 123456FloatingActionButton floatingActionButton(BuildContext context) &#123; return FloatingActionButton( child: Icon(Icons.add), onPressed: () &#123;&#125;, );&#125; 之后，让我们显示搜索结果页面设计。我们谈到了这篇页面设计对文章的打击。这对颤振计划非常重要。你需要一直考虑这个树型结构。你可以用这个小部件树的思想做一个很棒的页面。 123456789101112131415@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: buildAppBar(context), body: Padding( padding: EdgeInsets.only(top: MediaQuery.of(context).size.width * 0.08), child: Column( children: [ textFieldSearchCard(context), Expanded(child: buildGridViewBody()), ], ), ), );&#125; 这说明了很多问题。让我们来看一些小部件，以了解如何使用主题。我们的设计有一个自定义搜索栏，带有搜索图标和麦克风按钮。 1234567891011121314Widget textFieldSearch(BuildContext context) &#123; return TextField( decoration: InputDecoration( border: InputBorder.none, prefixIcon: Icon(Icons.search_sharp, color: Theme.of(context).colorScheme.onPrimary.withOpacity(0.5)), suffixIconConstraints: BoxConstraints(maxHeight: 30), suffixIcon: FloatingActionButton( onPressed: () &#123;&#125;, mini: true, child: Icon(Icons.mic_sharp),)),);&#125; 这种代码设计不需要额外的代码。您可以从主题上下文中使用这里需要的内容。让我们来看看文本样式示例: 123456789Text buildTextSub(BuildContext context) &#123; return Text( items.searchResults, style:Theme.of(context).textTheme.headline6?.copyWith( letterSpacing: -0.2, fontWeight: FontWeight.w400, ), );&#125; 你可以看到这是一个非常简单和易于管理的代码，我只是添加了一些自定义代码并完成了所有的工作。 你可以看到条目属性，也许这和注释有重要的关系。如果您拥有所有的常量值类，并且只想创建常量值，那么您可以在类获得安全能力之后添加@immutable 注释。 12345@immutableclass AppTextItems &#123; final String searchResults = 'Search Results'; final String brocoliText = 'Broccoli';&#125; 是的，这个项目可能是理解这个体系结构的一个样本，但是总是应该编写强大的代码。 Yees 项目已经完成。如果你想改变一个主题，比如黑暗，我们只需要把这个实例改成黑暗，然后就可以了。 因此，我们采用了抽象的工厂设计能力和可管理的代码设计。它听起来很适合开发力量，因为颤振可以改善模式和特殊的角度。 完成了。现在我们可以直接实施我们自己的项目并管理一切。另一方面，这个项目不需要如何创建新的主题知识，因为你知道我们创建接口。不同的主题刚好适合这些界面，然后一切都完成了。 实际上，本文的主要目标是如何在主题实例中使用这种模式，因此这方面的知识对您的开发生活非常重要。 感谢你阅读《感谢你阅读《为你的生命健康》》 https://github.com/VB10/flutter-abstract-theme-manager © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"搭建一个摄像头应用程序 应用程序内部摄像头","date":"2021-07-05T16:00:00.000Z","path":"2021/07/06/translation/build-a-camera-app-flutter-in-app-camera/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/geekculture/build-a-camera-app-flutter-in-app-camera-825b829fe138 代码https://github.com/jagrut-18/flutter_camera_app.git 参考 https://pub.dev/packages/camera 正文 在许多应用程序中，我们需要用户通过点击图片上传图片。为此，我们可以使用设备的默认摄像头应用程序，但如果我们需要集成一个应用程序内的摄像头呢？那么，这也是可能的 Flutter 。小组已经开发了一个叫做摄像头的 https://pub.dev/packages/camera ，它可以让我们做到这一点。 建立项目首先，通过在 pubspec.yaml 文件中添加以下行，将 camera 包安装到项目中。 1camera: ^0.8.1+3 IOS 设置 这个插件需要 IOS 10.0 或更高版本。在 Info.plist 文件中添加以下行来设置内容。 1234&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;Can I use the camera please?&lt;/string&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;&lt;string&gt;Can I use the mic please?&lt;/string&gt; Android Setup 在 Android/app/build.gradle 文件中将 Android sdk 最小版本更改为 21(或更高版本)。 1minSdkVersion 21 现在我们的项目设置完成了，我们可以开始编写应用程序了。 我们将在应用程序中创建两个屏幕。 1.CameraScreen ー此屏幕将显示相机输出并拍摄图片 2.GalleryScreen ー这个屏幕将在网格视图中显示捕获的图片。 装载摄像头为了显示相机预览，我们需要首先加载相机。为此，转到 main.dart 文件中的 main 函数和 runApp 上面的这些行。 1WidgetsFlutterBinding.ensureInitialized(); //Ensure plugin services are initializedfinal cameras = await availableCameras(); //Get list of available cameras 现在我们有了相机列表，我们需要把它们传递给我们的相机/屏幕。 所以，摄像机会像这样通过 经过这一切之后，这就是 main.dart 的样子。 1234567891011121314151617181920212223import 'package:camera/camera.dart';import 'package:flutter/material.dart';import 'camera_screen.dart';void main() async &#123; WidgetsFlutterBinding.ensureInitialized(); // Obtain a list of the available cameras on the device. final cameras = await availableCameras(); runApp(MyApp(cameras: cameras));&#125;class MyApp extends StatelessWidget &#123; final List&lt;CameraDescription&gt; cameras; const MyApp(&#123;Key? key, required this.cameras&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Camera App', home: CameraScreen(cameras: cameras), ); &#125;&#125; CameraScreen这个屏幕的布局很简单。在顶部我们将显示实时相机预览和在底部将有三个按钮(交换相机，捕获和显示画廊)。 创建一个有状态小部件 CameraScreen。 我们将创建四个变量, 我们必须设置 selectedCamera = 0，从后置摄像头开始。如果设备有多于 1 个摄像头，我们可以通过更改这个索引切换到它。 现在让我们创建一个方法来初始化选定的相机。 在此方法中，我们将传递要初始化的摄像机索引。使用通过的摄像机列表，我们将加载具体的相机与分辨率的选择。 使用这个方法，我们将初始化 initState 中的后置摄像头。 别忘了丢掉相机控制器。 现在让我们构建 UI。 为了显示 CameraPreview，我们将使用以下代码。 123456789101112FutureBuilder&lt;void&gt;( future: _initializeControllerFuture, builder: (context, snapshot) &#123; if (snapshot.connectionState == ConnectionState.done) &#123; // If the Future is complete, display the preview. return CameraPreview(_controller); &#125; else &#123; // Otherwise, display a loading indicator. return const Center(child: CircularProgressIndicator()); &#125; &#125;,), 好了，现在我们要连续显示三个按钮。 开关/摄像头按钮首先是开关摄像头图标按钮。点击这个按钮，摄像头应该在前后之间切换。 为此，我们将使用相同的 initializeCamera 方法，但这一次 cameraIndex 将是动态的。cameraIndex 后置摄像头为 0，前置摄像头为 1(如果有前置摄像头的话)。 在点击，我们将检查设备是否有多个摄像头，如果没有，我们将显示一个带有消息的 snackbar。 12345678910111213141516IconButton( onPressed: () &#123; if (widget.cameras.length &gt; 1) &#123; setState(() &#123; selectedCamera = selectedCamera == 0 ? 1 : 0;//Switch camera initializeCamera(selectedCamera); &#125;); &#125; else &#123; ScaffoldMessenger.of(context).showSnackBar(SnackBar( content: Text('No secondary camera found'), duration: const Duration(seconds: 2), )); &#125; &#125;, icon: Icon(Icons.switch_camera_rounded, color: Colors.white),), 捕捉按钮为了显示捕获按钮，我使用了一个半径为 60 的简单白色圆圈。点击后，我们将使用相机控制器拍摄一张照片并将其添加到 captureImages 数组中。 1234567891011121314151617GestureDetector( onTap: () async &#123; await _initializeControllerFuture; //To make sure camera is initialized var xFile = await _controller.takePicture(); setState(() &#123; capturedImages.add(File(xFile.path)); &#125;); &#125;, child: Container( height: 60, width: 60, decoration: BoxDecoration( shape: BoxShape.circle, color: Colors.white, ), ),), 显示画廊按钮这个按钮非常简单，我们将显示从 capturedmages 数组拍摄的最后一张图片，当单击时，它将导航到 GalleryScreen。 12345678910111213141516171819GestureDetector( onTap: () &#123; if (capturedImages.isEmpty) return; //Return if no image Navigator.push(context, MaterialPageRoute( builder: (context) =&gt; GalleryScreen( images: capturedImages.reversed.toList()))); &#125;, child: Container( height: 60, width: 60, decoration: BoxDecoration( border: Border.all(color: Colors.white), image: capturedImages.isNotEmpty ? DecorationImage(image: FileImage(capturedImages.last), fit: BoxFit.cover) : null, ), ),), 如您所见，GalleryScreen 接受捕获的图像列表，因此我们可以在 gridview 中显示它们。让我们完成这一部分来看看应用程序的运行情况。 GalleryScreen这是非常直接的屏幕。获取图像列表并在 GridView 中显示它们。 123456789101112131415161718192021222324import 'dart:io';import 'package:flutter/material.dart';class GalleryScreen extends StatelessWidget &#123; final List&lt;File&gt; images; const GalleryScreen(&#123;Key? key, required this.images&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Gallery'), ), body: GridView.count( crossAxisCount: 3, mainAxisSpacing: 2, crossAxisSpacing: 2, children: images .map((image) =&gt; Image.file(image, fit: BoxFit.cover)) .toList(), ), ); &#125;&#125; Final Product在构建应用程序之后，这是最终的结果。 摄像头包也可以捕捉视频，你可以使用 startVideoRecording，pauseVideoRecording 和 stopVideoRecording 方法来捕捉 https://pub.dev/packages/Camera。 这是这个项目的 Github 链接，希望对你有所帮助。 https://github.com/jagrut-18/flutter_camera_app.git 这个就到此为止，希望你喜欢。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 Flutter 使用 Sentry 收集错误","date":"2021-07-04T21:36:05.000Z","path":"2021/07/05/translation/error-reporting-using-sentry-in-flutter/","text":"猫哥说这个 Sentry 是一个错误收集平台方案，个人项目是免费的。 现在针对 Flutter 已经很成熟，可以同时收集 Dart、Flutter、原生端的错误。 猫哥在企业中是自己搭建了 Sentry 服务，这个是可以私有化的。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/podiihq/error-reporting-using-sentry-in-flutter-c4e7c8030b88 代码通过这种方式，您将能够监视和获得错误通知，并在客户开始抱怨之前提前解决它们。因为工作代码 = = 快乐的客户。 参考 https://sentry.io https://pub.flutter-io.cn/packages/sentry_flutter 正文想象一下你是一个独立的开发者，你在度假之前开发了一个新功能，在周末前几天将它部署到生产环境中，当客户开始积极使用它时，用户的问题和抱怨开始出现，你已经开启了你的度假情绪。正如通常的口号所说，“顾客永远是对的”，你决定优先考虑顾客的满意度而不是假期，并恢复工作情绪。可能会令人沮丧，对吧？ 以下是如何向服务报告错误，从而避免在客户之前出现未知的潜在错误或问题，因为工作代码等同于满意的客户。 您可以向许多服务报告代码错误。但是，在本文中，您将了解如何监视应用程序和潜在错误或 bug，并使用 Sentry 报告它们。 什么是 Sentry？Sentry 是一个应用程序监视平台，它使开发人员能够监视、诊断、修复和优化其代码的性能。 让我们开始吧使用 Sentry 创建一个帐户如果你在 Sentry 上还没有帐号，在这里创建一个: https://sentry.io/signup 创建一个新的 Sentry Flutter 应用接下来，登录到刚刚创建的 Sentry 帐户，创建 Flutter 应用程序。 按照下面的步骤成功地创建新项目。 创建新项目 登录之后，选择 create project 图标来创建一个新项目。 选择开发平台 有各种各样的开发平台支持 Sentry，包括 Python，Express，Spring Boot，Android 等等，但是本文只关注 Flutter。因此，从列表中选择 Flutter。 设置默认警报设置 接下来，将默认警报设置设置为在发生任何错误时何时以及如何获取警报的频率。在本文中，我将选择获取任何新问题的警报选项，但您始终可以选择任何您想要的选项。 最后，给你的项目起个名字 在本文中，我将给它命名为扑哨测试，然后，创建项目。 从 Sentry 获取 DSN 为了向 Sentry 报告错误，您需要一个 DSN (数据源名称) ，它将用 Sentry 服务唯一地标识您的应用程序。因此，在 Sentry 上创建项目之后，我们将从上面步骤中创建的应用程序中复制 DSN。 要获得 DSN，在您刚刚从上面创建的项目中，导航到项目设置并向下滚动到客户机密钥(DSN) ，如下所示: 接下来，在选择客户端密钥之后，客户端密钥选项卡将显示出来，从那里您将复制 DSN，如下所示: 创建一个 Flutter 应用程序，用于向 Sentry 报告错误这一步假设，您已经有了一些关于如何创建一个新的 Flutter 项目的实践经验。如果你是新的 Flutter 检验官方 Flutter 文件。你也可以看看我的文章《如何用 Flutter 开始》 现在让我们创建一个示例 Flutter 应用程序，用于向 Sentry 服务报告错误。 在终端上，输入 $flutter create Command，后跟应用程序的名称。在这种情况下，我们将使用名称 flutter _ sentry _ test。 1$ flutter create flutter_sentry_test 注意: 您也可以根据自己的喜好在各自的 IDE 上创建应用程序。 导入 Flutter Sentry 包在应用程序中安装 Sentry，将其添加到 pubspec.yaml 文件中 配置和初始化 Sentry SDK在 main.dart 文件中，导入 sentry 包。 接下来，添加将捕获应用程序中未处理的异常的配置。在此步骤中，用您在步骤 2 中创建的应用程序中的 Sentry DSN 替换 DSN url。从上面的 Sentry 那里得到一个 DSN。 您还可以通过 Dart 环境变量配置 SENTRY _ dsn，方法是将 – Dart-define 标志传递给编译器，如下例所示: 1--dart-define SENTRY_DSN = &apos;https://your-sentry.io DSN&apos; 验证最后，在这个步骤中，为了测试目的，通过在代码中添加一个有意识的错误来验证是否发送了错误。 这将抛出一个 State Error，它将被发送到 Sentry.io 服务 你可以通过导航到你的 Sentry 应用程序来确认这一点 在我的例子中，这里是发送到我的 Flutter Sentry 应用程序的 State Error 下面是示例应用程序如何向 Sentry 发送错误的演示: 点击这里查看完整的代码片段: https://github.com/JosephineAkello/flutter_sentry_test 通过这种方式，您将能够监视和获得错误通知，并在客户开始抱怨之前提前解决它们。因为工作代码 = = 快乐的客户。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在你的 Flutter 项目中隐藏敏感信息","date":"2021-07-01T16:00:00.000Z","path":"2021/07/02/translation/learn-the-best-way-to-hide-sensitive-keys-in-your-flutter-app/","text":"猫哥说有的时候我们需要在项目中隐藏敏感信息，比如你的阿里 OSS 账号 AccessKey ，写入代码中上传 git 仓库，是一件很危险的事情，所以我们需要用环境变量的方案来隐藏，记得你的 .env 文件要加入 .gitignore 文件中进行过滤呀。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutter-community/learn-the-best-way-to-hide-sensitive-keys-in-your-flutter-app-ac7638435401 代码https://github.com/Wizpna/flutter_dotenv_tutorial.git 参考 https://pub.dev/packages/flutter_dotenv 正文 我很高兴能写这个话题，因为这是一个移动应用程序开发者必须很少或已知的知识领域。 作为一个应用程序开发者，在谷歌游戏商店或苹果商店上开发和部署应用程序并不意味着你已经耗尽了移动应用程序开发周期。 移动应用程序开发周期还包括提高应用程序安全性。 这就是为什么我分享这篇文章，以便您将学习如何隐藏敏感的安全密钥在您的 Flutter 应用程序。 在本文的最后，您将学习如何使用一个名为 Flutter_dotenv 的 Flutter 插件来隐藏您的 Flutter 应用程序中的敏感键。 https://pub.dev/packages/flutter_dotenv 那么让我们开始吧使用 Visual Studio、 IntelliJ 或 Android Studio 创建您的 flutter 应用程序，然后打开“ pubspec.yaml”文件，并安装以下包。 12dependencies: flutter_dotenv: ^5.0.0 在您的 flutter 项目的根目录下创建一个.env 文件 将新创建的. env 文件添加到 pubspec.yaml 文件中的资产包中。 12assets: - .env 请注意: 添加新创建的。在 pubspec.yaml 文件中，请运行 flutter Pub get in the terminal，或者单击 Pub get in IntelliJ 或 Android Studio 将该文件添加到当前的工作目录文件夹中。 在成功添加了。在 pubspec.yaml 文件中添加您的敏感键。你创建的 env 文件。(例如，见下图) 下一步是在 main.dart 文件中初始化/加载. env 文件内容，如下图所示: 下一步将访问。环形文件。你可以访问。使用下面的代码。 1dotenv.env['VAR_NAME']; 请参阅下面的图片以获得正确的理解 使用物理设备或模拟器测试运行项目 请注意: 为了这个教程的缘故，我必须显示我添加在我的灵敏度键。因为我希望你们都能看到它，了解如何将敏感的密钥存储在 env 文件中，并在 flutter 应用程序中的任何地方访问它。 这种将敏感密钥存储在 env 文件中的模式有助于在黑客对应用进行反编译时，安全引导敏感密钥不被暴露。 永远记住添加。文件作为一个条目在您的 .gitignore 文件。(一) .gitignore 文件是一个纯文本文件，其中每一行包含 git working copy 中不包含的文件/目录。) 如果你读到这里，恭喜你！ 这是你刚刚参与的项目的源代码。 https://github.com/Wizpna/flutter_dotenv_tutorial.git 如果你发现这篇文章有帮助和教育，请击击击掌按钮尽可能多的次数，以显示您的支持 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 设计 使您的主题同质化","date":"2021-06-30T16:00:00.000Z","path":"2021/07/01/translation/flutter-design-make-your-theme-homogeneous/","text":"猫哥说如果你和我一样长期面对电脑，分享几个对眼睛有好处的经验 竟可能的室内用自然光，关掉多余的光源 显示器分辨率比例调小，字体大些 如果你需要更多屏幕空间，可以加一个辅助屏幕 可能的话去慢慢适应暗色主题 颜色调的对比度低些 连续工作 2 小时，起来走走 让眼睛眺望下远方 当然并不是所有人都适合，让自己的眼睛舒服就行 这篇文章是告诉你如何通过 ThemeData 来全局管理 Flutter 的界面样式。 有一次我项目做完，已经通过了评审，然后产品和我说要调下样式，刷的一下，给我了一个新的 sketch 设计稿，我的内心是抗拒的，但是只能耐心的去分析这个新版的样式标准，幸好设计师是一个设计学科的硕士做事还算规范。 然后我通过 ThemeData 解决了 90% 的问题，因为我在代码中尽可能的用官方组件，这样在 ThemeData 中还能找到这个对象。 剩下的自定义组件，应为我有抽取公共组件，所以改改就完成了。 阅读建议，你可以通过我的译文大致的了解内容，如果感兴趣可以通过原文细细品味，下方有原文链接。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutter-community/flutter-design-make-your-theme-homogeneous-13ddeffb186f 代码https://github.com/GONZALEZD/flutter_demos/tree/main/app_theming 参考正文 在很多 Flutter 源代码和应用程序中，我观察到一个反复出现的实践，即通过小部件参数直接添加自定义样式，导致不一致的设计和额外的维护。作为一个个人的例子，我必须维护一个 Flutter 应用程序，其中所有标题有不同的字体大小(有时字体重量)。 在这篇文章中，我将解释你的重要性的方式，你应该设计您的 Flutter 应用程序，尤其是关注的主题。 在您看来，这些“设置”页面在代码方面的区别是什么？ Settings page 设置页面 应用程序主题的正确方法是什么？ 在上图中，“设置”页面共享完全相同的代码。在这个层次上，这四种设计之间没有严格的区别。 这里面没有什么神奇的东西: 所有的主题相关的东西都集中在更高的层次，在 MaterialApp widget 中。这个小工具允许你定义两个主题，一个用于 light brightness，另一个用于 dark theme 模式。 此外，如果没有给出任何价值，大多数小部件都会从中检索它们的设计。 小部件正在从 ThemeData (大多数情况下)设置默认值 让我们来看一个如何正确做到这一点的例子: Card widget。你可以观察到在设置页面的第三个例子中，形状是直线而不是角。 而只有‘ child’属性在代码中使用: Card (child: …) 当你深入研究 Card 小部件是如何设计的时候，你会看到它的形状是如何定义的。下面是有关 Card.shape 属性的代码文档: 12345678/// The shape of the card's [Material].////// Defines the card's [Material.shape].////// If this property is null then [CardTheme.shape] of [ThemeData.cardTheme]/// is used. If that's null then the shape will be a [RoundedRectangleBorder]/// with a circular corner radius of 4.0.final ShapeBorder? shape; 因此，为了确保“普通”卡片共享相同的设计，您必须定义自己的 ThemeData，并在 MaterialApp 小部件中使用它作为主题(或 darkTheme)。 123456789101112131415ThemeData example() &#123; final base = ThemeData.dark(); final mainColor = Colors.lightBlue; return base.copyWith( cardColor: Color.lerp(mainColor, Colors.white, 0.2), cardTheme: base.cardTheme?.copyWith( color: Color.lerp(mainColor, Colors.black, 0.1), margin: EdgeInsets.all(20.0), elevation: 0.0, shape: BeveledRectangleBorder( borderRadius: BorderRadius.circular(14.0), side: BorderSide(color: Colors.white24, width: 1)), ), );&#125; 上面的代码演示了如何更改卡片设计，但是您可以为来自 Flutter SDK 的几乎所有小部件进行更改。此外，您应该将主题相关的内容集中到单个文件中，因为 ThemeData 是一个巨大的数据结构。 主题数据涵盖了所有的窗口小部件，对吧？不幸的是，ThemeData 并不能覆盖所有窗口小部件。例如，您不能在其中定义列表贴片设计。幸运的是，您可以通过 ListTileTheme 小部件实现这一点。 说明如何更改列表平铺选定的颜色和填充，而无需在源代码中显式设置页面。 通过 ListTileTheme，我们可以在不更改页面代码一行的情况下重新定义选择的标题/背景和前景色 12345678910111213ListView.builder( itemBuilder: (context, index) &#123; final value = elements[index]; return ListTile( selected: value == selected, title: Text(value.title), subtitle: Text(value.message), leading: Icon(value.icon), onTap: () =&gt; setState(() =&gt; selected = value), ); &#125;, itemCount: elements.length,); 正如您在代码中看到的，与设计没有任何关系。它的优点是避免代码噪声，使其简洁易懂。另外，我喜欢的一点是我所有的方法都很小(少于 30 行)。 总结在本文中，我们了解了如何将应用程序设计集中到 ThemeData 对象中。正如你所理解的，你可能需要阅读很多 Flutter SDK 代码文档，但是当你或者其他同事需要维护它的时候，好处就来了: 避免代码重复 减少页面中的代码，使代码更易于阅读和理解 确保设计的一致性 但是正如你可能已经看到的，ThemeData 对象是一个非常大的结构，在不断的演变中。所以，请密切关注它！ 我在开始一个新项目时查看 ThemeData 为了更进一步..再给你两个小建议！首先，如果您希望为您的组件之一进行特定的设计，而不是在构建方法中定制它，您可以将小部件包装到 Theme 小部件中。 当您设计一个新的小部件时，您可能希望通过从 ThemeData 检索主题信息来模仿 SDK 小部件。您可能已经看到，从 ThemeData 继承是不正确的方式。相反，您可以通过 InheritedTheme 小部件“扩展”它，并模仿它在 ListTileTheme 小部件中的实现方式。 像往常一样，你可以在这里找到本文使用的源代码和 adobe 设计: https://github.com/GONZALEZD/flutter_demos/tree/main/app_theming © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 强随机密码生成器","date":"2021-06-28T16:00:00.000Z","path":"2021/06/29/translation/generate-strong-random-password-in-flutter/","text":"猫哥说有的时候手机上也需要强密码生成器，这样就不用再 PC 上生成后复制过去了，用 Flutter 自己来打造一个吧。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/generate-strong-random-password-in-flutter-723e631727cc 代码https://github.com/flutter-devs/flutter_generate_strong_random_password_demo 参考正文 只是让我对你能够有效地做到的令人愉快的用户界面感兴趣，而且显然，它允许你同时为两个平台创建。存在的重要原因是用小部件构造应用程序。它描述了您的应用程序视图应该如何看待它们的当前设置和状态。当您修改代码时，小部件通过计算过去和当前小部件之间的对比来重新构建它的描述，以确定在应用程序的 UI 中呈现的可忽略的更改。 在这个博客中，我们将探索在 Flutter 中生成强随机密码。我们将实现一个生成随机密码演示程序，并了解如何创建一个强大的随机密码产生您的 Flutter 应用程序。 生成随机密码毫无疑问，我们可以创建复杂的密码，并用于您的客户端帐户。选择长度和字符，以利用和生成您的密码安全。 这个演示视频展示了如何在一次 Flutter 中创建一个强大的随机密码。它显示了如何生成强随机密码将工作在您的 Flutter 应用程序。当用户点击按钮，然后，密码将产生的组合长度，字符，数字，特殊，低字母，和上游字母表。它将在文本表单字段上生成，用户还将复制生成的密码。它会显示在你的设备上。 如何实现 dart 文件中的代码你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 generate _ password. dart 的新 dart 文件。 在主体部分，我们将添加 Container。在内部，我们将添加一个 Column 小部件。在这个小部件中，我们将添加 mainAxisAlignmnet 和 crossAxisAlignmnet。我们将添加文本并将其包装到行中。 12345678910111213141516171819Container( padding: EdgeInsets.all(32), child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Row( children: [ Text(\"Generate Strong Random Password\",style: TextStyle( fontSize: 18, fontWeight: FontWeight.bold ),), ], SizedBox(height: 15,), TextFormField(), SizedBox(height: 15,), buildButtonWidget() ), ], ),), 现在我们将添加 TextFormFeld，我们将使 _ contoller 的变量等于 TextEditingController ()。 1final _controller = TextEditingController(); 我们将真正的只读，因为密码生成时没有编辑。我们将假设 enableInteractiveSelection 并添加 InputDecoration 作为边框。 12345678910111213TextFormField( controller: _controller, readOnly: true, enableInteractiveSelection: false, decoration: InputDecoration( focusedBorder: OutlineInputBorder( borderSide: BorderSide(color: Colors.cyan,), ), enabledBorder: OutlineInputBorder( borderSide: BorderSide(color: Colors.cyan), ), ),), 我们还将创建一个 dispose ()方法来释放控制器 12345@overridevoid dispose() &#123; _controller.dispose(); super.dispose();&#125; 在 TextFormField 中，我们还将创建一个后缀图标。在内部，我们将添加 IconButton ()。我们将添加一个复制图标和 onPressed 方法。在 onPressed 方法中，我们将添加最终数据等于 clipboard data，在括号中，我们将添加 _ controller。文本和设置剪贴板上的数据。我们将显示一个 snackbar 时，复制图标按下，然后显示一个消息是“密码复制”。 12345678910111213suffixIcon: IconButton( onPressed: ()&#123; final data = ClipboardData(text: _controller.text); Clipboard.setData(data); final snackbar = SnackBar( content: Text(\"Password Copy\")); ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(snackbar); &#125;, icon: Icon(Icons.copy)) 现在我们将创建一个 buildButtonWidget () 我们将创建 buildButtonWidget () ，内部将返回一个标高按钮()。在这个按钮中，我们将添加标题按钮的样式并添加子属性。我们将添加文本“ Password Generate”，并在 child 属性中添加 onPressed 函数。在这个函数中，我们将添加一个等于 generatePassword ()的最终密码。我们将在下面的 generatePassword ()中进行深入的描述。添加 _ controller。文本等于密码。 123456789101112Widget buildButtonWidget() &#123; return ElevatedButton( style: ElevatedButton.styleFrom( primary: Colors.black ), onPressed: ()&#123; final password = We will deeply describe; _controller.text = password; &#125;, child: Text(\"Password Generate\",style: TextStyle(color: Colors.white),) );&#125; 我们将深入描述 generatePassword () : 在 lib 文件夹中创建一个名为 custom.dart 的新 dart 文件。 我们将创建一个 String generatePassword ()方法。在内部，我们将添加最终长度等于 20，letterLowerCase，letterUpperCase，number，special 字符。当我们使用一个强密码，然后真正的所有 bool 字母，isNumber，和 isSpecial。添加字符串字符并返回 List。生成()。添加 final indexRandom 等于 Random.secure ()。nextInt (chars.length)和 return chars [ indexRandom ]。 123456789101112131415161718192021222324import 'dart:math';String generatePassword(&#123; bool letter = true, bool isNumber = true, bool isSpecial = true,&#125;) &#123; final length = 20; final letterLowerCase = \"abcdefghijklmnopqrstuvwxyz\"; final letterUpperCase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; final number = '0123456789'; final special = '@#%^*&gt;\\$@?/[]=+'; String chars = \"\"; if (letter) chars += '$letterLowerCase$letterUpperCase'; if (isNumber) chars += '$number'; if (isSpecial) chars += '$special'; return List.generate(length, (index) &#123; final indexRandom = Random.secure().nextInt(chars.length); return chars [indexRandom]; &#125;).join('');&#125; 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:flutter/services.dart';import 'package:flutter_generate_strong_random/custom.dart';class GeneratePassword extends StatefulWidget &#123; @override _GeneratePasswordState createState() =&gt; _GeneratePasswordState();&#125;class _GeneratePasswordState extends State&lt;GeneratePassword&gt; &#123; final _controller = TextEditingController(); @override void dispose() &#123; _controller.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( automaticallyImplyLeading: false, backgroundColor: Colors.cyan, title: Text('Flutter Generate Random Password'), ), body: Container( padding: EdgeInsets.all(32), child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Row( children: [ Text(\"Generate Strong Random Password\",style: TextStyle( fontSize: 18, fontWeight: FontWeight.bold ),), ], ), SizedBox(height: 15,), TextFormField( controller: _controller, readOnly: true, enableInteractiveSelection: false, decoration: InputDecoration( focusedBorder: OutlineInputBorder( borderSide: BorderSide(color: Colors.cyan,), ), enabledBorder: OutlineInputBorder( borderSide: BorderSide(color: Colors.cyan), ), suffixIcon: IconButton( onPressed: ()&#123; final data = ClipboardData(text: _controller.text); Clipboard.setData(data); final snackbar = SnackBar( content: Text(\"Password Copy\")); ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(snackbar); &#125;, icon: Icon(Icons.copy)) ), ), SizedBox(height: 15,), buildButtonWidget() ], ), ), ); Widget buildButtonWidget() &#123; return ElevatedButton( style: ElevatedButton.styleFrom( primary: Colors.black ), onPressed: ()&#123; final password = generatePassword(); _controller.text = password; &#125;, child: Text(\"Password Generate\",style: TextStyle(color: Colors.white),) ); &#125;&#125; 结语在本文中，我解释了生成强随机密码的基本结构，您可以根据自己的选择修改这个代码。这是一个小的介绍生成强随机密码用户交互从我这边，它的工作使用 Flutter。 我希望这个博客将提供您尝试在您的 Flutter 项目生成强随机密码充足的信息。我们将向您展示生成随机密码是什么？.制作一个工作生成强随机密码的演示程序，它会显示当用户点击按钮，然后，密码将生成的长度，字符，数字，特殊，低字母和上游字母组合。它将生成的文本表单字段和用户也复制生成的密码在您的 Flutter 应用程序。所以请尝试一下。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 编写自定义组件 Part2.a ChildSize(with helpers)","date":"2021-06-20T21:55:22.000Z","path":"2021/06/21/translation/writing-custom-widgets-in-flutter-part-2-singlechildrenderobjectwidget/","text":"猫哥说这是自定义组件的第二篇, 第一篇点这里 有的时候我们需要做些很基础的组件或者工具，我们需要控制渲染、尺寸变化、预处理、销毁 这篇文章是写关于如何封装一个响应式的 ChangeSize 组件，组件继承了 SingleChildRenderObjectWidget，如果你也在写类似的功能，用这个父类可以快速的上手。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-2-singlechildrenderobjectwidget-5637fecdf9bb 代码https://github.com/MatrixDev/Flutter-CustomWidgets 参考 https://pub.flutter-io.cn/packages/get#reactive-state-manager https://dart.dev/guides/language/extension-methods 正文 介绍我写第二篇文章的时候到了。这次它将是一个非常简单的小部件，当它的子大小发生变化时，它会通知我们。这个任务非常简单，但是它的主要目的是向您展示如何在 RenderObject 中管理子对象。 当我刚开始学习 Flutter 的时候，它是我的问题之一，甚至是完成 Udemy 的课程，很遗憾，我没有得到我的答案。在 StackOverflow 上，人们建议在 Widget 上使用 GlobalKey，找到它的 RenderObject 并获取它的大小。 虽然上述解决方案没有任何问题，但我仍然不喜欢它的一些地方: 它改变了 Widget 元素的销毁方式 您需要在声明性小部件结构中添加命令式代码 没有能力实际跟踪小部件的大小，它需要根据需要拉 一般来说，我想要达到的目标是: 1234return ChildSize( child: buildChildWidget(), onChildSizeChanged: (size) =&gt; handleNewChildSize(size),); 简单的理论当编写一个包含子窗口的自定义窗口小部件时，我们需要知道一些重要的事情: 对于每个自定义小部件，我们需要编写它的 Element 和(有时) RenderObject 实现 元素将扩展其子元素 Widgets 为单独的元素，并在需要时更新/重新创建它们 几乎没有什么重要的角色ーー子代管理、布局、绘制和命中测试(鼠标指针、触摸事件等) 代码首先，我们需要声明一个实际的 Widget: 123456789class ChildSize extends SingleChildRenderObjectWidget &#123; final void Function(Size)? onChildSizeChanged; const ChildSize(&#123; Key? key, Widget? child, this.onChildSizeChanged, &#125;) : super(key: key, child: child);&#125; 这里没有什么新东西，除了 SingleChildRenderObjectWidget。这是 Flutter 框架中的一个帮手，它允许我们编写不超过一个子窗口的自定义窗口小部件。这大大简化了我们的代码，因为我们根本不需要编写定制的 Element。 我们唯一需要添加到 Widget 中的是创建 RenderObject，并在 Widget 更改时更新它: 12345678910111213class ChildSize extends SingleChildRenderObjectWidget &#123; // ... @override RenderObject createRenderObject(BuildContext context) &#123; return RenderChildSize().._widget = this; &#125; @override void updateRenderObject(BuildContext context, RenderChildSize renderObject) &#123; renderObject.._widget = this; &#125;&#125; 现在我们需要创建渲染对象: 1234class RenderChildSize extends RenderBox with RenderObjectWithChildMixin&lt;RenderBox&gt; &#123; var _widget = const ChildSize();&#125; 是一个特殊的 mixin，我们在使用 SingleChildRenderObjectWidget 时必须添加它。这个 mixin 将处理所有无聊的东西(请参阅下一篇文章)。几乎这种类型的每个帮助器都需要添加一些 mixin。您可以在每个帮助器的文档中找到这些要求。 下一步要做的是布局我们的 child: 123456789101112131415161718class RenderChildSize ... &#123; // ... var _lastSize = Size.zero; @override void performLayout() &#123; final child = this.child; if (child != null) &#123; child.layout(constraints, parentUsesSize: true); size = child.size; &#125; else &#123; size = constraints.smallest; &#125; if (_lastSize != size) &#123; _lastSize = size; _widget.onChildSizeChanged?.call(_lastSize); &#125; &#125;&#125; 在布局过程中我们必须决定渲染对象的大小。要做到这一点，我们需要布置我们的孩子。渲染对象的大小将与子对象的大小相同(我们没有任何填充、边距等)。 这里有一些重要的注意事项: 我们必须通过 parentUsesSize = true 子布局函数，以便事后得到它的大小。否则将抛出异常。感谢这个 flag Flutter 可以添加额外的优化 可能有这样一种情况，即使我们有一个子 Widget，也不会有它的子 RenderObject。并不是所有的小工具都有渲染对象。在这种情况下，如果存在任何最近的嵌套渲染对象，Flutter 将尝试提供给我们 在这个方法中，我们还检查大小是否发生了变化，并在发生变化时调用回调。 我们需要做的最后一件事就是描绘我们的 child 和路由命中测试事件: 12345678910111213141516class RenderChildSize ... &#123; // ... @override void paint(PaintingContext context, Offset offset) &#123; final child = this.child; if (child != null) &#123; context.paintChild(child, offset); &#125; &#125; @override bool hitTestChildren(BoxHitTestResult result, &#123;required Offset position&#125;) &#123; return child?.hitTest(result, position: position) == true; &#125;&#125; 结果如下: ### ### © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 创建多图像的 PDF 文件","date":"2021-06-17T16:00:00.000Z","path":"2021/06/18/translation/flutter-create-pdf-files-with-multiple-images/","text":"猫哥说保持热情去改变! 今天这篇文章是让你在客户端完成 PDF 的创建，这样能减轻服务器的压力。 这是很有必要的，服务器的 CPU 资源很宝贵。 Flutter 插件 https://pub.dev/packages/pdf 功能有： 载入图片 写上文字 加密、签名文件 也可以载入 pdf 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecatb 站 https://space.bilibili.com/404904528原文 https://medium.com/flutterdevs/flutter-create-pdf-files-with-multiple-images-4458e813fe37 代码https://github.com/flutter-devs/flutter_pdf_create_view_demo 参考 https://pub.dev/packages/pdf https://pub.dev/packages/path_provider/versions/2.0.1 https://pub.dev/packages/syncfusion_flutter_pdfviewer/versions/19.1.64-beta 正文 在 Flutter 不同的功能使您的应用程序丰富的有用性，并给简单的客户端做东西内的应用程序和改善客户端的经验，是一个专家合作是另外必不可少的开发人员。 有很多软件包可以用来在应用程序中打开 pdf，有些比较复杂，有些并不难执行，在这里我将阐明可能最容易使用的方法。 在这个博客中，我们将探索 Flutter ー创建多张图片的 PDF 文件。我们将实施一个演示程序，以显示如何 Flutter 创建一个 pdf 文件与多个图像使用的三个要素包在您的 Flutter 应用程序。 状态管理简介:PDF 很可能是用于交换业务信息的最著名的文档格式，因为内容不能像不同配置那样有效地更改。这样可以保护我们的信息不受未经批准的更改的影响。一旦你知道了策略，这通常是一个简单的互动，我会告诉你在你的任务中制作 pdf 文档的最好方法。 对于这个演示，需要三个基本的软件包。 https://pub.dev/packages/pdf https://pub.dev/packages/path_provider/versions/2.0.1 https://pub.dev/packages/syncfusion_flutter_pdfviewer/versions/19.1.64-beta 演示模块: 这个演示视频显示了如何在一个 Flutter 与多个图像创建 pdf 文件。它显示了 pdf 文件将如何使用这三个软件包在您的 Flutter 应用程序。它显示当用户点击一个创建按钮，然后出现 pdf，根据页面有多个图像。它会显示在你的设备上。 实施方案: 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 1234567dependencies: flutter: sdk: flutter cupertino_icons: ^1.0.2 path_provider: ^2.0.1 pdf: ^3.3.0 syncfusion_flutter_pdfviewer: ^19.1.64-beta 第二步: 添加 assets 将 assets 添加到 pubspec ー yaml 文件。 12assets: - assets/images/ 第三步: 导入 123import 'package:pdf/pdf.dart';import 'package:path_provider/path_provider.dart';import 'package:syncfusion_flutter_pdfviewer/pdfviewer.dart'; 第四步: 在应用程序的根目录中运行 flutter 软件包 如何实现 dart 文件中的代码:你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 pdf _ screen _ demo. dart 的新 dart 文件。 首先，让我们创建一个基本的 PDF 文件: 在文件中创建一个 StatefulWidget，名为 PdfScreenDemo。 1String pdfFile = ''; 一个基本的用户界面，我们有一个凸起的按钮，使我们的 PDF 文件和一个可见性小部件揭示 PDF 浏览器一旦 PDF 记录。要查看 PDF 记录，我们将使用 syncfusion/flutter/pdfviewer 包的 SfPdfViewer.file 小部件，在这个小部件中，我们将制作一个文档，其方式与我们制作的 PDF 类似。 12345678910111213141516Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Visibility( visible: pdfFile.isNotEmpty, child: SfPdfViewer.file(File(pdfFile), canShowScrollHead: false, canShowScrollStatus: false), ), RaisedButton( color: Colors.tealAccent, onPressed: () &#123; &#125;, child: Text('Create a Pdf File')), ],), PDF 包有它自己的小部件库存，为了调用这些库存，我们需要导入 PDF 小部件作为一个变量名为 pw。 1import 'package:pdf/widgets.dart' as pw; 为了构造一个 PDF 格式，我们将通过调用 pw &lt; widgetnme &gt; 来调用小部件。 为了保存一个 pdf 文件，我们应该做一个。文件()。这个不常见的小部件将保存已生成 PDF 的数据，因此我们在 _ PdfScreenDemoState 中生成一个变量如何。 1var pdf = pw.Document(); Lest’s create createPdfFile() method: 在这个模型中，我们的想法是制作一个多页的带有 a4 设计的 PDF。因为我们要添加的图片的数量，页面的数量可能是多个的，按照这些顺序，现在制作一个多页面小部件是个好兆头。 在 MultiPage 小部件的构建方法内部，将有一个带有 Header 的 Column 和 Divider，用于将实质内容与 Header 分离。在接下来的几个阶段中，我们将在本栏内的分隔符下添加实质内容。 123456789101112131415161718createPdfFile() &#123; pdf.addPage(pw.MultiPage( margin: pw.EdgeInsets.all(10), pageFormat: PdfPageFormat.a4, build: (pw.Context context) &#123; return &lt;pw.Widget&gt;[ pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.min, children: [ pw.Text('Create a basic PDF', textAlign: pw.TextAlign.center, style: pw.TextStyle(fontSize: 26)), pw.Divider(), ]), ]; &#125;));&#125; 此后，我们应该创建一个 savePdfFile ()方法。 它是一种异步方法，等待 IOS 或 Android 平台的目录。然后，该技术使用 ID 的名称和目录的 documentPath 创建一个记录。你可以用任何你喜欢的方式来命名你的记录，但是对于不同的 PDF 创建来说，更聪明的做法是为每个 PDF 文档都起一个特殊的名字。 最后，该方法将 PDF 保存为文件。Path 和 value 被赋给 setState 策略中的 pdfFile 变量，以便稍后刷新 UI。 123456789101112131415savePdfFile() async &#123;Directory documentDirectory = await getApplicationDocumentsDirectory();String documentPath = documentDirectory.path;String id = DateTime.now().toString();File file = File(\"$documentPath/$id.pdf\");file.writeAsBytesSync(await pdf.save());setState(() &#123;pdfFile = file.path;pdf = pw.Document();&#125;);&#125; 重要提示: 任命民主党人是根本。在保存 pdf 文件之后，将 Document ()转换为 pdf 变量。如果不这样做，该 pdf 将尝试使另一个最近制作的 pdf 文件，这将导致一个有缺陷的 pdf 文件被制作。 如果您需要保存您的 PDF 文件的字节，您可以利用下方的方法。 123List&lt;int&gt; pdfBytes;pdfBytes = await file.readAsBytes();pdfFile base64Encode(pdfBytes); 除此之外，使用异步 onPressed 方法: 为了保存记录，我们需要首先等待 createPdfFile ()策略。 1234onPressed: () async &#123; await createPdfFile(); savePdfFile();&#125;, 好了，现在一切都安排好了。你可以点击“创建一个 PDF 文件”按钮来查看你的第一个基本 PDF 文档。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 让我们用一个图片创建一个 pdf 文件: 在 pdf 包中，你可以添加一个图片。MemoryImage.因此，我们需要将图片更改为内存字节。 首先导入下面的软件包。 12import 'dart:typed_data';import 'package:flutter/services.dart'; 从那时起，将 createdffile 转换为一个 async 方法，并添加这两个变量。 12final ByteData bytes = await rootBundle.load('assets/images/null_safety.png');final Uint8List byteList = bytes.buffer.asUint8List(); 第一个变量在资源图片上更改为字节，第二个变量在字节上更改为 Uint8List 字节列表。 然后，在这一点上添加一个 pw 图像小部件在分隔符下面。 1234567891011121314151617181920212223242526272829createPdfFile() async &#123; final ByteData bytes = await rootBundle.load('assets/images/null_safety.png'); final Uint8List byteList = bytes.buffer.asUint8List(); pdf.addPage(pw.MultiPage( margin: pw.EdgeInsets.all(10), pageFormat: PdfPageFormat.a4, build: (pw.Context context) &#123; return &lt;pw.Widget&gt;[ pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.min, children: [ pw.Text('Flutter Pdf File with Image', textAlign: pw.TextAlign.center, style: pw.TextStyle(fontSize: 26)), pw.Divider(), ]), pw.SizedBox(height: 70), pw.Image( pw.MemoryImage( byteList, ), height: 300, fit: pw.BoxFit.fitHeight), ]; &#125;));&#125; MemoryImage 接受 byteList 作为位置竞争，将图片传送到 pdf 记录中。现在重新启动应用程序，并尝试制作另一个 PDF 文档，以查看其中包含图片的文件。当我们运行应用程序时，我们应该获得屏幕输出，就像下面的屏幕截图一样。 让我们创建一个有多个图片的 pdf 文件: 在演示的最后一步，我们将制作一个 pdf 构建技术，它可以用给定的各种图像生成一条记录。首先，我们需要制定一个策略，将图片转换为 Uint8List 设计。 在状态小部件中，创建一个空白列表，用于将图片放入 Uint8list。 1List&lt;Uint8List&gt; imagesUint8list = []; 然后，我们应该重构 createdffile 方法，并集中于另一种获取图片字节的技术。 12345getImageBytes(String assetImage) async &#123; final ByteData bytes = await rootBundle.load(assetImage); final Uint8List byteList = bytes.buffer.asUint8List(); imagesUint8list.add(byteList); &#125; 现在我们将制作一个类型为 pw 的列表。createPdfFile ()技术中的小部件，它生成具有图像标题和图像本身的 Column。 12345678910111213141516171819202122232425final List&lt;pw.Widget&gt; pdfImages = imagesUint8list.map((image) &#123; return pw.Padding( padding: pw.EdgeInsets.symmetric(vertical: 20, horizontal: 10), child: pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.max, children: [ pw.Text( 'Image' ' ' + (imagesUint8list .indexWhere((element) =&gt; element == image) + 1) .toString(), style: pw.TextStyle(fontSize: 22)), pw.SizedBox(height: 10), pw.Image( pw.MemoryImage( image, ), height: 400, fit: pw.BoxFit.fitHeight) ])); &#125;).toList(); 注意: 这是紧急给一个特定的最大大小的图片小部件，否则一个图片可能会溢出页面设计促使一个失败的 pdf 创建。 Createdffile 最初会创建一个 for 循环，将多个图片更改为 Uint8List。稍后，它将制作一个带有头部的图片列表。最后，pdfImages 将作为子文件显示在 pdf 的基本列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748createPdfFile() async &#123; for (String image in assetImages) await getImageBytes(image); final List&lt;pw.Widget&gt; images = imagesUint8list.map((image) &#123; return pw.Padding( padding: pw.EdgeInsets.symmetric(vertical: 20, horizontal: 10), child: pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.max, children: [ pw.Text( 'Image' ' ' + (imagesUint8list .indexWhere((element) =&gt; element == image) + 1) .toString(), style: pw.TextStyle(fontSize: 22)), pw.SizedBox(height: 10), pw.Image( pw.MemoryImage( image, ), height: 400, fit: pw.BoxFit.fitHeight) ])); &#125;).toList(); pdf.addPage(pw.MultiPage( margin: pw.EdgeInsets.all(10), pageFormat: PdfPageFormat.a4, build: (pw.Context context) &#123; return &lt;pw.Widget&gt;[ pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.min, children: [ pw.Text('Create a Simple PDF', textAlign: pw.TextAlign.center, style: pw.TextStyle(fontSize: 26)), pw.Divider(), ]), pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.max, children: pdfImages), ]; &#125;)); &#125; 另一个步骤是用 SingleChildScrollView 和 Expanded 小部件包装可见性小部件。 123456789Expanded( child: SingleChildScrollView( child: Visibility( visible: pdfFile.isNotEmpty, child: SfPdfViewer.file(File(pdfFile), canShowScrollHead: false, canShowScrollStatus: false), ), ), ), 现在如何我们按下按钮最后一次机会，使 PDF 文件与多个图片。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import 'dart:io';import 'dart:typed_data';import 'package:flutter/services.dart';import 'package:path_provider/path_provider.dart';import 'package:pdf/pdf.dart';import 'package:pdf/widgets.dart' as pw;import 'package:flutter/material.dart';import 'package:syncfusion_flutter_pdfviewer/pdfviewer.dart';class PdfScreenDemo extends StatefulWidget &#123; @override _PdfScreenDemoState createState() =&gt; _PdfScreenDemoState();&#125;class _PdfScreenDemoState extends State&lt;PdfScreenDemo&gt; &#123; String pdfFile = ''; var pdf = pw.Document(); static const List&lt;String&gt; assetImages = [ 'assets/images/null_safety.png', 'assets/images/stream.png', 'assets/images/error_handling.jpg' ]; List&lt;Uint8List&gt; imagesUint8list = []; @override @override Widget build(BuildContext context) &#123; return SafeArea( child: Scaffold( body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Expanded( child: SingleChildScrollView( child: Visibility( visible: pdfFile.isNotEmpty, child: SfPdfViewer.file(File(pdfFile), canShowScrollHead: false, canShowScrollStatus: false), ), ), ), RaisedButton( color: Colors.tealAccent, onPressed: () async &#123; await createPdfFile(); savePdfFile(); &#125;, child: Text('Create a Pdf File')), ], ), ), ), ); &#125; getImageBytes(String assetImage) async &#123; final ByteData bytes = await rootBundle.load(assetImage); final Uint8List byteList = bytes.buffer.asUint8List(); imagesUint8list.add(byteList); print(imagesUint8list.length); &#125; createPdfFile() async &#123; for (String image in assetImages) await getImageBytes(image); final List&lt;pw.Widget&gt; pdfImages = imagesUint8list.map((image) &#123; return pw.Padding( padding: pw.EdgeInsets.symmetric(vertical: 50, horizontal: 10), child: pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.max, children: [ pw.Text( 'Image' ' ' + (imagesUint8list .indexWhere((element) =&gt; element == image) + 1) .toString(), style: pw.TextStyle(fontSize: 22)), pw.SizedBox(height: 30), pw.Image( pw.MemoryImage( image, ), height: 300, fit: pw.BoxFit.fitHeight) ])); &#125;).toList(); pdf.addPage(pw.MultiPage( margin: pw.EdgeInsets.all(10), pageFormat: PdfPageFormat.a4, build: (pw.Context context) &#123; return &lt;pw.Widget&gt;[ pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.min, children: [ pw.Text('Flutter Pdf File with Multiple Image', textAlign: pw.TextAlign.center, style: pw.TextStyle(fontSize: 26)), pw.Divider(), ]), pw.Column( crossAxisAlignment: pw.CrossAxisAlignment.center, mainAxisSize: pw.MainAxisSize.max, children: pdfImages), ]; &#125;)); &#125; savePdfFile() async &#123; Directory documentDirectory = await getApplicationDocumentsDirectory(); String documentPath = documentDirectory.path; String id = DateTime.now().toString(); File file = File(\"$documentPath/$id.pdf\"); file.writeAsBytesSync(await pdf.save()); setState(() &#123; pdfFile = file.path; pdf = pw.Document(); &#125;); &#125;&#125; Conclusion在这篇文章中，我解释了创建 PDF 文件的基本结构与多重图像 Flutter; 您可以修改这个代码根据您的选择。这是一个小的介绍创建 PDF 文件与多图像用户交互从我这边，它的工作使用 Flutter。 我希望这个博客将提供您在尝试创建 PDF 文件与多个图像在您的扑项目充分的信息。我们将向您展示介绍是什么？.制作一个演示程序为工作创建 PDF 文件与多个图像和显示当用户点击一个创建按钮，然后 PDF 发生，与多个图像根据页面使用所有三个软件包在您的 Flutter 应用程序。所以请尝试一下。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"用 Flutter 实现动画 Motion Design","date":"2021-06-16T16:00:00.000Z","path":"2021/06/17/translation/implementing-motion-design-with-flutter/","text":"猫哥说这篇文章讲的是如何在你的动画中加入运动特性、运动球、重力、贝塞尔曲线、多边形、不规则曲线，如果你正在找这方面资料，这个源码你可要好好消化了。这都是动画中的基础，前端就是要酷炫，开始吧。 最佳体验还是阅读原文（链接在下面）。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 Flutter 技术群 ducafecat原文https://preyea-regmi.medium.com/implementing-motion-design-with-flutter-126d06b080ab 代码https://github.com/PreyeaRegmi/FlutterMotionDesignSamples 参考 https://pub.flutter-io.cn/packages/get#reactive-state-manager https://dart.dev/guides/language/extension-methods 正文大部分时间实现运动设计是一个有点累赘的移动应用程序。本文从更加实用的角度阐述了如何通过 Flutter 实现运动设计。我们将采取一个简单的运动设计从运球作为一个参考，并开始建设它一步一步。所有版权保留给各自的作者，实现的完整源代码可以在 github 上找到。 https://github.com/PreyeaRegmi/FlutterMotionDesignSamples 现在我们将重点放在登录/注册交互上。所以，就像其他的交互设计一样，我们将尝试把它分解成多个场景，这样我们就可以有一个清晰的整体概念，并将这些场景链接在一起。 场景 1: 初始状态屏幕 在这个场景中，我们在底部有一个弹跳的图像和文字，一个弯曲的白色背景，一个品牌标题包围着图像的中心和变形虫形状的背景。拖动底部的内容，直到一定的距离被覆盖，揭示动画播放和场景转换到下一个场景。 展示动画(中间场景) 在这个中间场景中，曲线背景高度是动画的。此外，在这个动画，控制点的三次贝塞尔曲线也被平移和还原，以提供加速效果。侧面的图标和变形虫背景也在垂直方向上 translated 以响应动画的显示。 场景 2: 后期显示动画状态屏幕 当显示动画完成后，品牌标题被一个圆形图标取代，一个标签指示器从屏幕左侧飞过来，相应的标签被加载。 现在我们有了设计中涉及的相关场景的概述。下一步，我们尝试将这些想法映射到实现细节中。那么让我们开始吧。 我们将使用 stack 作为顶级容器来托管我们所有的场景，并根据当前场景状态，我们将向 stack 添加各自的小部件，并动画他们的几何图形。 12345678910111213141516171819202122232425262728@override Widget build(BuildContext context) &#123; List&lt;Widget&gt; stackChildren = []; switch (currentScreenState) &#123; case CURRENT_SCREEN_STATE.INIT_STATE: stackChildren.addAll(_getBgWidgets()); stackChildren.addAll(_getDefaultWidgets()); stackChildren.addAll(_getInitScreenWidgets()); stackChildren.add(_getBrandTitle()); break; case CURRENT_SCREEN_STATE.REVEALING_ANIMATING_STATE: stackChildren.addAll(_getBgWidgets()); stackChildren.addAll(_getDefaultWidgets()); stackChildren.add(_getBrandTitle()); break; case CURRENT_SCREEN_STATE.POST_REVEAL_STATE: stackChildren.addAll(_getBgWidgets()); stackChildren.addAll(_getDefaultWidgets()); stackChildren.insert(stackChildren.length - 1, _getCurvedPageSwitcher()); stackChildren.addAll(_getPostRevealAnimationStateWidgets()); stackChildren.add(buildPages()); break; &#125; return Stack(children: stackChildren); &#125; 对于场景 1，所有相应的小部件都被定位并添加到 stack 中。底部“向上滑动开始”小部件的弹跳效果也立即开始。 12345678910111213141516171819202122232425262728293031323334353637383940414243//Animation Controller for setting bounce animation for \"Swipe up\" text widget _swipeUpBounceAnimationController = AnimationController(duration: Duration(milliseconds: 800), vsync: this) ..repeat(reverse: true); //Animation for actual bounce effect _swipeUpBounceAnimation = Tween&lt;double&gt;(begin: 0, end: -20).animate( CurvedAnimation( parent: _swipeUpBounceAnimationController, curve: Curves.easeOutBack)) ..addListener(() &#123; setState(() &#123; _swipeUpDy = _swipeUpBounceAnimation.value; &#125;); &#125;); //We want to loop bounce effect until user intercepts with drag touch event. _swipeUpBounceAnimationController.repeat(reverse: true);//Animated value used by corresponding \"Swipe up to Start\" Widget in _getInitScreenWidgets() method Positioned( right: 0, left: 0, bottom: widget.height * .05, child: Transform.translate( offset: Offset(0, _swipeUpDy), child: IgnorePointer( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Icon( Icons.upload_rounded, color: Colors.deepPurple, size: 52, ), Text( \"Swipe up to start\", style: TextStyle(color: Colors.grey.shade800), ) ]), ))), 为了实现这个小部件的拖动行为，一个可滚动的小部件也被放置在顶部，覆盖屏幕的下半部分。“向上滑动开始”也会根据拖动距离进行 translated，一旦跨过阈值(可滚动部件高度的 70%) ，就会播放显示动画。 12345678910111213141516171819202122232425262728293031323334353637//A simple container with a SingleChildScrollView. The trick is to set the child of SingleChildScrollView height//exceed the height of parent scroll widget so it can be scrolled. The BouncingScrollPhysics helps the scroll retain its//original position if it doesn't cross the threshold to play reveal animation.//This widget is added by _getInitScreenWidgets() methodPositioned( right: 0, left: 0, bottom: 0, child: Container( height: widget.height * .5, child: SingleChildScrollView( controller: _scrollController, physics: BouncingScrollPhysics(), child: Container( height: widget.height * .5 + .1, // color:Colors.yellow, ), ), ), ), //Intercepts the bounce animation and start dragg animation void _handleSwipe() &#123; _swipeUpBounceAnimationController.stop(canceled: true); double dy = _scrollController.position.pixels; double scrollRatio = math.min(1.0, _scrollController.position.pixels / _swipeDistance); //If user scroll 70% of the scrolling region we proceed towards reveal animation if (scrollRatio &gt; .7) _playRevealAnimation(); else setState(() &#123; _swipeUpDy = dy * -1; &#125;); &#125; 在显示动画中，使用 CustomPainter 绘制曲线背景和变形虫背景。在动画制作过程中，曲线背景的高度以及中间控制点都被内插到了屏幕高度的 75% 。类似地，用贝塞尔曲线绘制的变形虫也是垂直平移的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Update scene state to \"reveal\" and start corresponding animation//This method is called when drag excced our defined threshold void _playRevealAnimation() &#123; setState(() &#123; currentScreenState = CURRENT_SCREEN_STATE.REVEALING_ANIMATING_STATE; _revealAnimationController.forward(); _amoebaAnimationController.forward(); &#125;); &#125;//Animation controller for expanding the curve animation _revealAnimationController = AnimationController(duration: Duration(milliseconds: 500), vsync: this) ..addStatusListener((status) &#123; if (status == AnimationStatus.completed) setState(() &#123; currentScreenState = CURRENT_SCREEN_STATE.POST_REVEAL_STATE; _postRevealAnimationController.forward(); &#125;); &#125;);//Animation to translate the brand label _titleBaseLinePosTranslateAnim = RelativeRectTween( begin: RelativeRect.fromLTRB( 0, widget.height - _initialCurveHeight - widget.height * .2 - arcHeight, 0, _initialCurveHeight), end: RelativeRect.fromLTRB( 0, widget.height - _finalCurveHeight - 20 - arcHeight, 0, _finalCurveHeight)) .animate(CurvedAnimation( parent: _revealAnimationController, curve: Curves.easeOutBack));//Animation to translate side icons _sideIconsTranslateAnim = RelativeRectTween( begin: RelativeRect.fromLTRB( 0, widget.height - _initialCurveHeight - widget.height * .25 - arcHeight, 0, _initialCurveHeight), end: RelativeRect.fromLTRB( 0, widget.height - _finalCurveHeight - widget.height * .25 - arcHeight, 0, _finalCurveHeight)) .animate(CurvedAnimation( parent: _revealAnimationController, curve: Curves.easeInOutBack));//Tween for animating height of the curve during reveal process_swipeArcAnimation = Tween&lt;double&gt;(begin: _initialCurveHeight, end: _finalCurveHeight) .animate(CurvedAnimation( parent: _revealAnimationController, curve: Curves.easeInCubic));//Animation for the mid control point of cubic bezier curve to show acceleration effect in response to user drag. _swipeArchHeightAnimation = TweenSequence&lt;double&gt;( &lt;TweenSequenceItem&lt;double&gt;&gt;[ TweenSequenceItem&lt;double&gt;( tween: Tween&lt;double&gt;(begin: 0, end: 200), weight: 50.0, ), TweenSequenceItem&lt;double&gt;( tween: Tween&lt;double&gt;(begin: 200, end: 0), weight: 50.0, ), ], ).animate(CurvedAnimation( parent: _revealAnimationController, curve: Curves.easeInCubic));//Animation Controller for amoeba background _amoebaAnimationController = AnimationController(duration: Duration(milliseconds: 350), vsync: this); _amoebaOffsetAnimation = Tween&lt;Offset&gt;(begin: Offset(0, 0), end: Offset(-20, -70)).animate( CurvedAnimation( parent: _amoebaAnimationController, curve: Curves.easeInOutBack)); 完成动画后，场景 2 就设置好了。在这个场景中，品牌标题被图标所取代，标签指示器从屏幕左侧显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//Animation controller for showing animation after reveal _postRevealAnimationController = AnimationController(duration: Duration(milliseconds: 600), vsync: this); //Scale animation for showing center logo after reveal is completed _centerIconScale = Tween&lt;double&gt;(begin: 0, end: .5).animate(CurvedAnimation( parent: _postRevealAnimationController, curve: Curves.fastOutSlowIn, ));//_centerIconScale animation used by FAB in the middle Positioned.fromRelativeRect( rect: _titleBaseLinePosTranslateAnim.value.shift(Offset(0, 18)), child: ScaleTransition( scale: _centerIconScale, child: FloatingActionButton( backgroundColor: Colors.white, elevation: 5, onPressed: null, child: Icon(Icons.monetization_on_outlined, size: 100, color: isLeftTabSelected ? Colors.deepPurple : Colors.pinkAccent))), ),//Tab selection is done by \"CurvePageSwitchIndicator\" widgetPositioned( top: 0, bottom: _titleBaseLinePosTranslateAnim.value.bottom, left: 0, right: 0, child: CurvePageSwitchIndicator(widget.height, widget.width, arcHeight, 3, true, _onLeftTabSelectd, _onRightTabSelectd), );//The build method of CurvePageSwitchIndicator consisting of \"CurvePageSwitcher\" CustomPainter to paint tab selection arc//and Gesture detectors stacked on top to intercept left and right tap event.///When the reveal scene is completed, left tab is selected and the tab selection fly//towards from the left side of the screen @override Widget build(BuildContext context) &#123; return Stack(children: [ Transform( transform: Matrix4.identity() ..setEntry(0, 3, translationDxAnim.value) ..setEntry(1, 3, translationDyAnim.value) ..rotateZ(rotationAnim.value * 3.14 / 180), alignment: Alignment.bottomLeft, child: Container( height: double.infinity, width: double.infinity, child: CustomPaint( painter: CurvePageSwitcher( widget.arcHeight, widget.arcBottomOffset, showLeftAsFirstPage, pageTabAnimationController!), ), )), Row( crossAxisAlignment: CrossAxisAlignment.center, mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Expanded( child: Stack(children: [ Positioned( left: 0, right: 20, bottom: 0, top: 90, child: Transform.rotate( angle: -13 * 3.14 / 180, child: Align( alignment: Alignment.center, child: Text( \"Login\", style: TextStyle( color: showLeftAsFirstPage ? Colors.white : Colors.white60, fontSize: 22, fontWeight: FontWeight.w800), )))), GestureDetector(onTap: _handleLeftTab, ) ])), Expanded( child: Stack(children: [ Positioned( left: 20, right: 0, bottom: 0, top: 90, child: Transform.rotate( angle: 13 * 3.14 / 180, child: Align( alignment: Alignment.center, child: Text(\"Signup\", style: TextStyle( color: !showLeftAsFirstPage ? Colors.white : Colors.white60, fontSize: 22, fontWeight: FontWeight.w800))))), GestureDetector(onTap: _handleRightTab, ) ])), ], ), ]); &#125; 制表符指示器也使用贝塞尔曲线绘制，并定位在场景 1 的曲面背景之上，但在单独的 CustomPainter 中。为了实现制表位选择效果，在绘制制表位选择曲线时使用剪辑路径。 123456789101112131415161718192021222324252627282930//The paint method of \"CurvePageSwitcher\" to draw tab selection arcvoid _drawSwipeAbleArc(Canvas canvas, Size size) &#123; Path path = Path(); path.moveTo(-2, size.height - archBottomOffset); path.cubicTo( -2, size.height - archBottomOffset, size.width / 2, size.height - arcHeight - archBottomOffset, size.width + 2, size.height - archBottomOffset); path.moveTo(size.width + 2, size.height - archBottomOffset); path.close(); double left, right; if (showLeftAsFirstPage) &#123; left = size.width / 2 - size.width / 2 * animation.value; right = size.width / 2; swipeArcPaint.color = Colors.green; &#125; else &#123; left = size.width / 2; right = size.width * animation.value; swipeArcPaint.color = Colors.deepPurple; &#125; canvas.clipRect(Rect.fromLTRB(left, 0, right, size.height)); canvas.drawPath(path, swipeArcPaint); &#125; 除此之外，两个容器以各自的标签颜色相互顶部放置。根据选定的选项卡，保留相应的容器，将另一个容器 translated 到 x 轴的相反端，从而丢弃另一个容器。 1234567891011121314151617181920212223242526272829303132333435363738///The background for selected tab. On the basis of tab selected, the foreground container is translated away,///revealing the underlying background container. If the screen state is just set to reveal, then in the///initial state no foreground container is added which is signified by _tabSelectionAnimation set to null.///_tabSelectionAnimation is only set when either of the tab is pressed. List&lt;Widget&gt; _getBgWidgets() &#123; List&lt;Widget&gt; widgets = []; Color foreGroundColor; Color backgroundColor; if (isLeftTabSelected) &#123; foreGroundColor = Colors.deepPurple; backgroundColor = Colors.pink; &#125; else &#123; foreGroundColor = Colors.pink; backgroundColor = Colors.deepPurple; &#125; widgets.add(Positioned.fill(child: Container(color: foreGroundColor))); if (_tabSelectionAnimation != null) widgets.add(PositionedTransition( rect: _tabSelectionAnimation!, child: Container( decoration: BoxDecoration( color: backgroundColor ), ))); widgets.add(Container( height: double.infinity, width: double.infinity, child: CustomPaint( painter: AmoebaBg(_amoebaOffsetAnimation), ), )); return widgets; &#125; 因为我不能得到确切的图片和资源，我使用了我能在网上找到的最接近的一个。 所以总的来说，我们得到的结果如下。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Dart 的编程语言之美 4 个超级特性","date":"2021-06-14T23:46:06.000Z","path":"2021/06/15/translation/the-beauty-of-the-flutters-programming-language-4-superb-features-of-dart/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 Flutter 技术群 ducafecat原文 https://reprom.io/the-beauty-of-the-flutters-programming-language-4-superb-features-of-dart 参考 https://dart.dev/codelabs/async-await https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3 https://dart.dev/guides/language/language-tour https://api.dart.dev/stable/2.13.1/dart-isolate/dart-isolate-library.html 正文在阅读 Flutter 时，我读到最多的缺点之一就是使用 Dart 编程语言。它还没有 Kotlin 那么成熟，这是我读到的最常被提及的论点之一。在我看来(我承认这可能会引起争议) ，Dart 是一种伟大的语言，我不会在 Flutter 创建应用程序时为其他任何语言改变它，我是在 Kotlin 专业地创建 android 应用程序之后说的，顺便说一句，这也是一种优雅而美丽的语言。 在这篇文章中，我打算展示我最喜欢的 Dart 编程语言的 4 个特性，没有特定的顺序; 让我们看看我们如何利用这个现代工具: Null safety最近在 2.12 版本中添加(包括在 Flutter 2.0 中)。在任何假装坚实和高效的现代语言中，空安全都是必须的。这就是为什么 Dart 团队一直致力于实现声音 null 安全，这意味着我们可以有可以为空的类型和不能为空的类型，如果我们尝试在后面执行一个不安全的操作，我们会在应用程序构建之前得到一个编译错误: 123456789101112131415161718192021222324252627282930// This is a String that can be nullString? nullVar;// This String cannot be null, the compiler forces me// to set it a value because of its non-nullable nature.String nonNullVar = 'I am not null';// Alternatively, I can specify that the value will be// set later, but the property continues to be non-nullable.late String lateNonNullVar;// If I want to call a method on an instance of a type// that can be null, I need first to do a runtime check that// its value is not null.if (nullVar != null) &#123; nonNullVar.toLowerCase();&#125;// Or call it using the '?' operator, which means that the// method will only be called if the instance is not null:nullVar?.toLowerCase();// If the type is not nullable I can safely call any// method on it directly.nonNullVar.toLowerCase();// Always remember to initialize late vars, or you// will get an exception when trying to access its members.lateNonNullVar = 'some value';lateNonNullVar.toLowerCase(); Async / await就像在 Javascript 中我们有 Promises，在 Dart 中我们有 Futures，其中 async/await 是主要的关键词，这给了我们开发者一个简单而强大的方法来处理异步操作: 使用 Futures，我们可以轻松地停止当前操作流，等待某个异步操作完成，然后继续工作。 12345678910111213141516171819202122232425262728293031323334// To specify that a function will perform an asynchronous// operation (like doing a network request or reading from// a database) we mark it with the 'async' keyword:asyncFunction() async &#123; // ...&#125;// Use the 'await' keyword to stop the flow until the function// has completed its task:await asyncFunction();// You must declare a function as 'async' if it contains// calls to other async functions:main() async &#123; await asyncFunction();&#125;// If the async function returns a value, wrap it within// a Future. For instance, the following function// would do a network call and return its result:Future&lt;NetworkResult&gt; doNetworkCall() async &#123; // ...&#125;final result = await doNetworkCall();// But what if the network request fails and an exception// is thrown? Just wrap the call in a try/catch block:late NetworkResult result;try &#123; result = await doNetworkCall();&#125; on NetworkException catch (e) &#123; // Handle error&#125; 需要指出的是，即使使用 async/await 关键字，所有的操作都是在同一个线程中执行的，如果我们需要具体的性能要求，我们可以使用 isolates 产生替代线程。 定义函数参数的多种方法在 Dart 中，我们在定义函数参数时有多个选项: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// You can define mandatory parameters as you do in// many other languages, specifying their type and setting a label:functionWithMandatoryParameters(String someString, int someNumber) &#123; // ...&#125;// You are forced to send the defined parameters// when using the function:functionWithMandatoryParameters('some_string', 46);// You can however specify that the parameters are optional:// (note that the type must be defined as nullable, precisely because// there's no guarantee that the caller will send a value)functionWithOptionalParams( &#123;String? optionalString, int? optionalNumber&#125;) &#123; // ...&#125;// You can call this function without sending any values,// or specifying a value for an optional parameter with its label:functionWithOptionalParams();functionWithOptionalParams(optionalString: 'some_string');functionWithOptionalParams( optionalString: 'some_string', optionalNumber: 46);// When defining optional parameters, you can set a default value// that will be used in case that there is no value sent by the caller:functionWithDefaultValue(&#123;String someString = 'default'&#125;) &#123; // ...&#125;// The value of someString is 'default'functionWithDefaultValue();// The value of someString is 'some_string'functionWithDefaultValue(someString: 'some_string');// Lastly, you can even define mandatory named parameters with the// 'required' keyword, this is useful to enhance code readability.createUser( &#123;required String username, required String name, required String surname, required String address, required String city, required String country&#125;) &#123;// ...&#125;createUser( username: 'Ghost', name: 'John', surname: 'Doe', address: '3590 Mill Street', city: 'Beaver', country: 'US'); Composition with mixins软件开发中最不流行的趋势之一是重组而不是继承，这意味着使用类似组件的元素向类添加功能，而不是从父类继承。这种方法允许我们轻松地添加封装的功能，而无需处理复杂的继承层次结构。 例如，假设您有一个登录逻辑，您可能希望在应用程序中的不同位置使用它。您可以使用这个逻辑创建一个组件(mixin) ，然后在需要时重用它: 12345678910111213141516171819202122232425abstract class AuthUtils &#123; Future&lt;User&gt; login() async &#123; // Here we can add the login logic that will later be reused // in any class that ads this mixin. &#125;&#125;class LoginPage extends StatefulWidget &#123; LoginPage(&#123;Key? key&#125;) : super(key: key); @override _LoginPageState createState() =&gt; _LoginPageState();&#125;class _LoginPageState extends State&lt;LoginPage&gt; with AuthUtils &#123; @override Widget build(BuildContext context) &#123; return FutureBuilder&lt;User&gt;( future: login(), // Calling the mixin function builder: (BuildContext context, AsyncSnapshot&lt;User&gt; snapshot) &#123; // ... &#125;, ); &#125;&#125; 这里的优点是，我们可以随心所欲地添加任意多的 mixin，而不是仅通过使用继承从一个父类继承。 总结这些只是 Dart 提供给开发者的多个有用特性中的 4 个。如果你想了解更多，我建议你去参观 Dart 语言之旅，它以一种非常友好的方式解释了这门语言的每一个细节。 https://dart.dev/guides/language/language-tour © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 自动提示文本框","date":"2021-06-09T16:00:00.000Z","path":"2021/06/10/translation/autocomplete-fields-in-flutter/","text":"猫哥说当你开始用多屏，你就会需要屏幕越来越大、越来越多，不信你试试，会找各种理由来说服自己。 确实一块辅助屏对效率有很大的提升，我是建议辅助屏幕小些，或者说你自己舒服就行。 今天推荐的文章是提示输入框，虽然简单，但是很实用。 这种搜索提示框，可以放在登录账号输入框，搜索输入框提示，基础数据输入框。。。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecat原文 https://theiskaa.medium.com/autocomplete-fields-in-flutter-ec4eb6ec5ad7 代码 https://github.com/theiskaa/anon 参考 https://flutter.dev/docs/development/packages-and-plugins/using-packages https://pub.dev/packages/field_suggestion 正文 注意: 如果你是新手，想要创建非常基本的高级自动完成字段，那么这篇文章是为你准备的，继续！ 每个人都知道自动补全领域，有我们左右。我们可以在移动应用程序、网站、桌面应用程序等中看到它们。你有没有试过在 Flutter 中创建自动补全字段？啊，这对新手来说有点难。当你是一个新的学习者，这似乎是不可能的。 好吧那包裹可以帮我们。(我想我们大多数人都知道软件包/插件，如果你不知道，不要担心，只要按照这个官方文档的软件包和完整的阅读然后回来!). https://flutter.dev/docs/development/packages-and-plugins/using-packages 我写的其中一个是 field_suggestion 包，它可以帮助我们创建 Basic 或高级的自动完成字段。 https://pub.dev/packages/field_suggestion 在开始解释如何使用这个软件包之前，我想向您展示一个我使用这个软件包的应用程序的概览。 这是一个名为 Anon 的开源应用程序的截图。在那里我们使用字段建议作为我们的搜索栏。 查看详细信息: https://github.com/theiskaa/anon 好了，够了，让我们开始使用现场建议。 Requirements一个 textedingcontroller 和建议列表。 123456789101112131415161718192021222324final textEditingController = TextEditingController();// AndList&lt;String&gt; suggestionList = [ 'test@gmail.com', 'test1@gmail.com', 'test2@gmail.com',];// OrList&lt;int&gt; numSuggestions = [ 13187829696, 13102743803, 15412917703,];// Or// Note: Take look at [Class suggestions] part.List&lt;UserModel&gt; userSuggestions = [ UserModel(email: 'test@gmail.com', password: 'test123'), UserModel(email: 'test1@gmail.com', password: 'test123'), UserModel(email: 'test2@gmail.com', password: 'test123')]; 非常基本的用法这里我们有，只是文本编辑控制器和建议列表(作为字符串) 12345FieldSuggestion( textController: textEditingController, suggestionList: suggestionList, hint: 'Email',), 外部控制在这里，我们刚刚用 GestureDetector 包装了脚手架来处理屏幕上的手势。现在我们可以在点击屏幕的时候关闭盒子。(您可以在任何地方使用 BoxController 进行此操作，其中使用了 FieldSuggestion)。 123456789101112131415161718192021class Example extends StatelessWidget &#123; final _textController = TextEditingController(); final _boxController = BoxController(); @override Widget build(BuildContext context) &#123; return GestureDetector( onTap: () =&gt; _boxController.close(), child: Scaffold( body: Center( child: FieldSuggestion( hint: 'test', suggestionList: [], // Your suggestions list here... boxController: _boxController, textController: _textController, ), ), ), ); &#125; &#125; Class suggestions 注意: 你必须在你的模型类中使用 toJson 方法。如果你想在建议列表中使用它。 12345678910111213class UserModel &#123; final String? email; final String? password; const UserModel(&#123;this.email, this.password&#125;); // If we wanna use this model class into FieldSuggestion. // Then we must have toJson method, like this: Map&lt;String, dynamic&gt; toJson() =&gt; &#123; 'email': this.email, 'password': this.password, &#125;;&#125; 如果我们给出一个 userSuggestions，它是 List&lt;usermodel&gt; 。然后我们必须添加 searchBy 属性。我们的模型只有电子邮件和密码，对吗？所以我们可以这样实现: searchBy: email 或者 searchBy: password。 123456FieldSuggestion( hint: 'Email', textController: textEditingController, suggestionList: userSuggestions, searchBy: 'email' // Or 'password'), © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"介绍 Flutter 桌面应用 NativeShell","date":"2021-06-08T16:00:00.000Z","path":"2021/06/09/translation/introducing-nativeshell/","text":"猫哥说看到这张图片，我就感觉脖子酸。。。我这样摆过，虽然看起来很 cool，然后你的脖子要上下调整，这比左右调整费事。 今天推荐阅读的是关于 Flutter 桌面开发，下面有原文、代码 Git 链接。 开始前我想起 React Native 说过的一句话 《用同样的方法在多端开发》，这句话很玄妙又很正确，就是说不是让你同一套代码同时能编译成 ios android web windows linux …，只是代码的高度复用，所以有的同学在做多端架构时就要注意拆包了。 比如 你的业务代码、API、Entity、功能函数 很多情况下是复用的。但是各个平台的底层、交互体验是个性化。 不要被在 ios android 两端平滑兼容所欺骗。 今天介绍 NativeShell 这个桌面程序，这个程序演示了 多窗口、模式对话框、拖拽、菜单、工具栏、文件操作、系统 API 调用的例子，如果你正在做研究，这是一个很好参考。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信群 ducafecat原文 https://matejknopp.com/post/introducing-nativeshell/ 视频代码https://github.com/nativeshell/app_template 参考 http://airflow.app/ https://airflow.app/remote-app/ https://github.com/nativeshell/examples/blob/main/src/file_open_dialog.rs#L18 https://github.com/nativeshell/examples/blob/main/lib/pages/drag_drop.dart https://github.com/nativeshell/nativeshell/blob/main/nativeshell/src/shell/platform/win32/drag_com.rs 正文自从我第一次看到 Turbo Vision，我就对桌面应用程序感兴趣。DOS 中那些文本模式可调整大小的窗口对我来说就像魔术一样。它激发了人们对用户界面框架的兴趣，这种框架在 20 多年后依然很强大。 在过去十年左右的时间里，人们的注意力主要转移到了网络和移动设备上，这并没有让我感到特别高兴。所以我觉得是时候从阴影中爬出来，离开我的舒适区，试着把一些聚光灯带回它应该在的地方。到桌面上去！:) Flutter 之路我最后一个处理的桌面应用程序是(现在仍然是) Airflow。它是 Qt 和大量平台特定代码的混合体。如果我自己这么说的话，我对最终的结果非常满意，但是开发人员的经验和整体生产力还有很多需要改进的地方。 http://airflow.app/ 大约两年前，我需要一个适用于 iOS 和安卓系统的气流应用程序。经过几个原型后，决定做出，我去 Flutter。我确实喜欢认为我有自己的 UI 开发经验，毕竟，我在不同的平台上使用过十几个 GUI 框架，所以现在没有什么能让我感到惊讶的了，对吧？错了。他们所有人中最大的惊喜就是和 Flutter 一起工作的感觉是多么的好。在我的一生中，从来没有，一次也没有，建立用户界面这么有意义。 https://airflow.app/remote-app/ 如果我能用这种方式构建桌面应用程序，岂不是很神奇？当然，这是可能的，但现实是一个严酷的情妇，在那个时候桌面嵌入仍然处于婴儿期。那就回到 Qt 吧。但这个念头一直在我脑海中挥之不去。 一两年过去了，很多事情发生了变化。还有很多工作要做，但是桌面嵌入已经成熟了很多，而且 Flutter on desktop 已经开始成为一个可行的选择。 Flutter desktop 嵌入现在你可能会问: Matt，Flutter 不是已经嵌入了桌面吗? 那么这一切都是为了什么呢？ 是的，的确如此。NativeShell 就建立在他们之上。您可以将 Flutter 桌面嵌入程序想象为一个平台视图组件(想想 GtkWidget、 NSView 或者，恕我直言，HWND)。它处理鼠标和键盘输入，绘画，但它不尝试管理窗口，或 Flutter 引擎/隔离。或者做一些像平台菜单和拖放的事情。为了使事情更加复杂，Flutter 嵌入在每个平台上都有完全不同的 API。因此，如果您希望为一些低级代码创建引擎或注册平台通道处理程序，则需要为每个平台分别执行此操作。 https://nativeshell.dev/ 这就是 NativeShell 介入的地方从 Flutter 桌面嵌入结束的地方开始。它为现有的 Flutter 嵌入提供了一个一致的、与平台无关的 API。它管理引擎和窗户。它提供了拖放支持，对平台菜单的访问，以及其他超出 Flutter 嵌入范围的功能。并且它通过简单易用的 Dart API 公开了所有这些。 NativeShell 是用铁锈写的。锈是伟大的，因为它可以让你编写高效的低级平台特定的代码，如果你需要，但它也让你使用 NativeShell，而不必知道任何锈。简单地执行货物运输是所有需要让事情进行。Cargo 是 Rust 软件包管理器(就像 pub 是用于 Dart 的) ，它负责下载和构建所有依赖项。 开始 Install Rusthttps://www.rust-lang.org/tools/install Install Flutterhttps://flutter.dev/docs/get-started/install 在 Flutter 中启用桌面支持(为您的平台选择一个) 123$ flutter config --enable-windows-desktop$ flutter config --enable-macos-desktop$ flutter config --enable-linux-desktop Switch to Flutter Master 12$ flutter channel master$ flutter upgrade 在这之后，你应该可以开始了: 123$ git clone https://github.com/nativeshell/examples.git$ cd examples$ cargo run NativeShell 透明地集成了 Flutter 建立过程和货物。如果铁锈和飞镖之神在对你微笑，这就是你现在应该看到的: Platform Channels如果您需要从 Flutter 应用程序调用本机代码，这两个选项是平台通道或 FFI。对于一般使用的平台通道是预先设计好的，因为它们更容易使用，并且能够在平台和 UI 线程之间适当地传递消息。 这就是使用 NativeShell 注册平台通道处理程序的效果(我保证，这里也是惟一的 Rust 代码) 12345678910111213fn register_example_channel(context: Rc&lt;Context&gt;) &#123; context .message_manager .borrow_mut() .register_method_handler(\"example_channel\", |call, reply, engine| &#123; match call.method.as_str() &#123; \"echo\" =&gt; &#123; reply.send_ok(call.args); &#125; _ =&gt; &#123;&#125; &#125; &#125;);&#125; 为了直接使用现有的平台嵌入 API 来完成这项工作，您需要使用平台特定的 API 为每个平台分别编写这些代码。然后确保每次创建新引擎时都注册处理程序(关闭引擎时可能注销)。 使用 NativeShell，您只需注册处理程序一次，它可以从任何引擎调用。消息可以通过 Serde 被透明地序列化和反序列化为 Rust 结构(使用 Flutter 的标准方法编解码格式)。 https://github.com/nativeshell/examples/blob/main/src/file_open_dialog.rs#L18 Window Management想必你希望你的桌面应用程序有多个窗口？NativeShell 已经掩护你了。调整窗口大小到内容或设置最小的窗口大小，使 Flutter 布局不底流？它也能做到这一点。它还确保只在内容准备好后才显示窗口，从而消除了丑陋的闪烁。 目前，每个窗口作为单独的独立窗体运行。NativeShell 为创建窗口、设置和调整几何形状、更新样式和窗口标题提供了 API。它还提供了便于在窗口之间进行通信的 API。 视频可以根据内容调整大小，也可以根据内容大小调整大小。 多窗口 模式对话框 这将是 Dart 中如何创建和管理多个窗口的最小演示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void main() async &#123; runApp(MinimalApp());&#125;class MinimalApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // Widgets above WindowWidget will be same in all windows. The actual // window content will be determined by WindowState return MaterialApp( home: WindowWidget( onCreateState: (initData) &#123; WindowState? context; context ??= OtherWindowState.fromInitData(initData); // possibly no init data, this is main window context ??= MainWindowState(); return context; &#125;, ), ); &#125;&#125;class MainWindowState extends WindowState &#123; @override Widget build(BuildContext context) &#123; return TextButton( onPressed: () async &#123; // This will create new isolate for a window. Whatever is given to // Window.create will be provided by WindowWidget in new isolate final window = await Window.create(OtherWindowState.toInitData()); // you can use the window object to communicate with newly created // window or register handlers for window events window.closeEvent.addListener(() &#123; print('Window closed'); &#125;); &#125;, child: Text('Open Another Window'), ); &#125;&#125;class OtherWindowState extends WindowState &#123; @override Widget build(BuildContext context) &#123; return Text('This is Another Window!'); &#125; // This can be anything that fromInitData recognizes static dynamic toInitData() =&gt; &#123; 'class': 'OtherWindow', &#125;; static OtherWindowState? fromInitData(dynamic initData) &#123; if (initData is Map &amp;&amp; initData['class'] == 'OtherWindow') &#123; return OtherWindowState(); &#125; return null; &#125;&#125; Drag &amp; Drop很难想象还有哪个桌面用户界面框架不支持拖放操作。NativeShell 支持拖放文件路径、 url、自定义 Dart 数据(由 StandardMethodCodec 实现序列化) ，甚至可以扩展以处理自定义平台特定格式。 它应该很容易使用，而且我对它的结果很满意，尽管它确实涉及到编写一些看起来非常吓人的代码。 https://github.com/nativeshell/examples/blob/main/lib/pages/drag_drop.dart https://github.com/nativeshell/nativeshell/blob/main/nativeshell/src/shell/platform/win32/drag_com.rs Popup Menu很多框架和应用程序都犯了这样的错误，这常常让我感到惊讶。直到最近 Firefox 才开始在 macOS 上使用本地弹出菜单。无论你的应用程序多么精致，如果你的菜单出错了，你就会感觉不对劲。 允许你轻松地创建和显示上下文菜单。考虑到菜单系统的强大功能，这个菜单 API 看似简单。菜单是反应性的。你可以要求重建菜单，而可见和 NativeShell 将计算三角洲和只更新菜单项实际上已经改变。 12345678910111213141516171819202122232425262728int _counter = 0;void _showContextMenu(TapDownDetails e) async &#123; final menu = Menu(_buildContextMenu); // Menu can be updated while visible final timer = Timer.periodic(Duration(milliseconds: 500), (timer) &#123; ++_counter; // This will call the _buildContextMenu() function, diff the old // and new menu items and only update those platform menu items that // actually changed menu.update(); &#125;); await Window.of(context).showPopupMenu(menu, e.globalPosition); timer.cancel();&#125;List&lt;MenuItem&gt; _buildContextMenu() =&gt; [ MenuItem(title: 'Context menu Item', action: () &#123;&#125;), MenuItem(title: 'Menu Update Counter $_counter', action: null), MenuItem.separator(), MenuItem.children(title: 'Submenu', children: [ MenuItem(title: 'Submenu Item 1', action: () &#123;&#125;), MenuItem(title: 'Submenu Item 2', action: () &#123;&#125;), ]), ]; MenuBar可能是 NativeShell 中我最喜欢的功能。在 macOS 上，它呈现为空窗口小部件，而是将菜单放在系统菜单栏(在屏幕顶部)。在 Windows 和 Linux 上，它使用 Flutter 小部件呈现顶级菜单项，然后使用本机菜单处理其余部分。这意味着菜单栏可以位于小部件层次结构中的任何位置，它不局限于窗口的顶部，也不依赖于 GDI 或 Gtk 来绘制 iself。 它支持鼠标跟踪和键盘导航，就像普通系统菜单栏一样，但没有任何限制。 现在情况如何NativeShell 正在被沉重的开发。事情很可能会破裂。迫切需要更多的文档和示例。但我认为它的形状可能对某些人有用。 所有三个支持的平台(macOS，Windows，Linux)都具有完全的同等功能。 https://github.com/nativeshell/nativeshell/tree/main/nativeshell/src/shell/platform/macos https://github.com/nativeshell/nativeshell/tree/main/nativeshell/src/shell/platform/win32 https://github.com/nativeshell/nativeshell/tree/main/nativeshell/src/shell/platform/linux 如果你一路走到了这里，你可以继续 nativeshell.dev。 https://nativeshell.dev/ 感谢您的反馈！ https://github.com/nativeshell/nativeshell/issues © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"用 Melos 管理多包 Flutter 项目","date":"2021-06-07T16:00:00.000Z","path":"2021/06/08/translation/managing-multi-package-flutter-projects-with-melos/","text":"猫哥说我正在的写的新闻客户端代码模板，只是适合最多 100 pages 的轻巧型单包项目。 但是页面再多的话，说明你的项目业务、功能、组件足够复杂，项目也庞大，参与的人也多，这样的话项目就需要多包架构了，做过 android 的朋友最能体会了。 这篇文章就是介绍如何用 melos 来管理多包项目，看看对你是否有帮助吧。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文代码https://github.com/SAGARSURI/melos_demo integrate_melos 分支是完成的代码 参考 https://docs.page/invertase/melos https://invertase.io/ 正文大多数情况下，当你创建一个 flutter 项目。你使用一个包。这个项目由一个 pubspec.yaml，lib 文件夹组成。您将所有的特性和实用程序放在同一个包中。但也有一些项目将它们的特性和实用程序分解成多个包。这有助于提高关注点分离，并允许团队开源他们的一些软件包。下面是一个多包项目的示意图: 在这里，我们将项目分为三个层次。第一层是根项目，它包含适用于项目中所有不同包的通用配置。第二层拥有独立的功能包，它们不相互依赖。第三层由多个功能包中使用的实用工具包组成。我不会深入探讨如何创建或结构一个多包 flutter 项目。本文将着重于解决一个典型的多包 flutter 项目所面临的特殊挑战。 挑战在一个简单的程序包中，运行下面的任务是非常简单的: flutter pub get flutter test flutter analyze Generating code coverage i.e flutter test –coverage 但是在一个多包的 flutter 项目中运行相同的任务是具有挑战性的，因为你需要在项目中的每个包中运行这些任务，并在任务完成后给出总结结果。现在我们知道挑战是什么了。让我们来讨论一下解决这个问题的可能方法。 解决方案有两种可能的解决方案来解决这个问题。让我们看看第一个: 为各种任务编写 bash 脚本 这绝对是一个解决方案，但不是一个明智的解决方案。您需要首先编写一个脚本，找出项目中的所有包，并在其中运行上述任务之一。您还需要确保以漂亮的格式显示输出，以使内容具有可读性。如果您更喜欢 GUI，那么您需要在 IDE 中创建某种配置，以便通过 GUI 运行脚本 将 Melos 整合到你的项目中 这是一个比我强烈推荐的第一个方案更聪明的解决方案。因此，让我们详细讨论什么是 Melos，以及如何将其集成到您的多包项目中 介绍 Melos Melos 是一个 CLI 工具，用于管理多个包的 flutter/飞镖项目。 Melos 是由一个著名的小组在 flutter 社区即 invertase。你可以在他们的网站上阅读关于 Melos 的详细信息，但是这里有一个 Melos 提供的特性的快速列表: Automatic versioning &amp; changelog generation. 自动版本控制和更新日志生成 Automated publishing of packages to 将包自动发布到 pub.dev. Local package linking and installation. 本地包的链接和安装 Executing simultaneous commands across packages. 跨包执行同步命令 Listing of local packages &amp; their dependencies. 本地包及其依赖项的列表 现在让我们看看如何使用 Melos 执行上述所有任务。 注意: 如果你想在实践中学习，请下载入门课程。还有另一个分支，您可以在其中找到项目的最终版本。 https://github.com/SAGARSURI/melos_demo 安装 Melos让我们先安装 Melos。我假设您已经安装了 Flutter SDK，并将 Flutter 和 Dart 路径设置为 bash_profile。在终端中运行以下命令: 1dart pub global activate melos 下一步是在 IDE 中打开初学者项目。我更喜欢使用 Intellij，并且会向你展示一些由 Melos 提供的非常棒的 GUI 特性。项目结构应如下: 现在创建一个名为 melos.yaml 的文件，并将以下内容复制到其中: 123456name: melos_demopackages: - utility/** - features/** - \"*\" 让我们理解一下上面的脚本:a) name : 你必须给出项目的名称。您可以在 root 项目的 pubspec.yaml 中找到它.b) packages : 这个列表应该包含到项目中单个软件包的路径. 可以使用 glob 模式展开格式定义每个路径. Melos Bootstrap现在，从根项目中在终端中运行以下命令，将所有本地包链接在一起，并更新依赖关系，即 flutter pub get。 1melos bootstrap 在运行上面的命令之后，你应该会看到如下的输出: 你可以在这里阅读为什么你需要引导 Melos。准确地说，这是在项目中设置 Melos 或执行项目清理时应该执行的重要命令之一。 https://docs.page/invertase/melos/getting-started#why-do-i-need-to-bootstrap Melos Clean当您希望从项目中删除临时文件(构建工件、pub 文件等)时，可以执行此命令。下面是这个命令的样子: 1melos clean Commands现在，您将着手创建不同的命令，以实现我们在本文开头提到的任务。 在特定的包中运行测试用例在你的 melos.yaml 文件中写入以下命令: 1234567891011121314name: melos_demopackages: - utility/** - features/** - \"*\"scripts: test:selective_unit_test: run: melos exec --dir-exists=\"test\" --fail-fast -- flutter test --no-pub --coverage description: Run Flutter tests for a specific package in this project. select-package: flutter: true dir-exists: test 让我们理解一下上面的脚本中发生了什么: 1)你已经创建了一个自定义脚本，即 test: selective_unit_test，一旦执行，它会显示一个选项来选择一个你想要运行的单元测试包。 Melos 提供了强大的过滤选项来选择符合过滤条件的包。在上面的脚本中，您使用 – dir-exists = “ test”作为筛选选项。这将过滤由 testfolder 组成的所有包。你可以在他们的网站上找到更多的过滤选项。 3)——如果遇到失败的测试用例，fail-fast 将立即终止脚本执行。 4)您可以使用描述部分为每个脚本提供一个可读的描述。 5)你一定想知道为什么你把这个命令命名为 test: selective_unit_test。下一个命令将回答您的问题。 6)你可以详细阅读 melos exec 做了什么。基本上，它将在项目中的每个包中执行命令或脚本。 https://docs.page/invertase/melos/commands#exec 现在运行以下命令: 1melos run test:selective_unit_test 您将看到以下输出: 上面的命令能够找出包含文件夹测试的这些包。输入 2 作为选项，你会看到如下输出: 在所有包中运行测试用例现在编写以下命令，它将运行项目中的所有单元测试用例。这不会提示任何选项的选择: 1234scripts: test: run: melos run test:selective_unit_test --no-select description: Run all Flutter tests in this project. 让我们讨论一下上面的命令是做什么的: 这个命令将基本上运行上一个命令–no-select as an argument. 这意味着运行所有的单元测试 你可以使用 melos 来运行这个命令 因为可能有多个变种的测试命令，就像您在前一步骤 i.e 中创建的那样 test:selective_unit_test . 您还可以创建更多的变种，例如 test:e2e_test , test:bdd_test etc. 你可以将所有的变量组合在一起，并在一个命令 i.e 中运行 test . 运行所有包中的 analyzein: 在 script 部分创建以下命令: 123analyze: run: melos exec -- flutter analyze . description: Run `dart analyze` in all packages. 这里没有什么特别的，您可以执行 melos 运行分析来运行所有包中的分析。 生成整个项目的代码 coverage: 为整个项目生成代码 coverage。项目中包含一个自定义脚本，即组合覆盖。嘘。这将基本上合并来自不同包的所有 lcov.info 文件到一个 lcov.info 文件中。然后，您可以使用此方法将 lcov.info 文件转换为 HTML。 https://stackoverflow.com/a/53663093/4161284 1234567891011121314#!/usr/bin/env bashescapedPath=\"$(echo `pwd` | sed 's/\\//\\\\\\//g')\"if grep flutter pubspec.yaml &gt; /dev/null; then if [ -d \"coverage\" ]; then # combine line coverage info from package tests to a common file if [ ! -d \"$MELOS_ROOT_PATH/coverage_report\" ]; then mkdir \"$MELOS_ROOT_PATH/coverage_report\" fi sed \"s/^SF:lib/SF:$escapedPath\\/lib/g\" coverage/lcov.info &gt;&gt; \"$MELOS_ROOT_PATH/coverage_report/lcov.info\" rm -rf \"coverage\" fifi 在脚本部分下面写下以下命令: 1gen_coverage: melos exec -- \"\\$MELOS_ROOT_PATH/combine_coverage.sh\" Path 会给出存储 MELOS.yaml 的路径即 root 项目。脚本执行完毕后。您可以在项目中看到 coverage_report 文件夹。现在你有一个 lcov.info 文件，它会给你一个整个项目的报告。 最后，你的 melos.yaml 文件看起来像这样: 1234567891011121314151617181920212223name: melos_demopackages: - utility/** - features/** - \"*\"scripts: test:selective_unit_test: run: melos exec --dir-exists=\"test\" --fail-fast -- flutter test --no-pub --coverage description: Run Flutter tests for a specific package in this project. select-package: flutter: true dir-exists: test test: run: melos run test:selective_unit_test --no-select description: Run all Flutter tests in this project. analyze: run: melos exec -- flutter analyze . description: Run `dart analyze` in all packages. gen_coverage: melos exec -- \"\\$MELOS_ROOT_PATH/combine_coverage.sh\" 图形用户界面选项如果您不希望通过终端执行这些命令，并希望使用 GUI 运行它们，那么 Melos 可以满足您的要求。添加所有命令后，可以再次运行引导程序命令。这将生成一些配置，你可以看到一些图形用户界面选项如下: 现在您可以执行所有这些命令，而无需在终端中键入任何内容。 Next Steps这只是冰山一角。你可以在 Melos 网站上学到更多的过滤选项和命令。希望你喜欢这篇文章。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 5个必备的桌面插件包将包含在你的下一个版本中","date":"2021-06-03T16:00:00.000Z","path":"2021/06/04/translation/5-must-have-flutter-desktop-packages-to-include-in-your-next-build/","text":"猫哥说看到这张图，也许你和我一样向往着宁静的生活。 今天推荐文章中，感觉 字体、动画、下拉 插件还是很有用的，估计你都用上了。 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat 原文 https://medium.com/fddevops/5-must-have-flutter-desktop-packages-to-include-in-your-next-build-e45d6dfd3995 参考 https://pub.dev/packages/provider https://pub.dev/packages/google_fonts https://pub.dev/packages/photo_view https://pub.dev/packages/animations https://pub.dev/packages/flutter_pull_to_refresh 正文是 Google 在 2018 年开发的一个软件开发工具包。自成立以来，它获得了业界的广泛赞誉。使它脱颖而出的是其简单易学的编码语言省道，简单醒目的小部件设计，以及跨平台的开发能力。 Flutter 继续作出巨大的改进，现在是一个稳定的产品都 Flutter 网络和移动。虽然 Flutter Desktop Desktop 仍处于 alpha 阶段，但随着开发人员继续将其用于桌面应用程序开发，您可以期待在未来几个月内得到大量增强。在本文中，我们将向您介绍在下一个版本中必须包含的 5 个桌面软件包。 为什么桌面仍然有意义？如果你相信桌面应用程序的时代已经结束，那么你将是一个很好的公司。毕竟，移动应用程序的开发和使用仍在继续飞速增长，人们的注意力主要集中在移动应用的未来。 尽管如此，许多用户还是喜欢在更大的屏幕上查看应用程序，即使它不是桌面应用程序。桌面用户可以查看更多的信息，方便地导航，并且可以花更多的时间在应用程序上。 跨平台开发的兴起在过去的几年里，对本地开发人员的需求已经有了显著的下降。DRY (不要重复自己)长期以来一直是开发人员的圣杯。JsNode 有“承诺”(没有双关语的意思) ，然后 Xamarin 作为一个跨开发工具可以在多种平台上使用。本地开发中缺少这个特性。 Flego 是第一个跨平台开发工具，现在称为 React Native。Flutter 是一个跨平台的开发工具，它配备了 UI 呈现组件、导航、测试和大量的库。Flutter 引擎包含了开发人员构建和部署他们的应用程序所需的所有特性。 由于这些新的发展，许多人都认为 Flutter 有可能为桌面开发取代 electron。 Flutter 引擎Flutter 团队的目标是构建一个跨平台的 UI 工具包，以实现代码的可重用性。这就导致了 Flutter 发动机的发展。从技术的角度来看，Flutter 引擎把像素的屏幕上，当他们是必要的。Flutter 发动机是 Flutter 快速、高质量输出的基石。 Flutter 新的面向桌面的 alpha 版本允许更多的键盘输入、鼠标控制和大屏幕显示。 用于 Flutter 的桌面插件在 Windows、 Mac 和 Linux 操作系统上，有大量的桌面软件包可以使用。下面是这些软件包的一个快速概述。 Provider 5.0.0 (Null Safety)https://pub.dev/packages/provider 它是一个包装器，围绕着一个可继承的 widget，使它可重用且易于使用。你可以在代码中使用 Provider 而不是手动编写 Inheritedwidget，你会得到以下好处: 简化资源分配 延迟加载 一个显着减少样板和使一个新的类每次 用户友好的开发工具 在代码中使用 IngeritedWidget 的最可靠的方法 为类提供更多的可伸缩性 Google_fontshttps://pub.dev/packages/google_fonts 这并不奇怪。这个 Flutter 软件包可以让你在 Flutter 应用程序中使用 977 字体中的任何一种以及它们的变体，这些字体都来自 fonts.google.com。 开始使用 google 字体 使用 google 字体包,。或者。Otf 文件不需要存储在 assets 文件夹中，可以在 pubspec 中映射。它们可以在运行时通过 HTTP 命令检索一次，并且可以缓存在应用程序的系统中。这个包是专门为减少应用程序包的大小而设计的。使用 google_fonts 包，开发人员可以选择预绑定字体，然后使用相同的 API 在 HTTP 上选择字体。 Flutter Photo Viewhttps://pub.dev/packages/photo_view 一个简单的可缩放的用于 flutter 的图像/内容小部件。PhotoView 允许用户缩放图片，迎合用户的捏、旋转和拖动手势。 它还可以用于显示图像中的任何小部件，如 Container、 Text 或 SVG。虽然 PhotoView Flutter 软件包很容易使用，但是通过它的选项和控制器它是非常可定制的。 如何安装？ 在 pubspec.yaml 文件中添加 photo_view 作为依赖项 12dependencies: photo_view: ^0.11.1 导入照片查看: 1import 'package:photo_view/photo_view.dart'; 非常基本的用法 12345678@overrideWidget build(BuildContext context) &#123; return Container( child: PhotoView( imageProvider: AssetImage(\"assets/large-image.jpg\"), ) );&#125; animations高质量的 Flutter 动画预制。该软件包配备了预先录制的动画，以达到预期的效果。动画可以根据你的内容进行定制，也可以集成到应用程序中以取悦用户: Material Motion for FlutterMaterial Motion 是一组过渡模式，帮助用户理解和导航应用程序。目前，这个库提供了以下转换模式: Container transform Container transform 模式旨在促进包含容器的 UI 元素之间的转换。下面显示的图片告诉我们，这个包在两个 UI 元素之间创建了一个可见的连接。 Shared axis 共享轴模式有助于在具有空间或导航关系的 UI 元素之间进行转换。该模式在 x、 y 和 z 轴上使用共享转换来加强元素之间的关系。 Fade through 淡入模式用于在互不紧密相关的 UI 元素之间进行过渡。 Fade 淡入模式用于那些存在于屏幕边界内的 UI 元素，例如在屏幕中心淡出的对话框。 Flutter pulltorefresh该 Flutter 软件包集成了 Flutter 滚动部件和下拉刷新功能。 功能: 当你在窗口中向上滚动时，它会加载，当你向下滚动时，它会刷新 它最适合所有的滚动小部件，如 GridView 和 ListView 配备了一些常见的指示器 附带默认指示符和属性的全局设置 除了水平和垂直刷新，它还支持反向 ScrollView 包含更多的更新风格，比如 Behind，Follow，Unfollow 和 Front 支持两级刷新 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 构建漂亮的 Windows 应用程序ーー流畅的设计结构和导航","date":"2021-06-02T16:00:00.000Z","path":"2021/06/03/translation/flutter-building-beautiful-windows-apps-fluent-design-structure-and-navigation/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat猫哥说这是一套用来做 Windows UWP APP 的界面解决方案库 界面的搭建，菜单 导航 Tab 表单 常用控件 样式抽取 转场动画 图标 主题 自适应切换 都有了 如果你用的话可以 clone 一套，自己维护或者研究 https://github.com/bdlukaa/fluent_ui 原文 https://itnext.io/flutter-building-beautiful-windows-apps-fluent-design-structure-and-navigation-e53a394988d2 代码https://github.com/bdlukaa/fluent_ui 参考 https://pub.dev/packages/fluent_ui 正文流畅的设计是微软为设计漂亮的 Windows 程序提供的解决方案。Flutter 最终在 Google i/o 2021 中扩展了对 Windows UWP 的支持，这需要精心设计的 Windows 应用程序。在本文中，我将向您展示如何使用 Flutter 创建一个基本的 Fluent 设计应用程序。 本指南最适用于 Win32 和 UWP Flutter 应用程序。如果你还没有设置你的 UWP 扑动应用程序尚未，按照我的其他指南这样做。 添加所需的包第一步是由 bdlukaa 安装 fluent_ui 包。 https://pub.dev/packages/fluent_ui 1flutter pub add fluent_ui 现在，是时候开始创建我们的 Fluent Design 应用程序了！ FluentApp在 main.dart 中，导入 fluent_ui 包: 1import 'package:fluent_ui/fluent_ui.dart'; 然后，在 build 函数中创建 FluentApp 小部件，这是 Fluent 应用的基础。 1return FluentApp(); 你的代码现在应该是这样的: 12345678910111213141516171819import 'package:fluent_ui/fluent_ui.dart';void main() &#123; runApp(MyApp());&#125;class MyApp extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return MyAppState(); &#125;&#125;class MyAppState extends State&lt;MyApp&gt; &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return FluentApp(); &#125;&#125; 与 MaterialApp 类似，FluentApp 也有一个主题属性，该属性接受 ThemeData() ，并允许您自定义应用程序的外观。还可以使用 darkTheme 属性设置单独的暗主题。 ThemeData ()的一些关键属性是 ecastcolor (高亮元素的颜色)和 scaffoldBackgroundColor (应用程序的背景颜色)。当然，还有很多其他属性，比如 iconTheme，buttonTheme 和 contentDialogTheme，它们可以让你分别自定义图标、按钮和对话框的外观。 下面是 FluentApp 中使用主题的一个例子: 12345678910return FluentApp( theme: ThemeData( scaffoldBackgroundColor: Colors.white, accentColor: Colors.blue, iconTheme: const IconThemeData(size: 24)), darkTheme: ThemeData( scaffoldBackgroundColor: Colors.black, accentColor: Colors.blue, iconTheme: const IconThemeData(size: 24)),); 导航视图NavigationView 控制 Fluent Design 页面之间的移动。在 Fluent App 的 home 属性中添加一个 NavigationView，如下所示: 1234567891011return FluentApp( theme: ThemeData( scaffoldBackgroundColor: Colors.white, accentColor: Colors.blue, iconTheme: const IconThemeData(size: 24)), darkTheme: ThemeData( scaffoldBackgroundColor: Colors.black, accentColor: Colors.blue, iconTheme: const IconThemeData(size: 24)), home: NavigationView()); 应用程序栏在很多 Windows 应用程序中都很常见，可以通过 appBar 属性中的 NavigationAppBar 实现到 NavigationView 中。 12345home: NavigationView( appBar: NavigationAppBar( title: Text(\"Fluent Design App Bar\") ), ) 导航窗格打开: 窗格被展开并放置在内容的左侧。每个类别或页面必须有一个图标 压缩: 窗格放置在内容的左侧，只显示图标，直到它被展开。 最小化: 在窗格展开之前，只显示菜单按钮。当展开时，它被放置在内容的左侧。 这个模式根据窗口的宽度动态地在 Minimal，Compact 和 Open 之间进行选择。 顶部: 窗格位于内容的上方。它对于不能用图标表示的类别或页面很有用。 要创建 NavigationPane，可以使用 NavigationView 的 pane 属性。然后，我们可以将 displayMode 设置为 PaneDisplayMode.auto，PaneDisplayMode.open，panedisplaymode.com pact，PaneDisplayMode.minimal 或 PaneDisplayMode.top。 1234567home: NavigationView( appBar: NavigationAppBar( title: Text(\"Fluent Design App Bar\")), pane: NavigationPane( displayMode: PaneDisplayMode.auto, ), ) 接下来，我们需要在 NavigationPane 中指定项目。我们可以将 items 属性设置为 PaneItems 列表。每个 PaneItem 接受一个图标和一个标题。以下是我的例子: 12345678910111213pane: NavigationPane( displayMode: PaneDisplayMode.auto, items: [ PaneItem( icon: Icon(Icons.code), title: Text(\"Sample Page 1\") ), PaneItem( icon: Icon(Icons.desktop_windows_outlined), title: Text(\"Sample Page 2\") ) ] ), 现在，在 MyAppState 类中创建一个 int 类型的变量 index。这将负责管理 NavigationPane 中选定的页面。 12class MyAppState extends State&lt;MyApp&gt; &#123; int index = 0; 现在，我们将索引链接为 NavigationPane 的选定索引。将 NavigationPane 的选定属性设置为索引。 123pane: NavigationPane( selected: index,... 要在选定的 PaneItem 更改时更新索引变量，我们需要指定 onChanged 属性。 12345678pane: NavigationPane( selected: index, onChanged: (newIndex)&#123; setState(() &#123; index = newIndex; &#125;); &#125;,... 可选: 要在 NavigationPane 中添加 Acrylic 透明效果，可以在 NavigationView 中将 usecrylic 属性设置为 true。 12345home: NavigationView( appBar: NavigationAppBar( title: Text(\"Fluent Design App Bar\")), useAcrylic: true,... NavigationBodyNavigationBody 用于将页面转换实现为导航视图，并在页面之间切换时执行相关转换。 我们可以将 NavigationBody 设置为 NavigationView 的内容属性。 123home: NavigationView( content: NavigationBody(),... 接下来，我们需要指定 index 属性作为 NavigationPane 的选定索引。我们可以将它设置为我们的索引变量。 12345home: NavigationView( content: NavigationBody( index: index ),... 然后，我们需要将 children 属性指定为一个 List，其中包含要为每个 PaneItem 显示的小部件。注意: children 属性中小部件的顺序必须与 PaneItem 小部件的顺序相同。 通常，这些窗口小部件是脚手架页面小部件: 1234567content: NavigationBody( index: index, children: [ ScaffoldPage(), ScaffoldPage(), ], ), 脚手架页面脚手架 page 是 Fluent Design 中的 Material Scaffold。 Header 属性指定顶部栏。 123456ScaffoldPage( header: Text( \"Sample Page 1\", style: TextStyle(fontSize: 60), ), ), Content 属性指定 ScaffoldPage 中的其他小部件，类似于 Material Scaffold 中的 body 属性。 123456789ScaffoldPage( header: Text( \"Sample Page 1\", style: TextStyle(fontSize: 60), ), content: Center( child: Text(\"Welcome to Page 1!\"), ), ); 下面是我的应用程序到目前为止的样子: Navigator.push &amp; Navigator.popFluentApp 支持和 MaterialApp 相同的导航功能，因为我们都喜欢它。然而，当在 FluentApp 中浏览页面时，我们使用 FluentPageRoute 来代替 MaterialPageRoute。 1Navigator.push(context, FluentPageRoute(builder: (context) =&gt; Page2())); © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"为什么 Flutter 已经为企业应用程序开发做好了准备","date":"2021-06-01T16:00:00.000Z","path":"2021/06/02/translation/heres-why-flutter-is-now-ready-for-enterprise-app-development/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat猫哥说这篇文章很硬，如果你正在架构一个 APP，或者你正在写 flutter 技术论文，可以参考下。 原文 https://betterprogramming.pub/heres-why-flutter-is-now-ready-for-enterprise-app-development-1986ef2cd3e3 正文为企业应用程序开发做好准备了吗？长期以来，这一直是开发者提出的最多的问题之一。但是在 Beta 发布之后，这个平台展示了很多前景，并且提供了大量的本地化特性，使得本地化应用程序的开发变得更加容易。 虽然移动应用开发市场的确正在向强大的应用开发过程体验转变，但主要障碍之一是 iOS 和安卓应用开发之间的分工。由于这两种操作系统的用户遍布全球，企业在锁定受众时必须注意这一点，以确保自己的品牌不会遗漏任何市场。 本文将帮助您了解为什么颤振是准备授权企业。 当谷歌在 2018 年宣布 Flutter 的第一个稳定版本(1.0)时，人们很想知道它是否是一个很好的企业级移动应用程序开发工具。 快进到今天，我很自豪我决定尝试 Flutter 为企业应用程序开发。 我知道你们很多人都想知道为什么 Flutter 在应用程序开发方面获得了广泛的关注，因为它的定位与其他跨平台开发工具没有什么不同，这些跨平台开发工具提供了原生的 iOS 和 Android 应用程序。建立一次，部署到每个地方！ 不像其他人，我避免陷入这些陈述！ 在一年的时间里，现在有超过 4000 个插件支持 Flutter 应用程序。媒体，YouTube，Stack Overflow，以及更多的网站都充斥着建议 Flutter 可以帮助你为不同的商业领域创建各种各样的应用程序的内容。 Flutter 是王道ーー至少在企业应用程序开发解决方案方面是如此。这不仅仅是我的观点，也是来自移动应用开发行业的压倒性的声音。 https://www.xicom.ae/services/mobile-app-development/ 根据谷歌的统计，每月有 50 万开发者使用谷歌软件开发工具包。 https://venturebeat.com/2020/04/22/google-500000-developers-flutter-release-process-versioning-changes/ 另外，Flutter 的 SDK 是 GitHub 上增长第二快的项目，它使得它在业界的竞争对手中脱颖而出。所有这一切都指向一个欣欣向荣的社区，渴望分享，成长，并提高 Flutter！ https://techmonitor.ai/technology/software/top-10-programming-languages 所有这些事实，现在是时候来决定 Flutter 和它的库是否准备好在 2021 年开发企业移动应用程序了。 在我们直接进入你可能需要开发特定的企业安卓应用程序的需求之前，我的简单目标是为每个需求找到至少一个 Flutter 解决方案，让你相信 Flutter 现在已经准备好开发几乎没有混合代码需求的企业应用程序。 当然，业务应用程序的需求因项目而异，因此最终的结果可能会有所不同。 让我们先简单介绍一下 Flutter。 框架概述Flutter 是一个开源的 UI 软件开发工具包，广泛用于跨平台应用程序开发。通过使用单一的代码库，移动应用程序开发公司可以创建各种类型的应用程序，从简单的聊天应用程序到按需购物应用程序。它与其他框架的不同之处在于 Flutter 应用程序是用 Google 的面向对象程序设计语言 Dart 编写的。 谷歌选择了 Dart，同时考虑了以下四点: Productivity 生产力 Faster allocation 更快的分配 Object orientation 面向对象 High performance 高性能 有了这些事实，Flutter 可以帮助开发者为 iOS、 Android 和网络平台开发本地应用程序，这些应用程序可以在多个平台上无缝运行。 UI 性能、源代码成熟度、安全测试和功能是开发人员在为不同平台设计应用程序时遇到的主要挑战。颤振应用程序开发可以帮助您解决这样的问题，以极其轻松。 现在，企业应用程序到底是什么，构建它的主要需求是什么，Flutter 是如何对过程做出贡献的？ 企业级移动应用首先，企业应用程序是否仅仅意味着领先品牌的发展。 无论你是一个进步的创业公司还是一个领先的组织，企业应用程序都是为所有人服务的。这些应用程序是专门为企业劳动力的有限和受保护的使用而设计和开发的。对于企业应用程序，管理员可以集中处理数据，实现大规模的自动化，并维护流畅的工作流。但是为了使其功能化，企业应用程序需要许多特性、高安全性和具有健壮框架的无缝 UI 设计，以确保高性能。 让我们了解一下构建企业应用程序的具体要求，看看 Flutter 和它的库包生态系统是否已经为这项任务做好了准备。 以下是我选择的基本要求。在每一个需求类别中都有很多需要覆盖的内容，尽管我已经试图简要地假设读者已经熟悉 Flutter 的基本特性。 Layered architecture 分层结构 Development environment 发展环境 User interface 用户界面 Hardware features 硬件特性 App security 应用程序安全性 Miscellaneous requirements 杂项需求 分层架构，确保更好的功能性在开发企业应用程序时，确保它具有分层架构，以确保无缝功能，并通过不同开发团队的各种技能提高生产率。 当 layers 被插入时，开发者必须想办法提供以下功能: 更好地访问文档完整的设计模式 大量的开发人员同时处理代码库 很容易理解各种各样的应用程序功能 通过为网络资源、本地存储、 SQLite 数据库以及通过插件插件访问硬件提供简单而安全的网络，Flutter 在这里大放异彩。 让我们来看看如何: State management : 当前位置 Flutter 的应用程序架构的核心，而 Google 最近的建议是使用 Provider 框架，这个框架更容易理解和构建。同时其他状态管理如 Redux、 BLoC、,InheritedWidget 继承的 widget, setState, etc., they coexist within reason. 、 setState 等，它们在合理范围内共存 RxDart : 如果 Dart 的流和异步包不能满足您的异步编程需求，那么考虑 RxDart 是一个明智的决定。它与 Flutter 和状态管理框架无缝集成 Background processing 后台处理: 它允许计算密集的工作，以执行在应用程序，同时保持用户界面的响应在同一时间。根据后台处理需求的复杂程度，您可能需要采用纯 Dart 实现之外的本地平台特性 Dependency injection: 依赖注入: 为了使你的应用程序代码单元独立和可重用，移动应用程序开发人员可以使用 依赖注入.这是一种使代码更容易测试的设计模式。GetIT 定位器是一个简单易用的 DI 库，它与状态管理框架无缝地协同工作，以确保应用程序层的分离 JSON serialization/deserialization JSON 序列化/反序列化: 对于任何 RESTful 客户机都很重要，在大多数企业应用程序中也很常见 Deep linking 深度连接: 它提供正确的导航从一个网站或推送通知启动应用程序内的特定领域 Local storage 本地存储: 提供本地存储的少量键/值数据，然后帮助您的应用程序工作，即使应用程序是背景或停止 SQLite: 可用于处理大量的结构化数据 Push notifications 推送式通知 : 对于企业级应用程序，通常需要后端集成，以帮助您向用户通知到期日期、关于服务的提醒等。对于此，firebasmessaging 是一站式解决方案 本地安卓和 iOS 应用的开发环境对于开发环境，开发人员可以在 Android Studio/IntelliJ 和 Visual Studio Code 之间选择他们的 Flutter IDE。所有这些都在 Mac，PC，Linux 和 Chromebook 上得到了很好的支持。所有你需要的是采用 Flutter 应用程序开发与正确的经验。 在这些 ide 中，开发人员可以实现构建、设备部署、调试和性能分析。但是要为本地 iOS 创建一个开发环境/部署，需要在 Mac 上使用 Xcode。 Scalability 可伸缩性: 颤振应用程序很容易扩展，因为它基于 Dart 生态系统，引入 Dart 包来提供外部库的功能。颤振项目可以重构成颤振飞镖软件包，提供了另一种方式来分割大型团队的工作，使其更容易扩大应用程序 Testability 可测试性: 是否正在使用 unit tests 单元测试, widget tests 小部件测试, or ，或 integration tests 集成测试, 每一个 Flutter 小工具可以很容易地测试。所有这些测试工具都允许最大的测试覆盖率，并且仅受可用时间和资源的限制 Continuous integration/continuous delivery 持续集成/持续交付: 使用卓越的安卓和 iOS 工具集将应用程序部署到 Google Play 商店或苹果商店，使它们可以在任何现有的企业移动 CI/CD 设置中使用 与 Flutter 合作的移动应用程序开发公司可以将大部分时间花在 Flutter/Dart 环境中，同时将 Flutter 应用程序部署到安卓和 iOS 设备上。知识如何建立和签署应用程序和供应配置文件，等是必不可少的实施一个成功的扑动应用程序。 用户界面应用程序界面在用户体验中扮演着重要角色。企业移动应用程序努力专注于提供优秀的用户界面。为了满足这个需求，Flutter 提供了一套全面的 Android 和 iOS 的高精度演示。 为了让你的用户界面更有吸引力，你可以整合: Animations 动画: 很容易开始学习动画，他们可以扩展到任何复杂性。对于广泛使用的 Flutter，你可以包括耀斑，这是一个完整的 2D 矢量动画库。应用程序开发公司正在广泛使用这个工具来定制具有无缝接口的企业应用程序 Page transitions 页面转换: 他们可以是一个完美的例子，学习如何导航之间的应用程序页面与动画可以实现 Paging 分页或无限滚动列表视图: 当需要在不占用大量设备内存的情况下向用户显示大量数据时，这是一个常见的需求。这是年的最新趋势移动应用开发服务，因为 Flutter 提供了丰富的内容存储库的无限滚动 Image loading/caching library 图像加载/缓存库: 它提供了一种快速、简单的方法来处理许多图像，包括在基本图像或 SVG 图像不够好的情况下进行缓存。因此，Flutter 应用程序开发人员可以很容易地通过加载和缓存库管理图像 最后，你可以在 Flutter 移动应用程序上提供谷歌和苹果地图。 硬件特性需求无论你是如何出色地定制了你的应用程序，并提供了一系列广泛的功能，没有一个应用程序是完全可以在没有硬件功能支持的情况下工作的。 因此，当你雇佣应用程序开发人员为企业员工/用户/员工开发企业应用程序时，你需要硬件和软件支持: https://www.xicom.ae/solutions/hire-developers/ Camera 相机 Accelerometer 加速度计 GPS 全球定位系统 Biometric authentication, including fingerprint and face ID 生物计量学，包括指纹和脸部识别码 Microphone 麦克风 移动应用安全安全是一个企业无法破坏的领域ーー无论是基本的企业应用程序还是高级应用程序。保护应用程序数据安全是企业最关心的问题之一。因此，在创建企业应用程序时需要注意各种各样的事情。毫无疑问，这是一个非常广泛的话题，但我将把它缩小到几个具体点，使之易于理解。 假设 Flutter 应用程序是建立在安卓和 iOS 沙箱环境之上的，所以每个 Flutter 应用程序对于本地 iOS 和安卓应用程序都有固有的安全方面。 最基本的要求，如身份验证(生物统计学，拇指指纹，两级密码)很好地迎合了 Flutter 的简单认证。 以下是你可以考虑的其他认证提供商: Amazon 亚马逊 Facebook GitHub Google Dropbox Azure Active Directory Azure 活动目录 LinkedIn Instagram 图片分享 Microsoft Live Connect 微软 Live Connect SSL 证书固定也很重要，因为它减少了由于共享服务器而发生攻击的可能性。它确保 web (HTTPS)请求的安全，并且受到支持。 安全存储提供了一种在设备上安全地存储少量密钥或有价值信息的方法，即使在没有互联网连接的情况下也能让你的应用程序工作。 杂项要求除了以上所有的要求，这里还有一些在开发企业应用程序时需要考虑的多重要求: Analytics 分析: 分析库可在 Flutter 上满足这一要求 Error reporting 错误报告: 开发人员可以使用 Flutter’s Sentry library 插件. Third-party 第三方或开放源码库: 这份第三方插件的清单 在你开始在你的应用里随机挑选和使用一个之前 Generating QR codes: 生成二维码: 无论是为了应用程序的高级功能还是为了安全目的,二维码扫描很重要 考虑一下这个: 分享应用程序细节 社交媒体账号 访问个人接触名单 允许相机或位置，而使用的应用程序 发送短信或多媒体信息或接收短信 一次性密码 在应用程式内使用应用内支付 SDK. Flutter 的跨平台支持超越 iOS 和 Android我们只讨论了 Flutter 对本地 iOS 和 Android 应用程序的支持，但是 Flutter 正在极大地扩展对 web、 macOS、 Windows 和 Linux 的支持。开发一个可以在所有这些平台上无缝部署和执行的应用程序，只需要使用一段代码，这是您一直以来努力的目标。 与此同时，您必须接受这样一个事实，即并非所有平台都支持所有相同的特性。例如，谷歌地图现在只支持安卓、 iOS 和网络。另一方面，这些都是目前用户操作的主要平台。 通过利用 Flutter 的潜力和它广泛的小部件选择，你可以针对移动设备和网络。此外，它是更好的有响应屏幕与 Flutter 内置的应用程序，看起来不同的设备和适合用户的屏幕。所有这些都可以很容易地通过一个代码库实现。 总结在应用程序开发中，Flutter 已经越来越受欢迎，但随着图书馆的广泛支持，它已经迅速成为企业在短时间内创建企业应用程序的可行选择。 最好的部分是任何行业利基中的企业、科技公司、创业公司和个人开发者都可以通过雇佣合适的移动应用开发公司来发挥其潜力并创建一个应用程序。随着一个健康和成长的颤振库包装生态系统的正确使用，也许是时候让企业闪耀在竞争的市场，并建立自己的立足点在行业的未来十年。 https://www.xicom.ae/services/mobile-app-development/ 感谢 Anupam Chugh。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter开源项目 - 加密币客户端 flutter-crypto-app","date":"2021-05-31T16:00:00.000Z","path":"2021/06/01/flutter-opensource/flutter-crypto-app/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat猫哥说节日好伙伴们，今天这个项目推荐给大家，主要是用了 Riverpod 状态管理，Freezed 代码生成器, Flutter 2.2 空安全 还有就是 写了 单元测试 集成测试 Github Action，大家可以学习下。 代码https://github.com/salvadordeveloper/flutter-crypto-app 参考 https://flutter.dev/docs https://riverpod.dev/docs/getting_started/ https://docs.cryptowat.ch/rest-api/ 正文特性功能 API REST (CryptoWatch) restful 拉取数据 Linear Graph View (Hour, Day, Week, etc) 图 OHLC Graph 图 Search 搜索 Light / Dark Theme 样式主题 Multi Lenguage 多语言 Exchange Selection 交易 Favorite Pair 收藏 技术栈 Flutter 2.2.0 Riverpod + Hooks 状态管理 Freezed 代码生成器 Dio http 通讯 测试 Unit Testing (flutter_test) Integration Testing (integration_test) Mock Data (http_mock_adapter) Github Actions (iOS &amp; Android Integration Test) 屏幕截图 项目安装下载代码 1git clone https://github.com/salvadordeveloper/flutter-crypto-app 安装包 1flutter pub get 去申请 https://cryptowat.ch/zh-cn/ 账号 api 替换 API_KEY 1API_KEY=&#123;CryptoWatch_KEY&#125; 生成代码 1flutter pub run build_runner build --delete-conflicting-outputs 运行 app 1flutter run 单元测试 1flutter test 集成测试 1flutter drive --driver=test_driver/integration_test.dart --target=integration_test/main_test.dart 参考 https://flutter.dev/docs https://riverpod.dev/docs/getting_started/ https://docs.cryptowat.ch/rest-api/ © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 Flutter 中编写自定义小部件(第1部分)ー EllipsizedText","date":"2021-05-30T16:00:00.000Z","path":"2021/05/31/translation/writing-custom-widgets-in-flutter-part-1-ellipsizedtext/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://rlesovyi.medium.com/writing-custom-widgets-in-flutter-part-1-ellipsizedtext-a0efdc1368a8 代码https://github.com/MatrixDev/Flutter-CustomWidgets 正文 声明式用户界面在 Flutter 是相当不错，易于使用，它是非常诱人的使用尽可能。但是很多时候，开发人员只是做得太过火了ーー用声明的方式编写所有东西，即使有时候任务可以以更强制性的方式更有效、更容易理解。 每个人都应该明白的—- 在陈述和命令式编程之间必须有一个平衡。每种方法都有自己的用途，每种方法在某些任务上都比其他方法更加出色。 在本系列文章中，我将描述如何通过从头创建自定义小部件来解决不同的问题。每一个都比前一个稍微复杂一点。 思考在查看代码之前，我们需要知道一些基本的事情。 Widget ー只是一个不可变的(最好是 const)类，它包含 Elements 和 RenderObjects 的配置属性。它还负责创建上述元素和渲染对象。需要理解的重要事情ー小部件从不包含状态或任何业务逻辑，只是传递它们。 元素ー是负责实际 UI 树的实体。它包含对所有子元素的引用，以及(不像 Widget)对其父元素的引用。元素在大多数情况下都会被重用，除非键或小部件被更改。因此，如果 onlyWidget 属性被更改，即使分配了新的 Widget，Element 也将保持不变。 State ー只不过是 Element 内部的一个用户定义类，它还公开了一些来自它的回调。 RenderObject ーー负责实际尺寸的计算、子元素的放置、绘制、触摸事件的处理等。这些对象与 Android 或其他框架的经典视图非常相似。 为什么我们同时拥有元素和渲染对象？因为效率高。每个小部件都有各自的元素，但只有一些有渲染对象。由于这一点，很多布局，触摸和其他层次遍历调用可以省略。 代码第一个例子是一个非常简单的小部件，它在文本不适合时用省略号缩放文本。为什么我们需要这样一个小部件时，内置的文本已经省略号支持你可能会问？答案很简单—- 到目前为止，它只是通过文字而不是字符来表达 https://github.com/flutter/flutter/issues/18761。所以如果你有一个非常长的单词在结尾ー大多数时候你只能看到这个单词的前几个字母，即使有足够的空间去填充。 那么，我们开始吧。Flutter 有许多内置的基类和 mixin，它们将帮助构建完全自定义的小部件。以下是其中的一些: LeafRenderObjectWidget 没有 child SingleChildRenderObjectWidget 一个 child MultiChildRenderObjectWidget 多个 child 在我们的例子中，我们将使用 LeafRenderObjectWidget，因为我们只需要渲染文本，并且不会有子节点: 123456789101112131415161718192021222324enum Ellipsis &#123; start, middle, end &#125;class EllipsizedText extends LeafRenderObjectWidget &#123; final String text; final TextStyle? style; final Ellipsis ellipsis; const EllipsizedText( this.text, &#123; Key? key, this.style, this.ellipsis = Ellipsis.end, &#125;) : super(key: key); @override RenderObject createRenderObject(BuildContext context) &#123; return RenderEllipsizedText()..widget = this; &#125; @override void updateRenderObject(BuildContext context, RenderEllipsizedText renderObject) &#123; renderObject.widget = this; &#125;&#125; 我们创建了我们的 Widget，唯一不同寻常的是有两种方法: createRenderObject — 负责实际创建我们的 RenderObject updateRenderObject — 当 Widget 的数据发生变化但 RenderObject 保持不变时，将调用 updateRenderObject ー。在这种情况下，我们需要更新 RenderObject 中的数据，否则它将呈现旧文本 我还需要注意，将每个值从小部件复制到 RenderObject 是首选的。但是我会通过整个 Widget，因为不管怎样它们都是不可变的(而且我懒得编写所有的样板代码)。 现在让我们从实际的渲染对象开始: 123456789101112131415class RenderEllipsizedText extends RenderBox &#123; var _widgetChanged = false; var _widget = const EllipsizedText(''); set widget(EllipsizedText widget) &#123; if (_widget.text == widget.text &amp;&amp; _widget.style == widget.style &amp;&amp; _widget.ellipsis == widget.ellipsis) &#123; return; &#125; _widgetChanged = true; _widget = widget; markNeedsLayout(); &#125;&#125; 在这里，我们定义了所有的变量，并编写了一个 setter 来实际更新它们。还有一个检查值是否实际发生了更改的防护措施ー如果没有更改，则没有必要重新计算省略号和重绘文本。 现在我们需要布局渲染对象。 12345678910111213141516171819class RenderEllipsizedText extends RenderBox &#123; // ... var _constraints = const BoxConstraints(); @override void performLayout() &#123; if (!_widgetChanged &amp;&amp; _constraints == constraints &amp;&amp; hasSize) &#123; return; &#125; _widgetChanged = false; _constraints = constraints; size =_ellipsize( minWidth: constraints.minWidth, maxWidth: constraints.maxWidth, ); &#125;&#125; 布局的过程相当简单。所有我们需要做的ー根据提供给我们的约束计算渲染对象的大小。约束只描述我们必须遵守的最小和最大规模。另外，如果没有任何变化，并且在以前的布局传递过程中已经计算了大小，则添加额外的检查。 实际创建省略号文本的过程相当繁琐，而且肯定有更好的解决方案，但我选择使用二进制搜索来寻找最佳匹配。 12345678910111213141516171819202122232425class RenderEllipsizedText extends RenderBox &#123; // ... final _textPainter = TextPainter(textDirection: TextDirection.ltr); Size _ellipsize(&#123;required double minWidth, required double maxWidth&#125;) &#123; final text = _widget.text; if (_layoutText(length: text.length, minWidth: minWidth) &gt; maxWidth) &#123; var left = 0; var right = text.length - 1; while (left &lt; right) &#123; final index = (left + right) ~/ 2; if (_layoutText(length: index, minWidth: minWidth) &gt; maxWidth) &#123; right = index; &#125; else &#123; left = index + 1; &#125; &#125; _layoutText(length: right - 1, minWidth: minWidth); &#125; return constraints.constrain(Size(_textPainter.width, _textPainter.height)); &#125;&#125; 我不会讲完所有这些逻辑(如果你愿意，你可以通过它来阅读)。但是重要的是 TextPainter 是用来计算文本大小的。如果文本大小长于我们的约束，我会尽量使它越来越短，直到它符合我们的约束。 _layoutText 用来计算我们裁剪后的文本大小: 12345678910111213141516171819202122232425262728293031323334353637383940double _layoutText(&#123;required int length, required double minWidth&#125;) &#123; final text = _widget.text; final style = _widget.style; final ellipsis = _widget.ellipsis; String ellipsizedText = ''; switch (ellipsis) &#123; case Ellipsis.start: if (length &gt; 0) &#123; ellipsizedText = text.substring(text.length - length, text.length); if (length != text.length) &#123; ellipsizedText = '...' + ellipsizedText; &#125; &#125; break; case Ellipsis.middle: if (length &gt; 0) &#123; ellipsizedText = text; if (length != text.length) &#123; var start = text.substring(0, (length / 2).round()); var end = text.substring(text.length - start.length, text.length); ellipsizedText = start + '...' + end; &#125; &#125; break; case Ellipsis.end: if (length &gt; 0) &#123; ellipsizedText = text.substring(0, length); if (length != text.length) &#123; ellipsizedText = ellipsizedText + '...'; &#125; &#125; break; &#125; _textPainter.text = TextSpan(text: ellipsizedText, style: style); _textPainter.layout(minWidth: minWidth, maxWidth: double.infinity); return _textPainter.width;&#125; 差不多就是这样了，我们剩下要做的就是——实际上画出我们的文本。 1234@overridevoid paint(PaintingContext context, Offset offset) &#123; _textPainter.paint(context.canvas, offset);&#125; © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter 启动屏幕使用 Lottie 动画","date":"2021-05-26T16:00:00.000Z","path":"2021/05/27/translation/how-to-use-lottie-animation-in-your-flutter-splash-screen/","text":"猫哥说因为出差关系来了重庆，很美的一个城市，走在街道上感觉就是在爬山，生活节奏相对比较慢，希望疫情远离我们。 感谢群里重庆好友能抽时间出来聚会。 正题开始 lottie 是一个夸平台的动画库，用这个可以做出酷炫动画。 其实作为一个前端还是要稍微会一点点美术、动画、几何数学。 https://lottiefiles.com/ https://github.com/airbnb/lottie-web 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://mamuseferha.medium.com/how-to-use-lottie-animation-in-your-flutter-splash-screen-788f1380641d 代码https://github.com/debbsefe/Lottie-Animation-Splash-Screen 参考 https://lottiefiles.com/ https://github.com/airbnb/lottie-web https://github.com/debbsefe/Lottie-Animation-Splash-Screen 正文在构建移动应用程序时，启动画面非常常见。它们通常是在应用程序开始时显示的静态屏幕。这个屏幕可以帮助你告诉你的用户应用程序是关于什么的，通过显示你的应用程序标志或应用程序名称。 如果你想更进一步，真正吸引用户的注意力，可以考虑在启动画面上使用动画图片。使用 Lottie 显示一个动画图像就像在你的应用程序中使用 Image 小部件一样简单。 开始首先，创建一个新的 flutter 项目。 1flutter pub add lottie 通过粘贴以下代码创建启动画面小部件。 12345678910111213141516171819202122232425262728293031323334353637383940class SplashScreen extends StatefulWidget &#123; const SplashScreen(&#123;Key key&#125;) : super(key: key); @override _SplashScreenState createState() =&gt; _SplashScreenState();&#125;class _SplashScreenState extends State&lt;SplashScreen&gt; with TickerProviderStateMixin &#123; AnimationController _controller; @override void initState() &#123; super.initState(); _controller = AnimationController( duration: Duration(seconds: (5)), vsync: this, ); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Lottie.asset( 'assets/splash_lottie.json', controller: _controller, height: MediaQuery.of(context).size.height * 1, animate: true, onLoaded: (composition) &#123; _controller ..duration = composition.duration ..forward().whenComplete(() =&gt; Navigator.pushReplacement( context, MaterialPageRoute(builder: (context) =&gt; HomePage()), )); &#125;, ), ); &#125;&#125; Splash screen 小部件是一个有状态小部件，它在其 build 方法中保存 Lottie 文件。动画控制器在 initState 中创建，并在控制器属性中使用。 若要在动画完成后导航到下一个页面，请使用带有 LottieComposition 的 onLoaded 回调。这允许您有更多的信息和控制的 Lottie 文件。 1234567onLoaded: (composition) &#123; _controller ..duration = composition.duration ..forward().whenComplete(() =&gt; Navigator.pushReplacement( context, MaterialPageRoute(builder: (context) =&gt; HomePage()),)); &#125;, 动画完成后，导航到下一页。 我在代码中添加了一个启动画面导航到的主页小部件。 12345678class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center(child: Text('Homepage')), ); &#125;&#125; 以 scaffold 为中心的简单文本小部件。 现在你可以继续为你的用户创建更具视觉吸引力的应用了。 不要忘记将 Lottie 文件作为资产添加到 pubspec.yaml 中，否则，动画将不会显示。你也可以在 GitHub 上找到完整的项目。 https://github.com/debbsefe/Lottie-Animation-Splash-Screen © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Dart 集合操作插件 DartX","date":"2021-05-24T22:13:25.000Z","path":"2021/05/25/translation/dart-collections-with-dartx-extensions/","text":"本次图片是向 kallehallden 致敬，热爱编程，保持一颗好奇的心 老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat猫哥说最近没时间录视频，一直在做项目和技术研究，就翻译和写写文章和大家分享。 关于这篇文章，我只想说一切让我们少写代码，让代码简洁的方式都是好东西！ 也许这个组件 dartx 在某些人眼里不够成熟，但是这代表了一种思路，你应该去借鉴。 原文 https://medium.com/flutter-community/dart-collections-with-dartx-extensions-959a0b42849e 参考 https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/linq-to-objects https://pub.dev/packages/dartx 正文Darts Iterable 和 List 提供了一组基本的方法来修改和查询集合。然而，来自 c # 背景，它有一个非凡的 LINQ-to-Objects 库，我觉得我日常使用的一部分功能缺失了。当然，任何任务都可以只使用 dart.core 方法来解决，但有时需要多行解决方案，而且代码不是那么明显，需要花费精力去理解。我们都知道，开发人员花费大量时间阅读代码，使代码简洁明了是至关重要的。 Dartx 包允许开发人员在集合(和其他 Dart 类型)上使用优雅且可读的单行操作。 https://pub.dev/packages/dartx 下面我们将比较这些任务是如何解决的: first / last collection item or null / default value / by condition; map / filter / iterate collection items depending on their index; converting a collection to a map; sorting collections; collecting unique items; min / max / average by items property; filtering out null items; 安装 dartx pubspec.yaml12dependencies: dartx: ^0.7.1 1import 'package:dartx/dartx.dart'; First / last collection item…… or null为了得到第一个和最后一个收集项目的简单省道，你可以这样写: 12final first = list.first;final last = list.last; 如果 list 为空，则抛出 statereerror，或者显式返回 null: 12final firstOrNull = list.isNotEmpty ? list.first : null;final lastOrNull = list.isNotEmpty ? list.last : null; 使用 dartx 可以: 12final firstOrNull = list.firstOrNull;final lastOrNull = list.lastOrNull; 类似地: 1final elementAtOrNull = list.elementAtOrNull(index); 如果索引超出列表的界限，则返回 null。 … or default value鉴于你现在记住这一点。第一和。当 list 为空时，last getter 会抛出错误，以获取第一个和最后一个集合项或默认值，在简单的 Dart 中，你会写: 123final firstOrDefault = (list.isNotEmpty ? list.first : null) ?? defaultValue;final lastOrDefault = (list.isNotEmpty ? list.last : null) ?? defaultValue; 使用 dartx 可以: 123final firstOrDefault = list.firstOrDefault(defaultValue);final lastOrDefault = list.lastOrElse(defaultValue); 类似于 elementAtOrNull: 1final elementAtOrDefault = list.elementAtOrDefault(index, defaultValue); 如果索引超出列表的边界，则返回 defaultValue。 … by condition要获取第一个和最后一个符合某些条件或 null 的集合项，一个普通的 Dart 实现应该是: 123final firstWhere = list.firstWhere((x) =&gt; x.matches(condition));final lastWhere = list.lastWhere((x) =&gt; x.matches(condition)); 除非提供 orElse，否则它将为空列表抛出 StateError: 123final firstWhereOrNull = list.firstWhere((x) =&gt; x.matches(condition), orElse: () =&gt; null);final lastWhereOrNull = list.lastWhere((x) =&gt; x.matches(condition), orElse: () =&gt; null); 使用 dartx 可以: 123final firstWhereOrNull = list.firstOrNullWhere((x) =&gt; x.matches(condition));final lastWhereOrNull = list.lastOrNullWhere((x) =&gt; x.matches(condition)); … collection items depending on their indexMap…当您需要获得一个新的集合，其中每个项目以某种方式依赖于其索引时，这种情况并不罕见。例如，每个新项都是来自原始集合的项及其索引的字符串表示形式。 如果你喜欢我的一句俏皮话，简单地说就是: 1234final newList = list.asMap() .map((index, x) =&gt; MapEntry(index, '$index $x')) .values .toList(); 使用 dartx 可以: 1final newList = list.mapIndexed((index, x) =&gt; '$index $x').toList(); 我应用.toList ()是因为这个和大多数其他扩展方法返回 lazy Iterable。 Filter…对于另一个示例，假设只需要收集奇数索引项。使用简单省道，可以这样实现: 123456final oddItems = [];for (var i = 0; i &lt; list.length; i++) &#123; if (i.isOdd) &#123; oddItems.add(list[i]); &#125;&#125; 或者用一行代码: 12345final oddItems = list.asMap() .entries .where((entry) =&gt; entry.key.isOdd) .map((entry) =&gt; entry.value) .toList(); 使用 dartx 可以: 12345final oddItems = list.whereIndexed((x, index) =&gt; index.isOdd).toList();// orfinal oddItems = list.whereNotIndexed((x, index) =&gt; index.isEven).toList(); Iterate…如何记录集合内容并指定项目索引？ In plain Dart: 123for (var i = 0; i &lt; list.length; i++) &#123; print('$i: $&#123;list[i]&#125;');&#125; 使用 dartx 可以: 1list.forEachIndexed((element, index) =&gt; print('$index: $element')); Converting a collection to a map例如，需要将不同 Person 对象的列表转换为 Map &lt; String，Person &gt; ，其中键是 Person.id，值是完整 Person 实例。 1final peopleMap = people.asMap().map((index, person) =&gt; MapEntry(person.id, person)); 使用 dartx 可以: 12345final peopleMap = people.associate((person) =&gt; MapEntry(person.id, person));// orfinal peopleMap = people.associateBy((person) =&gt; person.id); 要得到一个 Map，其中键是 DateTime，值是列出那天出生的人的名单 &lt; person &gt; ，在简单的 Dart 中，你可以写: 12345678910final peopleMapByBirthDate = people.fold&lt;Map&lt;DateTime, List&lt;Person&gt;&gt;&gt;( &lt;DateTime, List&lt;Person&gt;&gt;&#123;&#125;, (map, person) &#123; if (!map.containsKey(person.birthDate)) &#123; map[person.birthDate] = &lt;Person&gt;[]; &#125; map[person.birthDate].add(person); return map; &#125;,); 使用 dartx 可以: 1final peopleMapByBirthDate = people.groupBy((person) =&gt; person.birthDate); Sorting collections你会怎样用普通的 dart 来分类一个收集? 你必须记住这一点 1list.sort(); 修改源集合，要得到一个新实例，你必须写: 1final orderedList = [...list].sort(); Dartx 提供了一个扩展来获得一个新的 List 实例: 12345final orderedList = list.sorted();// andfinal orderedDescendingList = list.sortedDescending(); 如何基于某些属性对收集项进行排序？ Plain Dart: 12final orderedPeople = [...people] ..sort((person1, person2) =&gt; person1.birthDate.compareTo(person2.birthDate)); 使用 dartx 可以: 12345final orderedPeople = people.sortedBy((person) =&gt; person.birthDate);// andfinal orderedDescendingPeople = people.sortedByDescending((person) =&gt; person.birthDate); 更进一步，你可以通过多个属性对集合项进行排序: 123456789final orderedPeopleByAgeAndName = people .sortedBy((person) =&gt; person.birthDate) .thenBy((person) =&gt; person.name);// andfinal orderedDescendingPeopleByAgeAndName = people .sortedByDescending((person) =&gt; person.birthDate) .thenByDescending((person) =&gt; person.name); Collecting unique items要获得不同的集合项，可以使用以下简单的 Dart 实现: 1final unique = list.toSet().toList(); 这并不保证保持项目顺序或提出一个多行的解决方案 使用 dartx 可以: 12345final unique = list.distinct().toList();// andfinal uniqueFirstNames = people.distinctBy((person) =&gt; person.firstName).toList(); Min / max / average by item property例如，要查找一个 min/max 集合项，我们可以对其进行排序，并获取 first/last 项: 123final min = ([...list]..sort()).first;final max = ([...list]..sort()).last; 同样的方法也适用于按项属性进行排序: 123final minAge = (people.map((person) =&gt; person.age).toList()..sort()).first;final maxAge = (people.map((person) =&gt; person.age).toList()..sort()).last; 或: 12345final youngestPerson = ([...people]..sort((person1, person2) =&gt; person1.age.compareTo(person2.age))).first;final oldestPerson = ([...people]..sort((person1, person2) =&gt; person1.age.compareTo(person2.age))).last; 使用 dartx 可以: 123final youngestPerson = people.minBy((person) =&gt; person.age);final oldestPerson = people.maxBy((person) =&gt; person.age); 对于空集合，它将返回 null。 如果收集项目实现了 Comparable，则可以应用不带选择器的方法: 123final min = list.min();final max = list.max(); 你也可以很容易地得到平均值: 12345final average = list.average();// andfinal averageAge = people.averageBy((person) =&gt; person.age); 以及 num 集合或 num 项属性的总和: 12345final sum = list.sum();// andfinal totalChildrenCount = people.sumBy((person) =&gt; person.childrenCount); Filtering out null itemsWith plain Dart: 1final nonNullItems = list.where((x) =&gt; x != null).toList(); 使用 dartx 可以: 1final nonNullItems = list.whereNotNull().toList(); More useful extensions在 dartx 中还有其他有用的扩展。这里我们不会深入讨论更多细节，但是我希望命名和代码是不言自明的。 joinToString123456final report = people.joinToString( separator: '\\n', transform: (person) =&gt; '$&#123;person.firstName&#125;_$&#123;person.lastName&#125;', prefix: '&lt;&lt;️', postfix: '&gt;&gt;',); all (every) / none123final allAreAdults = people.all((person) =&gt; person.age &gt;= 18);final allAreAdults = people.none((person) =&gt; person.age &lt; 18); first / second / third / fourth collection items1234final first = list.first;final second = list.second;final third = list.third;final fourth = list.fourth; takeFirst / takeLast123final youngestPeople = people.sortedBy((person) =&gt; person.age).takeFirst(5);final oldestPeople = people.sortedBy((person) =&gt; person.age).takeLast(5); firstWhile / lastWhile123456789final orderedPeopleUnder50 = people .sortedBy((person) =&gt; person.age) .firstWhile((person) =&gt; person.age &lt; 50) .toList();final orderedPeopleOver50 = people .sortedBy((person) =&gt; person.age) .lastWhile((person) =&gt; person.age &gt;= 50) .toList(); 总结Dartx 包包含了许多针对 Iterable、 List 和其他 Dart 类型的扩展。探索其功能的最佳方式是浏览源代码。 https://github.com/leisim/dartx 感谢软件包作者 Simon Leier 和 Pascal Welsch。 https://www.linkedin.com/in/simon-leier/ https://twitter.com/passsy © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"使用 Flutter WEB 实现桌面 GUI 第1部分 介绍","date":"2021-05-23T16:00:00.000Z","path":"2021/05/24/translation/desktop-gui-implementation-using-flutter-web-part-1-introduction/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://achraf-feydi.medium.com/desktop-gui-implementation-using-flutter-web-part-1-introduction-42d21a6e7937 演示https://www.fluttergui.com/ 代码https://github.com/achreffaidi/FlutterGUI 参考 https://pub.dev/packages/flutter_treeview https://pub.dev/packages/reorderables https://pub.dev/packages/video_player https://pub.dev/packages/flutter_simple_calculator https://pub.dev/packages/photo_view https://pub.dev/packages/maze https://pub.dev/packages/flutter_widget_from_html_core https://pub.dev/packages/native_pdf_view https://pub.dev/packages/painter 正文Why FlutterGUI?作为 flutter2 的一部分，flutter 已经宣布，flutter 的网络支持已达到稳定的里程碑。 这不仅意味着我终于可以停止编写 HTML 和 CSS 代码，而且我现在可以拥有一个可以在几乎所有流行平台上运行的应用程序。 我对 Flutter Web 的稳定版本并没有太多期待，因为我已经尝试了 Beta 版，而且大多数插件都没有足够的支持。但是回到两周前，我对目前支持 WEB 的插件的数量感到惊讶。 这促使我去尝试一些有挑战性的东西，创建一个桌面图形用户界面使用颤振网络作为我的新的投资组合网站。 坦率地说，这个项目本身并不是什么有用的东西，它不是在解决问题，而且很可能也不是我下一个十亿美元的想法。但是，这是最好的方式来发现的优势和局限性颤振网络使用在一个网络项目。说实话，我想我至少要花两个月的时间来发布第一个版本。 在这个项目上花了两个星期的时间，每晚工作两个小时左右，我最终得到了一些真正值得出版的东西。 尽管我没有阅读任何文档，也没有像平时那样频繁地用谷歌搜索东西，但我还是对这种简单流畅的体验感到惊讶。从使用 Flutter 手机开发到网络的转变真的很简单，而且我在这个项目中学到的关于网络开发的知识并不需要使用任何东西。 Technical overview Project 现在有 8 个应用程序运行在它里面，正如你已经猜到的: 它是所有的小部件。 大多数应用程序是现有的颤振插件，包装在我创建的通用应用部件内部。 这个码头是从零开始建造的，因为我找不到一个能满足我需要的现有码头。 项目没有后端，Flutter Web 应用程序托管在 Github 页面上。 我正在使用 Firebase 分析跟踪用户的互动与应用程序。 Apps 文件管理器: 用 flutter_treeview 颤振树景 and 及 reorderables 可调整的 plugins. 插件 https://pub.dev/packages/flutter_treeview https://pub.dev/packages/reorderables 视频播放器: 使用 video_player 视频播放器 plugin. 插件 https://pub.dev/packages/video_player 计算器: 使用 flutter_simple_calculator 简单计算器 plugin. 插件 https://pub.dev/packages/flutter_simple_calculator 照片: 使用 photo_view 照片查看 plugin. 插件 https://pub.dev/packages/photo_view 游戏: 使用 Maze 梅兹 plugin. 插件 https://pub.dev/packages/maze 阅读器: 使用 flutter_widget_from_html_core 从 html 核心 plugin. 插件 https://pub.dev/packages/flutter_widget_from_html_core PDF 阅读器: 使用 native_pdf_view 本地 pdf 查看 plugin. 插件 https://pub.dev/packages/native_pdf_view 画家: 使用 painter 画家 plugin. 插件 https://pub.dev/packages/painter © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"在 Dart 和 Flutter 中探索异步编程","date":"2021-05-20T16:00:00.000Z","path":"2021/05/21/translation/exploring-asynchronous-programming-in-dart-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://medium.com/flutterdevs/exploring-asynchronous-programming-in-dart-flutter-25f341af32f 正文 异步编程是一种相等的编程类型，它允许一个工作单元独立于基本的应用程序线程运行。当工作完成时，它告诉主线程。在 Flutter 结构中可访问的 UI 小部件利用 Dart 的异步编程亮点来达到非同寻常的效果，帮助保持代码的协调性，并防止 UI 在客户端上的安全性。 在这个博客中，我们将探索在 Dart &amp; Flutter 中的异步编程。我们将看看异步代码模式如何帮助准备用户交互和从网络恢复数据，并在您的 Flutter 应用程序中看到几个异步 Flutter 小部件的行动。 异步编程它是一种在编程周期中附加在事件链上的相等执行类型。对于那些刚刚接触异步编程的人来说，这是另一种加速改进周期的技术。尽管如此，我们不能在所有实例上使用异步编程。当你在寻找直率而不是生产力的时候，它是有效的。为了处理基本的、自治的信息，异步编程是一个非同寻常的决定。 various perspectives 是理想的对应物 Flutter 从各种角度，在任何事件，为异步编程。即使 Dart 是单线程的，它也可以与不同的代码相关联，这些代码运行在不连续的线程中。使用 Dart 中的同步代码会造成延迟并阻碍整个程序的执行。尽管如此，异步编程解决了这个问题。此外，这提示改进了应用程序的执行和应用程序的响应性。 为什么我们应该使用异步编程面是异步编程的一些应用: 改善工作表现及提高工作效率 反应性. 你的应用程序，特别是当你有长期运行的活动，不需要阻止执行。对于这种情况，您可以在等待长期任务的结果的同时执行其他工作 以一种完美的、易于理解的方式组装代码，从根本上比传统线程创建的标准代码更好，并且更好地处理代码，你编写更少的代码，你的代码将比利用过去的异步编程策略，如利用纯赋值更可行 您可以使用语言高亮部分的最新升级，如 async / await was presented in a flutter. 在一阵颤动中显现出来 对元素进行了一些改进，比如对每个 async 进行了改进，对 async 类型进行了总结，比如 Value. Future未来的工作方式基本上与 Javascript 中的 Promise 相同。它有两个表达是未完成和已完成。完成的未来要么有价值，要么有错误。未完成的未来是等待函数的异步活动完成或抛出错误。 这个类有几个构造函数: Future. 意味着将 Duration 对象作为展示延迟后执行的时间跨度和函数的竞争对象 编码内存缓存意味着在内存中以原始状态存储压缩图片 Future. 意味着使未来以错误结束 使用 Await/AsyncDart 中的异步和等待方法基本上与不同的方言相同，但是，不管您是否对异步编程利用异步/等待有所了解，您都应该认为在这里很容易理解。 =&gt; Async 函数: 函数构成了异步编程的基础。这些异步函数的主体中有异步修饰符。下面是一个关于综合异步工作的例子: 123void flutter() async &#123; print('Flutter Devs');&#125; =&gt; Await 表达式: 它使您编写异步代码就像它是同步的一样。总而言之，等待发音具有下面给出的结构: 1234void main() async &#123; await flutter(); print('flutter Devs done');&#125; 用户交互事件也许异步处理用户输入的最简单模型是用回调来响应按钮小部件上的连接事件: 123456FlatButton( child: Text(\"Data\"), onPressed: () &#123; print(\"pressed button\"); &#125;,) 和大多数 Flutter 组件一样，FlatButton 组件提供了一个舒适的界面，称为 onPressed，用于响应速度快的按钮。在这里，我们已经将一个神秘的回调容量传递给了边界，它除了向控制台打印消息之外什么也不做。当客户端按下 catch 时，onPressed 事件被关闭，当偶然循环可以到达时，将执行未知函数。 在后台，有一个事件流，每次向其添加另一个事件时，都会使用任何相关信息调用回调工作。对于这种情况，基本的 catch 按钮没有相关信息，因此回调没有边界。 使用回调的异步网络调用也许异步编程最著名的例子包括通过网络获取信息，例如，通过 HTTP 上的 REST 服务: 12345import 'package:http/http.dart' as http;final future = http.get(\"https://flutterdevs.com\");future.then((response) &#123; if (response.statusCode == 200) &#123; print(\"Response received.\"); &#125;&#125;); Http 包是 Dart 的包回购中最著名的一个，Pub。我在这里合并了一个导入断言，以引起对使用作为关键字的 http 名称命名导入的平均例子的注意。这些助手保持包的许多高级函数、常量和因子不与您的代码发生冲突，就像澄清像 get ()这样的函数从何而来一样。 代码模型展示了吞噬未来的经典例子。当调用 http.get ()时，对它的调用立即返回一个不适当的 Future 示例。回想一下，通过 HTTP 获得结果需要很大的能量，我们不需要在旁观时让应用程序保持惰性。这就是我们立即将未来移回来并继续执行以下代码行的原因。这些下一行使用了 Future 示例的 at that then ()策略来获得一个回调函数，这个回调函数迟早会在 REST 反应出现时执行。万一不可避免的响应 HTTP 状态码为 200(成功) ，我们可以向调试控制台打印一条直截了当的消息。 我们把这个例子改进一下怎么样。这个模型将未来存储在最后一个变量中，然后得到 then () ，但是除非你有一个有效的理由来保留这个未来案例，否则跳过这个部分是平均的，就像在相应的模型中一样: 12345678http.get(\"https://flutterdevs.com\").then((response) &#123; if (response.statusCode == 200) &#123; print(\"Response received.\"); &#125; else &#123; print(\"Response not received\"); &#125;&#125;); 由于对 get ()的调用会对 Future 采取步骤，因此您可以直接调用它的 then ()策略，而不需要在变量中保存将来的引用。这些代码在这些行上稍微简化了一点，但同时又可以破译。将一些有价值的回收注册链接到我们的未来是可行的，例如: 123456789101112http.get(\"https://flutterdevs.com\").then((response) &#123; if (response.statusCode == 200) &#123; print(\"Response received.\"); &#125; else &#123; print(\"Response not received\"); &#125;&#125;).catchError(() &#123; print(\"Error!\");&#125;).whenComplete(() &#123; print(\"Future complete.\");&#125;); 目前我们已经设置了一个回调函数，当 HTTP 调用关闭时将执行一个错误，而不是使用 catchError 的响应，另一个回调函数将运行时不会考虑未来如何利用 whenComplete ()完成。这种搭售的技巧是可以想象的，因为每一种策略都会给我们的未来带来参考。 没有回调的异步网络调用Dart 提供了一个解决异步调用的替代例子，这个例子看起来更像习惯的同步代码，它可以使仔细阅读和推理变得更加简单。异步/等待标点符号为你处理了大量的未来物流: 1234Future&lt;String&gt; getData() async &#123; final response = await http.get(\"https://flutterdevs.com\"); return response.body;&#125; 当您意识到将在函数内部执行异步调用时，例如 http.get () ，您可以使用 async 关键字对函数进行戳记。异步工作一致地返回未来，您可以利用其主体中的 await 关键字。对于这种情况，我们认识到 REST 调用将返回字符串信息，因此我们在返回类型上使用泛型来表示: Future &lt; string &gt; 。 你可以等待任何返回未来的函数。getData ()函数将在等待清晰运行之后挂起执行，并将未来返回给调用者。代码紧密地等待反应; 它等待网络调用的未来完成。然后，当反应出现荒谬时，执行继续，并将 Response 对象指定为最后一个因子，然后 getData ()返回 Response.body，这是一个字符串。您不必从 getData ()中明确返回 future，因为这样做的结果是返回了 await 的主要用途。当你有了字符串信息，你返回它，然后达特用价值结束未来。 为了在使用 await 时捕捉错误，你可以使用 Dart 的标准 try/catch 包括: 12345678Future&lt;String&gt; getData() async &#123; try &#123; final response = await http.get(\"https://flutterdevs.com\"); return response.body; &#125; catch (excute) &#123; print(\"Error: $excute\"); &#125;&#125; 在这个版本中，我们放置的代码，可以抛出豁免到 try 块。在一切都很容易的情况下，我们将得到一个响应并返回字符串信息，类似于在早期模型中。如果出现错误，catch 块将执行所有考虑过的内容，并向我们传递一个对豁免的引用。由于我们没有向 getData ()的最大限度添加明确的返回公告，Dart 将在那里添加一个特定的返回 null 语句，这将以 null 值结束未来。 请注意，如果网络调用成功，则在 try 块中会发生返回，因此不会调用隐含的返回。 回调函数有它们的用途，并且它们可以成为处理简单情况下的异步通信的一种特殊方法，例如，响应一个客户机挤压捕获。对于更多混乱的情况，例如，当你需要安排一些异步调用，每个异步调用都依赖于先前调用的结果，Dart 的异步/等待语法结构可以帮助你尽量不去安排回调，这里或那里暗指回调地狱之火。 FutureBuilder一个 FutureBuilder 根据给定的未来条件来组装自己。对于这个模型，我们应该期望您有一个名为 getData ()的函数，它返回 Future &lt; string &gt; 。 123456789101112131415class MyStatelessWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return FutureBuilder( future: getData(), builder: (BuildContext context, AsyncSnapshot snapshot) &#123; if (snapshot.connectionState == ConnectionState.waiting) &#123; return CircularProgressIndicator(); &#125; if (snapshot.hasData) &#123; return Text(snapshot.data); &#125; return Container(); &#125;, ); &#125;&#125; 这个定制的无状态小部件返回一个 FutureBuilder，如果 getData ()返回的 future 还没有结束，它将显示一个 advancement 指针，如果 future 已经结束，它将显示这个信息。万一这两样东西都不正确，一个空的容器就会被全面考虑。你建议 FutureBuilder 关注未来的边界，这时给它一个每次修改都需要的构建工作。构建回调获得典型的 BuildContext 争用，这是所有 Flutter 构建活动的正常情况，它同样获得 AsyncSnapshot 的出现，您可以使用 AsyncSnapshot 检查未来的状态并恢复任何信息。 这种方法有一个问题。根据 FutureBuilder 的官方文档，在构建步骤之前已经准备好了未来的必需品。 为了解决这个问题，我们需要使用一个有状态小部件来代替: 123456789101112131415161718192021class MyStatefulWidget extends StatefulWidget &#123; @override _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();&#125;class _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; &#123; Future&lt;String&gt; _dataFuture; @override void initState() &#123; super.initState(); _dataFuture = getData(); &#125; @override Widget build(BuildContext context) &#123; return FutureBuilder( future: _dataFuture, builder: (BuildContext context, AsyncSnapshot snapshot) &#123; if (snapshot.connectionState == ConnectionState.waiting) &#123; return CircularProgressIndicator(); &#125; if (snapshot.hasData) &#123; return Text(snapshot.data); &#125; return Container(); &#125;, ); &#125;&#125; 这个小部件的改编在 initState ()期间获得了未来的信息。创建小部件的状态对象时，将精确地调用 initState ()技术一次。 StreamBuilder流类似于事件管道。信息或错误事件朝向一边，它们被传递给另一边的侦听器。当您为 StreamBuilder 提供对当前流的引用时，它会因此订阅和提取，以刷新至关重要的内容，并且它依赖于需要成为管道的任何信息来组装自己。 123456789101112131415class MyStatelessWidget extends StatelessWidget &#123; final Stream&lt;String&gt; dataStream; const MyStatelessWidget(&#123;Key key, this.dataStream&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return StreamBuilder&lt;ConnectionState&gt;( stream: dataStream, builder: (BuildContext context, AsyncSnapshot&lt;ConnectionState&gt; snapshot) &#123; if (snapshot.connectionState == ConnectionState.waiting) &#123; return CircularProgressIndicator(); &#125; if (snapshot.hasData) &#123; return Text(snapshot.data); &#125; return Container(); &#125;, ); &#125;&#125; 总结本文介绍了 Flutter 基本结构的“dart 与 Flutter 中的异步编程”，您可以根据自己的选择修改该代码。这是一个小的介绍在 dart 和 flutter 异步编程用户交互从我这边，它的工作使用 flutter。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 2.2 升级了哪些东西？","date":"2021-05-19T16:00:00.000Z","path":"2021/05/20/translation/whats-new-in-flutter-2-2/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://medium.com/flutter/whats-new-in-flutter-2-2-fd00c65e2039 正文2.2 的发布侧重于改进和优化，包括 iOS 性能的提升，Android 延迟组件，为 Flutter web 更新服务工作者等等！ 今天是我们让 Flutter 2.2 可用的日子。您可以通过切换到 stable 通道并升级当前的 Flutter 安装，或者转到 Flutter.dev/docs/get-started 来启动新的安装。 尽管距离 Flutter 2 发布只有几个月的时间，我们在 2.2 中还是有很多改进可以分享。这个版本合并了 2,456 个 PRs，关闭了框架、引擎和插件库中的 3,105 个问题。特别大声呼吁 Flutter 社区在广大提供了大量的公关和公关审查，包括 Abhishek01039 谁贡献了最多的 PRs (17)和 xu-baolin，谁审查了最多的 PRs (9) Flutter 2.2。感谢所有贡献者的帮助，使 Flutter 2.2 的稳定通道。没有你我们做不到。 每一个 Flutter 发布到 stable 的新版本都会带来一组新的更新，无论是性能增强、新特性还是 bug 修复。此外，一个版本还包括一些尚未准备好投入生产使用的特性，但我们希望您能够验证它们是否按照您希望的方式工作。最后，每个新版本都附带了一组来自更大的 Flutter 社区的相关工具更新和更新。老实说，最近 Flutter 的每一个新版本都发生了很多事情，我们无法在一篇博客文章中合理地捕捉到所有的内容，但是我们会尽量突出重点。 在 stable 下 Flutter 2.2 更新这个版本涵盖了 Flutter 2 之上的一系列改进，包括跨 Android，iOS 和 web 的更新，新材质图标，文本处理更新，滚动条行为，以及对 TextSpan 小部件的鼠标光标支持，以及如何从单一源代码库中最好地支持多种平台的新指南。所有这些特性现在都可以稳定地使用，并且可以在生产应用程序中使用。它们都是建立在一个新的 Dart 释放上的。 Dart 2.13Flutter 2.2 带有 Dart 2.13 版本。除此之外，这次 Dart 更新包含了一个新的类型别名功能，它可以让你为类型和函数创建别名: 123456789// Type alias for functions (existing)typedef ValueChanged&lt;T&gt; = void Function(T value);// Type alias for classes (new!)typedef StringList = List&lt;String&gt;;// Rename classes in a non-breaking way (new!)@Deprecated(\"Use NewClassName instead\")typedef OldClassName&lt;T&gt; = NewClassName&lt;T&gt;; 类型别名可以为长而复杂的类型提供很好的短名称，它还允许您以非破坏性的方式重命名类。在 Dart 2.13 中还有更多的新功能，请查看 Dart 2.13 发布公告中的详细信息。 https://medium.com/dartlang/announcing-dart-2-13-c6d547b57067 Flutter web 更新Flutter 最新的稳定平台 web 已经在这个版本中得到了改进。 首先，我们使用新的服务工作者加载机制优化了缓存行为，并修复了 main.dart.js 的双重下载。在 Flutter web 的早期版本中，服务工作者在后台下载更新到您的应用程序，同时让您的用户访问您的应用程序的陈旧版本。一旦更新被下载，用户将不会看到这些更改，直到他们刷新浏览器页面几次。在 Flutter 2.2 中，当新的服务工作者检测到一个变化时，用户会等到更新被下载后才能使用这个应用程序，但是之后他们会看到更新，而不需要第二次手动刷新页面。 启用此更改需要您重新生成您的 Flutter 应用程序的 index.html。要做到这一点，保存修改，删除 index.html，然后运行 flutter create。在你的项目目录中重新创建它。 我们还对这两个网页渲染器进行了改进。对于 HTML，我们添加了对字体特性的支持，以支持设置 FontFeature，并使用 canvas api 呈现文本，以便文本在鼠标悬停时出现在正确的位置。对于 HTML 和 CanvasKit，我们增加了对着色遮罩和 computelinetrics 的支持，解决了 Flutter web 和移动应用之间的平价差距。例如，开发人员现在可以使用不透明遮罩来使用着色遮罩执行淡出过渡，并且可以像使用移动应用程序一样使用 computelinetrics。 对于 Flutter 网页，以及 Flutter general，可访问性是我们的最高优先事项之一。根据设计，Flutter 通过构建 SemanticsNode 树来实现可访问性。一旦 Flutter web 应用用户启用了可访问性，框架就会生成一个与 RenderObject DOM 树并行的 DOM 树，并将语义属性转换为 Aira。在这个版本中，我们改进了语义节点的位置，以便在使用转换时缩小移动和桌面 web 应用程序之间的差距，这意味着当小部件使用转换设计时，焦点框应该正确地出现在元素上。要看到这个效果，请看 Victor Tsaran 的视频，他领导了材料设计的可访问性项目，使用 VoiceOver with Flutter Gallery App: 我们还公开了语义节点调试树，在概要文件和释放模式中有一个命令行标志，通过可视化为 web 应用程序创建的语义节点来帮助开发人员调试可访问性。 为了使你自己的 Flutter web 应用程序能够使用这个功能，运行以下命令: 12$ flutter run -d chrome --profile \\ --dart-define=FLUTTER_WEB_DEBUG_SHOW_SEMANTICS=true 激活该标志后，您将能够看到小部件顶部的语义节点，这样您就可以调试并查看语义元素是否放置在不应该放置的位置。如果你找到这样的例子，请不要犹豫，提交一份错误报告。 https://goo.gle/flutter_web_issue 虽然我们在支持一组核心可访问性特性方面取得了重大进展，但我们将继续改进可访问性支持。在 2.2 稳定版之外的主版和开发版渠道中，我们增加了一个 API，让开发者可以通过编程方式自动启用应用程序的可访问性，并通过使用带有屏幕阅读器的 Tab 解决问题。 最后，但肯定不是最不重要的，最新版本的 Flutter DevTools 现在支持您的 Flutter 网络应用程序的布局浏览器。 这个更新给你提供了和你的移动和桌面应用程序一样的网页布局调试工具。 iOS 页面转换和增量安装对于 iOS，在这个版本中，我们通过减少 75% 渲染动画画面所需的时间，使 Cupertino 的页面转换更加流畅，而且可能在低端手机上更多。我们不只是寻找最终用户性能的改进，我们也一直在寻找提高开发性能的方法。 在这个版本中，我们在开发过程中实现了增量的 iOS 安装。在我们的基准测试中，我们发现安装升级版 iOS 应用程序的时间减少了 40% ，这样在测试应用程序更改时就会减少周转时间。 使用 Flutter 构建平台自适应应用程序随着 Flutter 扩展到支持更多稳定的平台，考虑不仅支持不同形式因素的应用程序变得很有用，比如移动设备、平板电脑和桌面，还有不同的输入类型(触摸和鼠标 + 键盘)和带有不同习惯用法的平台，比如导航抽屉和导航系统菜单。我们把能够根据不同目标平台的细节进行调整的应用称为“平台自适应”应用。 为了介绍在构建平台自适应应用程序时需要注意的事项，我们将向您介绍 Kevin Moore 的构建平台自适应应用程序会议。要了解更多详细信息，请查看 flutter.dev 上的平台自适应应用程序指南。 构建平台自适应应用https://events.google.com/io/session/868dfd56-7f8c-49ee-84ad-ac69a23ba19d?lng=en 指南https://flutter.dev/docs/development/ui/layout/building-adaptive-apps 最后，对于根据这些原则为多个平台编写的示例应用程序，我们推荐来自 gSkinner 的 Flokk 和 Flutter Folio 应用程序。你可以下载 Flokk 和 Folio 的代码，也可以从各种应用程序商店下载 Flokk 和 Folio，或者直接从浏览器上运行它们。另一个很好的例子是用于创建指南本身的应用程序: https://flutter.gskinner.com/flokk https://flutter.gskinner.com/folio https://flutter.gskinner.com/flokk/#g-download https://github.com/gskinnerTeam/flutter-folio Flutter 平台自适应应用指南的 UX 部分是基于新的大屏幕材料指南。这个来自 Material 团队的新指导包括几个主要布局文章的返工，以及对几个组件的更新和更新的设计工具包，所有这些都考虑到了大屏幕。 https://material.io/blog/material-design-for-large-screens Flutter 的目标一直是让应用程序不仅仅在多个平台上运行; 我们还要等到你的应用程序在所有你的目标平台上运行良好之后才能完成。的支持不仅可以针对多个平台的应用程序，还可以根据屏幕大小、输入模式和每个平台的习惯调整应用程序。 更多 Material 图标关于 Material guidance 的主题，在这个版本中，我们已经为 Flutter 添加了不止一个而是两个新的 Material 图标，包括一个 Dash 自己的图标！ https://github.com/flutter/flutter/pull/78311 这些更新使你的应用程序的材质图标总数超过 7000 个。如果你很难找到你想要的图标，那么在那些令人尴尬的财富中(谁不会呢?)你可在此 fonts.google.com/icons 按类别及姓名搜寻。 http://fonts.google.com/icons 按名称搜索 Flutter 材质图标 一旦你找到了完美的图标，新的“ Flutter”标签会告诉你如何使用它，或者你可以下载这个图标作为应用程序中的独立资产。添加 Dash 到您的 Flutter 应用程序从来没有这么容易。 改进的文本处理随着我们继续改进 Flutter 以支持每个平台的细节，我们继续推进新的领域，这些领域在移动表单因素上不像在桌面表单因素上那么重要。其中一个领域是文本处理。在这个版本中，我们已经开始重构我们如何处理文本输入，以实现诸如取消在小部件层次结构中冒泡的击键等功能，并通过引入完全自定义与文本动作相关的击键功能。 能够取消击键使得 Flutter 能够在不触发滚动事件的情况下实现诸如使用空格键和箭头键之类的东西，给你的最终用户一个更直观的体验。您可以使用同样的功能来处理击键，然后再将其发送到您自己的应用程序中的父窗口部件。另一个例子是，在这个版本中，你可以在 TextField 和 Flutter 应用程序中的一个按钮之间选择 Tab，而且它正常工作: 1234567891011121314151617181920212223import 'package:flutter/material.dart';void main() =&gt; runApp(App());class App extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; MaterialApp( title: 'Flutter Text Editing Fun', home: HomePage(), );&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; Scaffold( body: Column( children: [ TextField(), OutlinedButton(onPressed: () &#123;&#125;, child: const Text('Press Me')), ], ), );&#125; Flutter 2.2 可以取消冒出窗口部件层次结构的击键，例如允许 TAB 从 TextField 更改焦点 自定义文本操作允许你做一些事情，比如在 TextField 中特殊处理 Enter 键; 例如，你可以触发在聊天客户端发送消息，同时仍然允许通过 Ctrl + Enter 插入一个新行。这些相同的文本操作允许 Flutter 本身提供不同的按键来匹配主机 OS 本身的文本编辑行为，例如，在 Windows 和 Linux 上使用 Ctrl + c，而在 macOS 上使用 Cmd + c。 https://github.com/flutter/flutter/pull/75032 作为一个例子，下面的示例重写了默认的左箭头操作，并为退格键和删除键提供了一个新的操作: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import 'package:flutter/material.dart';import 'package:flutter/services.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; MaterialApp( title: 'Flutter TextField Key Binding Demo', home: Scaffold(body: UnforgivingTextField()), );&#125;/// A text field that clears itself if the user tries to back up or correct/// something.class UnforgivingTextField extends StatefulWidget &#123; @override State&lt;UnforgivingTextField&gt; createState() =&gt; _UnforgivingTextFieldState();&#125;class _UnforgivingTextFieldState extends State&lt;UnforgivingTextField&gt; &#123; // The text editing controller used to clear the text field. late TextEditingController controller; @override void initState() &#123; super.initState(); controller = TextEditingController(); &#125; @override Widget build(BuildContext context) =&gt; Shortcuts( shortcuts: &lt;LogicalKeySet, Intent&gt;&#123; // This overrides the left arrow key binding that the text field normally // has in order to move the cursor back by a character. The default is // created by the MaterialApp, which has a DefaultTextEditingShortcuts // widget in it. LogicalKeySet(LogicalKeyboardKey.arrowLeft): const ClearIntent(), // This binds the delete and backspace keys to also clear the text field. // You can bind any key, not just those already bound in // DefaultTextEditingShortcuts. LogicalKeySet(LogicalKeyboardKey.delete): const ClearIntent(), LogicalKeySet(LogicalKeyboardKey.backspace): const ClearIntent(), &#125;, child: Actions( actions: &lt;Type, Action&lt;Intent&gt;&gt;&#123; // This binds the intent that indicates clearing a text field to the // action that does the clearing. ClearIntent: ClearAction(controller: controller), &#125;, child: Center(child: TextField(controller: controller)), ), );&#125;/// An intent that is bound to ClearAction.class ClearIntent extends Intent &#123; const ClearIntent();&#125;/// An action that is bound to ClearIntent that clears the TextEditingController/// passed to it.class ClearAction extends Action&lt;ClearIntent&gt; &#123; ClearAction(&#123;required this.controller&#125;); final TextEditingController controller; @override Object? invoke(covariant ClearIntent intent) &#123; controller.clear(); &#125;&#125; 按左箭头或 ESC 可以清除文本 我们仍然有更多的工作要做，但我们正在努力给你提供完整的文本编辑操作。我们的目标是，当 Flutter 桌面变得稳定时，你的用户将无法分辨出 Flutter 应用程序中编辑文本与主机操作系统中其他应用程序之间的区别。 自动滚动行为作为我们持续追求的一部分，让 Flutter 应用在每个平台上都表现得像最好的应用一样，我们在这个版本中重新审视了滚动条。当实际显示滚动条时，安卓和 iOS 是相同的; 默认情况下它们不显示滚动条。另一方面，对于桌面应用程序，当内容大于容器时，通常会自动显示滚动条，这需要您添加一个滚动条父窗口小部件。为了在移动或桌面上获得正确的行为，此版本在必要时自动添加滚动条。 考虑下面的无滚动条代码: 123456789101112131415161718192021import 'package:flutter/material.dart';void main() =&gt; runApp(App());class App extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; MaterialApp( title: 'Automatic Scrollbars', home: HomePage(), );&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; Scaffold( body: ListView.builder( itemCount: 100, itemBuilder: (context, index) =&gt; Text('Item $index'), ), );&#125; 在桌面上运行时，会出现一个滚动条: 如果您不喜欢滚动条的外观，或者总是显示滚动条，那么可以设置 ScrollBarTheme。如果您不喜欢这种默认行为，可以通过设置 ScrollBehavior 在应用程序范围内或在特定实例上更改它。有关新的默认滚动条行为以及如何将代码迁移到新的最佳实践集的更多细节，请查看 flutter.dev 上的文档。 https://flutter.dev/docs/release/breaking-changes/default-desktop-scrollbars 鼠标 cursors over text spans在以前的 Flutter 版本中，您可以在任何小部件上添加一个鼠标光标(就像一只手指示可点击的东西)。实际上，Flutter 本身在大多数情况下为您添加那些鼠标光标，比如在所有按钮上添加一个手动鼠标光标。然而，如果你想要一系列富文本，它们具有不同的文本跨度和各自的样式，并且可能有足够长的时间来包装，那么你就不太走运了ーー TextSpan 不是一个小部件，因此不能用作鼠标光标的视觉范围… … 直到现在！在这个版本中，当你有一个带有手势识别器的 TextSpan 时，你将自动获得相应的鼠标光标: 123456789101112131415161718192021222324252627282930313233343536373839404142import 'package:flutter/gestures.dart';import 'package:flutter/material.dart';import 'package:url_launcher/url_launcher.dart' as urlLauncher;void main() =&gt; runApp(App());class App extends StatelessWidget &#123; static const title = 'Flutter App'; @override Widget build(BuildContext context) =&gt; MaterialApp( title: title, home: HomePage(), );&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar(title: Text(App.title)), body: Center( child: RichText( text: TextSpan( style: TextStyle(fontSize: 48), children: [ TextSpan( text: 'This is not a link, ', style: TextStyle(color: Colors.black), ), TextSpan( text: 'but this is', style: TextStyle(color: Colors.blue), recognizer: TapGestureRecognizer() ..onTap = () &#123; urlLauncher.launch('https://flutter.dev'); &#125;, ), ], ), ), ), );&#125; 现在您可以拥有所需的所有包装文本跨度，并且其中任何带有识别器的文本都将获得适当的鼠标游标。 在这个版本中，TextSpan 还支持 onEnter 和 onExit 以及 mouseCursor。像这样的东西可能看起来很小，但他们有很长的路要走，使 Flutter 应用程序感觉就像用户期望它的感觉。 Flutter 2.2 updates in preview除了可用于产品的新功能外，Flutter 2.2 在预览版中提供了一些功能，包括 iOS 着色器编译器性能的改进，Android 延迟组件支持，Flutter 桌面更新，以及索尼的 ARM64 Linux 主机支持。请尝试一下，如果有任何问题请告诉我们。 http://github.com/flutter/flutter/issues Preview: iOS 着色器编译改进在图形渲染术语中，“着色器”是一个在终端用户设备上可用的 GPU 上编译和运行的程序。自 Skia 图形库诞生以来，Flutter 就一直使用着色器来提供高质量的图形效果，包括颜色、阴影、动画等等。由于 Flutter 的 api 的灵活性，着色器生成和编译实时，与帧工作负载需要他们同步。当编译着色器的时间超过帧预算时，结果对用户来说是显而易见的“ jank” 为了避免混乱，Flutter 提供了在训练过程中缓存着色器的能力，然后打包并捆绑一个应用程序，在第一帧之前编译，同时 Flutter 引擎启动。这意味着预编译的着色器不必在框架工作负载期间进行编译，也不会造成混乱。然而，Skia 最初只在 OpenGL 中实现了这个特性。 因此，当我们在 iOS 上默认启用 Metal 后端以回应苹果不推荐使用 OpenGL 时，根据我们的基准测量，最糟糕的帧时间有所增加，而且用户报告的 jank 也有所增加。我们自己的测量表明，这些报告通常是由于增加了着色器编译时间，增加了 Skia 为 Metal 后端生成的着色器数量，以及编译的着色器无法在运行过程中缓存，以至于 jank 在第一次运行应用程序之后仍然存在。 因此，到目前为止，避免 iOS 上这种混乱的唯一方法是简化场景和动画，这并不理想。 https://github.com/flutter/flutter/issues/79298 然而，现在在开发通道是一个预览的新支持在 Skia 的着色器热身的金属。通过 Skia，Flutter 现在编译绑定着色器之前的第一帧工作量开始。 跟踪显示在应用程序启动期间发生的预编译 然而，这个解决方案也有一些警告: Skia 仍然为 Metal 后端生成比 OpenGL 后端更多的着色器 最终的着色器编译到机器代码仍然与框架工作负载同步进行，但这比作为框架渲染时间的一部分进行整个着色器生成和编译要快 生成的机器代码在应用程序第一次运行后被缓存，直到设备重新启动 如果您希望利用应用程序中的这种新支持，可以按照 flutter.dev 上的说明进行操作。 https://flutter.dev/docs/perf/rendering/shader#how-to-use-sksl-warmup We’re not done with this work, however. On both Android and iOS, this implementation has a few drawbacks: 然而，我们还没有完成这项工作，无论是在安卓还是 iOS 上，这个实现都有一些缺点: 部署应用程序的大小更大，因为它包含捆绑着色器 应用程序启动延迟更长，因为捆绑着色器需要预编译 我们对这种实现所暗示的开发人员的体验并不满意 我们认为最后一个问题是需要解决的最重要问题。特别是，我们查看了执行训练运行的过程，并推理由应用程序大小和应用程序启动延迟造成的权衡过于繁重。因此，我们继续研究如何消除不依赖于此实现的着色器编译 jank 和一般的所有 jank。特别是，我们正在与 Skia 团队合作，以减少它响应 Flutter 的要求所产生的着色器的数量，同时也在调查使用与 Flutter 引擎捆绑在一起的一小套静态定义着色器可以实现多少 Flutter。 你可以跟随这个项目在 Flutter 回购看到我们的进展。 Android 延迟组件对于 Android，这个版本使用了 Dart 的分离 AOT 编译特性，允许 Flutter 应用程序在运行时下载包含提前编译代码和资源的模块。我们将这些可安装的组件中的每一个称为延迟组件。通过将代码和资产的下载推迟到仅在需要时进行，初始安装大小可以显著减少。例如，我们实现了 Flutter Gallery 的一个版本，所有的研究和演示都被推迟了，发现初始安装规模减少了 46% 。 https://github.com/flutter/flutter/pull/76192 在启用延迟组件的情况下进行构建时，Dart 会将只使用 deferred 关键字导入的代码编译成单独的共享库，这些库与资产一起打包到延迟组件中。 延迟组件目前只能在 Android 上使用，这个特性是作为早期预览提供的。了解如何在 flutter.dev 上的新 Deferred 组件页面中实现 Deferred 组件。这个页面还链接到 Flutter 维基上的一个页面，该页面包含了关于这个功能如何工作的深入介绍。请在 Flutter 问题跟踪日志问题。 Flutter Windows UWP alpha在这个版本中，Flutter 的另一个更新是针对桌面爱好者的; 对 Windows UWP 的支持在 dev 通道中已经转移到 alpha 版本(稳定的 2.2 版本之外)。允许你把 Flutter 应用程序带到标准 Windows 应用程序不能运行的设备上，包括 Xbox。要进行尝试，首先需要设置 UWP 先决条件。然后，切换到开发通道，启用 UWP 支持: https://flutter.dev/desktop#windows-uwp 123$ flutter channel dev$ flutter upgrade$ flutter config — enable-windows-uwp-desktop 一旦启用，创建一个 Flutter 应用程序包括一个新的 winuwp 文件夹，它允许你在 UWP 容器中构建和运行你的应用程序: 1234$ flutter create uwp_fun$ cd uwp_fun$ flutter pub get$ flutter run -d winuwp 因为你正在构建一个 Windows UWP 应用程序，它在 Windows 的沙箱环境中运行，所以在开发过程中，你需要在本地主机上的应用程序防火墙上打一个洞，以启用热重载和调试器断点等功能。你可以通过 checkknesolation 命令按照扑桌面文档页面上的说明做到这一点。一旦你这样做了，你可以看到你最喜欢的 Flutter 应用程序运行作为一个 UWP 应用程序在 Windows 上。 你最喜欢的 Flutter 应用程序在 Windows UWP 容器中运行 当然，你可以运行更多有趣的 UWP 应用程序，比如这些 Flutter 应用程序运行在 Xbox 上。 我要特别感谢克拉克松，自从我加入 Flutter 队以来，他就一直致力于这项支持。有关 Windows UWP alpha 的更多细节，请查看 flutter.dev/desktop/# Windows-UWP。 http://flutter.dev/desktop/#windows-uwp ARM64 Linux host support from Sony另一个来自社区成员 HidenoriMatsubayashi 的杰出努力，他是索尼的软件工程师，为目标 ARM64 Linux 提供了支持。这个 PR 可以让你在 ARM64 Linux 机器上建立和运行 Flutter 应用程序。 您最喜欢的 Flutter 应用程序运行在 ARM64 Linux 机器上 https://github.com/HidenoriMatsubayashi https://github.com/flutter/flutter/pull/61221 很高兴看到 Flutter 社区将 Flutter 带到了 Google 团队无法想象的地方。继续好好干吧！ Flutter 生态系统和工具更新Flutter 引擎和框架只是整体经验的一部分。对软件包生态系统和工具的更新对 Flutter 开发人员的体验同样重要。我们在这些领域有一些很棒的更新可以分享。 在生态系统方面，我们有一些新的 Flutter 最喜欢的软件包，以及 FlutterFire 的几个更新，Flutter 对 Firebase 的支持。更好的是，FlutterFire 支持新的 Firebase App Check 预览，所以 Flutter 开发者可以在第一天就利用它。 在工具方面，Flutter DevTools 提供了新的更新，用于优化应用程序的内存占用和提供程序包的新标签。对于 VS Code 和 Android Studio/IntelliJ 的 IDE 插件都有一些值得注意的更新，如果你是一个以 Flutter 为目标的内容作者，那么有一种全新的方式将 DartPad 整合到你的写作中。 最后但并非最不重要的是，有一个新的低代码的应用程序设计和建设工具称为 FlutterFlow，目标 Flutter 和运行在网络上，因为它本身是建立了 Flutter。 Flutter Favorite updates作为这次发布的一部分，Flutter 生态系统委员会一直在努力认证 24 个新的 Flutter 最喜欢的软件包，我们最大的扩展。最新标记的 Flutter 收藏包括: 正在生产中:cloud_firestore, cloud_functions, firebase_auth, firebase_core, firebase_crashlytics, firebase_messaging, and 及 firebase_storage Flutter Community packages: android_alarm_manager_plus, android_intent_plus, battery_plus, connectivity_plus, device_info_plus, network_info_plus, package_info_plus, sensors_plus, and 及 share_plus googleapis package win32 package intl and 及 characters packages Sentry and sentry_flutter infinite_scroll_pagination and flutter_native_splash packages 所有这些软件包都已经迁移到 null 安全性，并且在适当的情况下支持 Android、 iOS 和 web。例如，firebase crashlytics 在 web 上没有底层的 SDK，Android alarm manager plus 是专门为 Android 设计的。 Flutter 社区“加上”包提供了一个超集相应的包从 Flutter 小组。例如，电池组在 Flutter 发布之前就已经由 Google 的 Flutter 团队提供，并且已经迁移到了 null 安全性，但是只支持安卓和 iOS。另一方面，Flutter 社区电池 + 软件包支持所有六个 Flutter 平台，包括 web、 Windows、 macOS 和 Linux。颁奖的 Flutter 最喜欢的奖项所有 9 个“加”包代表了一个成熟的 Flutter 社区作为一个整体向前迈出了一大步。比 Google 的工程师团队要大得多。您应该尽快将代码迁移到“附加”包，在未来几周内，Google 的相应包将进行更新，以推荐您这样做。 Googleapi 插件提供了大约 185 个自动生成的 Dart 包装器，用于客户端或服务器端的 Dart 应用程序(包括 Flutter 应用程序)。如果你想了解更多关于这个软件包，作者有一个关于使用 Google api 启动 Flutter 应用程序的 i/o 演讲。 Win32 包是一个工程奇迹，它使用 Dart FFI 包装了大多数常用的 Win32 API 调用，使它们可以被 Dart 代码访问，而不需要 c 编译器或 Windows SDK。随着 Flutter 在 Windows 平台上的流行，win32 包已经成为许多流行插件的关键依赖，包括最流行的路径提供者。作为一个完整性的测试，作者 timsneath 做了一些疯狂的事情，比如在原始的 Win32 中使用原始的 Dart 来实现记事本、 snake 和俄罗斯方块。 俄罗斯方块运行在 Windows 上，只使用 Dart FFI 和 Win32 调用 Win32 包是绝对值得检查，如果你做任何与 Dart 或扑在 Windows。 更新和 Firebase 应用程序检查FlutterFire，Flutter 对 Firebase 的支持，是 Flutter 使用的最流行的插件集合之一。转化酶已经做了一个巨大的工作，让它生产的 Flutter 2 释放，并继续改善它，从那时起。事实上，自从 FlutterFire 的初始生产版本发布以来，转化酶已经减少了 79% 的未解决问题，并且减少了 88% 的未解决问题。此外，他们不仅在产品质量插件方面做得非常出色，他们还将 beta 质量插件迁移到了空安全性，并且让它们在同一核心上构建和运行，这样你就可以混合和匹配了。 此外，Invertase 还继续为 FlutterFire 插件增加新的功能，包括一些 Flutter 与 Cloud Firebase 整合的更新: Typesafe API 空气污染指数 用于读写数据 支持 Firebase 本地模拟器套件 优化您的数据查询 data bundles 数据包 最后，但并非最不重要的是，FlutterFire 提供了对新 Firebase 产品 beta 版本的支持: Firebase App Check。防火基地应用程序检查保护你的后端资源，如云存储，免受滥用，如帐单欺诈或网络钓鱼。使用 App Check，运行你 Flutter 应用的设备使用一个应用程序身份认证提供商来确认它确实是你的应用程序，并且可能检查它是否运行在一个真实的、未被篡改的设备上。一旦你激活应用程序检查，这个认证就会附加到你的应用程序对 Firebase 后端资源提出的每个请求上。要了解更多信息，请参阅 FlutterFire App Check 文档。 Flutter DevTools updates随着这个版本的发布，Flutter DevTools 有了一些值得注意的更新，包括两个内存跟踪改进和一个全新的选项卡专门为提供者插件。 DevTools 版本中的第一个内存跟踪改进提供了跟踪对象分配位置的能力。这对于在代码中找到内存泄漏的位置非常方便。Flutter DevTools memory tab allocation stack trace Flutter DevTools 内存选项卡分配堆栈跟踪 第二个是将自定义消息注入内存时间轴的能力。这样你就可以为你的应用程序提供特定的标记，比如在你完成一些内存密集型的工作之前和之后，这样你就可以检查你是否正确地清理了东西。 自定义内存事件 随着 Flutter 应用程序越来越大，我们将继续确保 Flutter 开发者拥有他们需要的工具来跟踪和修复内存泄漏和各种运行时问题。 在使用 Flutter 框架时，你不仅要追踪运行时问题，有时你还要追踪与软件包相关的问题。在 pub.dev 上有超过 15,000 个 flutter 兼容的软件包和插件，随着应用程序使用更多的软件包，这种情况越来越有可能发生。因此，考虑到这一点，我们一直在尝试为 Flutter DevTools 添加一个新的 Provider 标签。实际上，这个选项卡是由提供程序包本身的作者 Remi Roussel 创建的(还有许多其他好东西)。如果你正在运行最新版本的 Flutter DevTools，并且正在调试一个使用提供者插件的 Flutter 应用程序，你将自动获得新的 Provider 标签。 激活 DevTools Provider 选项卡 “提供者”选项卡显示与每个提供者关联的数据，包括运行应用程序时的实时更改。如果这还不够惊人的话，它可以让你直接改变数据，作为一种测试你的应用程序的角落情况的方法！ 通过使用 Remi 的这个标签，我们学到了一些关于如何更好地支持其他想要做同样事情的软件包作者的知识; 你可以阅读 Remi 如何构建 Provider 标签，以及我们目前关于如何在 Flutter DevTools Plugins 提案中启用更多标签的想法。请给我们您的反馈，并随时联系告诉我们您的计划，一个新的标签在 Flutter 开发工具。 This is only a few of the cool new things in Flutter DevTools in this release. For the complete list, check out the individual announcements here: 这只是 Flutter DevTools 在这个版本中的一些很酷的新东西。完整的列表请点击这里查看个人声明: Flutter DevTools 2.1 Release Notes 2.1 发行说明https://groups.google.com/g/flutter-announce/c/tCreMfJaJFU/m/38p1BBeiCAAJ Flutter DevTools 2.2.1 Release Notes 2.2.1 发行说明https://groups.google.com/g/flutter-announce/c/t8opLnUyiFQ/m/dJth-jKxAAAJ Flutter DevTools 2.2.3 Release Notes 2.2.3 发行说明https://groups.google.com/g/flutter-announce/c/t8opLnUyiFQ/m/YX5Ds_q0AgAJ IDE 插件更新Visual Studio Code 和 IntelliJ/Android Studio IDE 扩展 for Flutter 在这个版本中也进行了更新。例如，visualstudio 代码扩展现在支持两个附加的 Dart 代码重构: 内联方法和内联局部变量。 新的 Dart 重构行动内嵌方法 在 Android Studio/IntelliJ 扩展中，我们添加了将所有堆栈跟踪打印到控制台的功能。 现在您可以获得所有的堆栈跟踪，而不仅仅是第一个 这对于那些根本原因可能在不同包中的项目很有帮助，因为以前没有打印这些包。我们已经有了一些想法，可以让这篇文章不那么冗长，所以在未来寻找更多的改变。 有关此版本的 IDE 扩展更改的完整列表，请查看以下公告: VS Code extension v3.21 VS Code 扩展 v3.21https://groups.google.com/g/flutter-announce/c/gNtKp9c1glU/m/SZYTuwcQBwAJ VS Code extension v3.22 VS Code 扩展 v3.22https://groups.google.com/g/flutter-announce/c/1XR7baYZOVI/m/y6MGYrGhAAAJ Flutter IntelliJ Plugin M55 Release 55 Releasehttps://groups.google.com/g/flutter-announce/c/tYwFDPAtLu0/m/FrsntcNNBwAJ Flutter IntelliJ Plugin M56 Release 56 发布https://groups.google.com/g/flutter-announce/c/EkgiAO4p3UM/m/P32ZXXKfAAAJ DartPad workshops为了确保我们在快速发展的 Flutter 开发者社区中准备好文档，Dart 和 Flutter 团队总是在寻找改进和扩展创建教育内容的方法。随着这个版本的发布，我们为 DartPad 添加了一个新的、逐步的 UI，开发人员可以使用它来跟随讲师指导的工作坊。 实践中的 DartPad 工作坊 通过直接在 DartPad 中添加说明，我们为 i/o 提供了一种有指导的工作坊体验。然而，我们不仅仅是为我们自己的工作坊创建它; 如果您想在您的 Dart 或 Flutter 工作坊中使用它，您可以通过遵循 DartPad 工作坊创作指南来实现。除此之外，你还可以在 Gist 中使用 DartPad 来共享代码，并在你自己的站点中嵌入 DartPad，这已经有一段时间了。 我们希望每个制作 Dart 和 Flutter 内容的人都能够为他们的用户提供丰富的交互式体验。请尝试一下这个新功能，让我们知道你的想法！ 社区聚光灯: FlutterFlowFlutterFlow 是一个“低代码”应用程序设计和开发工具，用于在浏览器中构建应用程序。它提供了一个所见即所得的环境，可以使用 Firebase 的实际数据在多个页面上展示你的应用程序。低代码工具的目标是轻松地完成大多数常见事情，允许您编写尽可能少的行自定义代码。事实上，作为一个演示，他们在不到一个小时的时间里创建了一个整体的多页面移动应用程序，可以用零代码浏览大都会艺术博物馆。 FlutterFlow 输出 Flutter 代码，所以如果你需要添加代码来进一步定制你的应用程序，你可以。你可以在 FlutterFlow.io 上阅读 FlutterFlow 产品的发布。 https://flutterflow.io/blog/launch Breaking Changes一如既往，我们努力减少破坏性更改的数量，在这个版本中，我们已经能够限制它去除这些反对意见: 73750 删除已弃用的 BinaryMessages 73751 删除已弃用的 TypeMatcher 类 您可以在 flutter.dev 上找到针对这些突发变化的缓解方法。 摘要像往常一样，来自谷歌 Flutter 团队的所有人，我们想说ーー谢谢。感谢你成为社区的一部分，让这一切成为可能。随着超过八分之一的新应用程序在播放商店正在建立 Flutter 和超过 200,000 个 Flutter 应用程序在播放商店，我们的持续增长是令人兴奋的。世界各地的各种规模的应用程序都委托他们的用户界面，飞翼工艺美丽的多平台体验，以满足用户可能在任何地方。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Google I/O 2021 发布 Flutter 2.2","date":"2021-05-19T00:42:13.000Z","path":"2021/05/19/translation/announcing-flutter-2-2-at-google-i-o-2021/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://medium.com/flutter/announcing-flutter-2-2-at-google-i-o-2021-92f0fcbd7ef9 参考 https://flutter.dev/docs/whats-new https://www.slashdata.co/reports/?category=mobile-desktop 正文在今天的 Google i/o 大会上，我们发布了 Flutter 2.2，这是我们最新发布的开源工具包，可以为单一平台上的任何设备构建漂亮的应用程序。Flutter 2.2 是 Flutter 目前为止最好的版本，它的更新让开发者比以往任何时候都更容易通过应用程序内购买、支付和广告赚钱; 连接到云服务和 api，扩展应用程序以支持新功能; 以及工具和语言功能，允许开发者消除一整类错误，提高应用程序性能和减少包大小。 建立在 Flutter 2 的基础上Flutter 2.2 是建立在 Flutter 2 的基础上的，它将 Flutter 从它的移动根源扩展到整合了 web、桌面和嵌入式使用。它是专门为环境计算世界设计的，用户有各种各样不同的设备和形式因素，并寻找跨越他们的日常生活的一致体验。使用 Flutter 2.2，企业、初创公司和企业家都可以构建高质量的解决方案，这些解决方案可以充分发挥其潜在市场的潜力，让创造性灵感(而不是目标平台)成为唯一的限制因素。 Flutter 是目前最流行的跨平台开发框架。 最近的一项移动开发者研究强调了 Flutter 的增长。分析公司 SlashData 的移动开发人员 2021 年人口预测显示，Flutter 现在是最流行的跨平台开发框架，有 45% 的开发人员选择了它，在 2020 年第一季度到 2021 年第一季度之间增长了 47% 。我们自己的数据证实了 Flutter 的这种转变; 在过去的 30 天里，Play Store 中超过八分之一的新应用程序都是使用 Flutter 构建的。 在 i/o，我们分享到仅仅在 Play Store 中就有超过 20 万个应用程序使用了 Flutter。这些应用程序来自腾讯，其微信即时通讯应用程序在 iOS 和安卓系统上被超过 12 亿用户使用; ByteDance，TikTok 的发起者，现在已经使用 Flutter 开发了 70 个不同的应用程序; 以及其他来自宝马、 SHEIN、 Grab 和滴滴等公司的应用程序。当然，Flutter 不仅仅被大公司使用。一些最具创新性的应用程序来自于你可能从未听说过的名字: Wombo，沃姆博，自拍应用程序; Fastly,间歇性禁食应用程序; Kite，一个漂亮的投资交易应用程序。 介绍 Flutter 2.2Flutter 2.2 发布的重点是改进开发体验，以帮助您向客户提供更可靠、性能更好的应用程序。 Sound null safety 现在是默认的新项目。空安全增加了对空引用异常的保护，使开发人员能够在代码中表达不可空类型。由于 Dart 的实现是合理的，编译器可以在运行时消除空检查，从而提高应用程序的性能。这个生态系统反应迅速，大约有 5000 个软件包已经升级到支持空安全。 这个版本还有很多性能改进: 对于 web 应用，我们使用服务工作者提供后台缓存; 对于 Android 应用，Flutter 支持延迟组件; 对于 iOS，我们一直在开发工具来预编译着色器，以消除或减少首次运行的 jank。我们还为 DevTools 套件添加了一些新特性，帮助您理解如何在应用程序中分配内存，以及对第三方工具扩展的支持。 此外，我们一直致力于一些重要的改进领域，如改善网页目标的可访问性。 我们的工作超越了 Flutter 的核心。我们还与其他谷歌团队合作，帮助将 Flutter 整合到我们更广泛的开发者堆栈中。特别是，我们继续建立可信赖的服务，帮助开发者负责任地将他们的应用货币化。我们的新广告 SDK 是更新在这个版本的零安全和自适应横幅格式的支持。我们还引入了一个新的支付插件，与谷歌支付团队建立了合作关系，让你可以在 iOS 和安卓系统上支付实体商品。我们更新了我们的应用内购买插件，以及一个匹配的代码。 adshttps://developers.google.com/admob/flutter/quick-start payhttp://pub.dev/packages/pay in_app_purchasehttps://pub.dev/packages/in_app_purchase codelabs flutter-in-app-purchaseshttps://codelabs.developers.google.com/codelabs/flutter-in-app-purchases 作为“秘密武器”的 Flutter，Dart 也得到一个更新，在这个版本。Dart 2.13 扩展了对本地互操作性的支持，在 FFI 中支持数组和打包结构。它还包括对类型别名的支持，这提高了可读性，并为某些重构场景提供了一种温和的方式。我们继续为更广泛的生态系统添加集成，使用 Dart GitHub Action 和针对基于云的业务逻辑部署进行优化的策划的 Docker Official Image。 github actionhttps://github.com/marketplace/actions/setup-dart-sdk ocker Official Imagehttps://hub.docker.com/_/dart 不仅仅是一个谷歌项目虽然谷歌仍然是 Flutter 项目的主要贡献者，但我们很高兴看到 Flutter 周围更广泛的生态系统的发展。 最近几个月来，Flutter 增长的一个特别领域是不断扩展到越来越多的平台和操作系统。在 Flutter 参与，我们宣布，丰田是带来扑动到他们的下一代汽车信息娱乐系统。上个月，Canonical 发布了他们的第一个 Ubuntu 版本，带有 Flutter 的集成支持，Snap 的集成和韦兰的支持。 https://medium.com/googleplaydev/seamless-multi-platform-app-development-with-flutter-ea0e8003b0f9#f53d https://ubuntu.com/blog/ubuntu-21-04-is-here 两个新的合作伙伴展示了这个不断增长的生态系统。三星正在将 Flutter 移植到 Tizen，并提供了一个其他人也可以贡献的开放源代码库。索尼正在努力为嵌入式 Linux 提供解决方案。 https://github.com/flutter-tizen/flutter-tizen https://github.com/sony/flutter-embedded-linux 设计师也从这个项目的开源性质中受益，Adobe 公布了更新后的 XD to Flutter 插件。Adobe XD 为设计师提供了一个很好的实验和迭代的方式，现在有了增强的 Flutter 支持，设计师和开发人员可以在同一资产上协作，比以往更快地将伟大的想法投入到生产中。 https://medium.com/adobetech/announcing-xd-to-flutter-v2-0-82d09f3909a7 最后，微软将继续与我们合作; 除了 Surface 团队一直在使用 Flutter 构建可折叠体验的工作外，本周还将看到为 Windows 10 构建的 UWP 应用程序 Flutter 的 alpha 支持。我们很高兴看到更多的应用程序能够利用 Flutter 内置的平台适应性，在移动、桌面、网络和其他领域提供更好的体验。 https://flutter.dev/desktop#windows-uwp 建立伟大的 Experiences最重要的是，我们建立 Flutter 来帮助开发者建立伟大的体验。我们被应用程序开发可以做得更好这个想法激励着: 我们可以通过消除传统的阻碍接触到你的受众的障碍来增强你的能力。 我们喜欢看你如何让 Flutter 工作。一个例子是美国退伍军人管理局的一个项目。下面的视频展示了他们的 Flutter 应用程序是如何帮助他们提供创伤后应激障碍士兵康复。 通过在 Google i/o 上举办各种各样的关于 Flutter 的研讨会、演示会和点播会议，我们很高兴与大家分享我们的工作。别忘了看看我们有趣的照相亭网络应用，它是用 Flutter 开发的，它可以让你和我们的 Dash 吉祥物和她的朋友们创建一张自拍！ https://events.google.com/io/program/content?4=topic_flutter https://photobooth.flutter.dev/ © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter ModalBottomSheet 指导","date":"2021-05-17T16:00:00.000Z","path":"2021/05/18/translation/flutter-modalbottomsheet-for-beginners/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://evandrmb.medium.com/flutter-modalbottomsheet-for-beginners-e5f3af271076 代码https://github.com/evandrmb/bottom_sheet 参考 https://material.io/components/sheets-bottom 正文根据材质设计指南，底部表是一个小工具，用于显示锚定在屏幕底部的附加内容。虽然了解使用这个的设计规则很好，但这不是本文的目标。要了解更多关于底板设计原则的详细信息，请参阅“Sheets: bottom — Material Design”。 现在你知道了 BottomSheet，你可能会问自己: 什么是 ModalBottomSheet？我们如何使用他们在 Flutter？ 好的，第一个问题，有两种底层表: 模态的和持久的。当用户与屏幕交互时，持久化保持可见。谷歌地图应用就是一个例子。 另一方面，模式化的操作会阻止用户在应用程序中做其他动作。您可以使用它们来确认某些操作，或者请求额外的数据，比如询问用户在电子商务应用程序中订购时需要多少交换，等等。 在本文中，我们将通过创建一个简单的体重跟踪应用程序来展示如何使用它，在这个应用程序中我们可以提交我们的体重并查看我们之前的体重。我们不会输入应用程序的详细信息，而是直接进入 ModalBottomSheet 实现。 要显示它，您需要从具有 Scaffold 的上下文调用 showModalBottomSheet，否则，您将得到一个错误。也就是说，让我们开始构建我们的表格。 首先要知道的是 ModalBottomSheets 的高度默认为屏幕的一半，为了改变它，必须传递 true 给 isScrollControlled 参数，并返回一个与我们期望的大小相匹配的小部件，所以让我们这样做。 1234567891011121314151617181920void addWeight() &#123; showModalBottomSheet( isScrollControlled: true, context: context, builder: (context) &#123; var date = DateTime.now(); return Container( height: 302, padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ ], ), ); &#125;, ); &#125; 现在，我们需要添加一些东西，以便我们的用户可以输入他们的权重让我们添加一个 TextInput 并给它一个 TextEditingController (这种方式即使我们的工作表意外关闭时，用户再次打开它，它的值仍然存在)。 1234567891011121314151617181920212223242526272829303132333435void addWeight() &#123; showModalBottomSheet( isScrollControlled: true, context: context, builder: (context) &#123; var date = DateTime.now(); return Container( height: 302, padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ padding: EdgeInsets.only(bottom: 24.0), child: Text( 'Register Weight', style: Styles.titleStyle, ), ), TextField( controller: weightInputController, keyboardType: TextInputType.number, decoration: InputDecoration( labelText: 'Weight (KG)', border: OutlineInputBorder( borderRadius: Styles.borderRadius, ), ), ), ], ), ); &#125;, ); &#125; 看起来不错，但现在我们有麻烦了。当用户点击我们的 TextField 键盘在它上面，为什么？当键盘打开时，我们的工作表不会调整位置，我们可以把工作表做得更大，但这不能解决我们的问题，因为我们仍然需要添加一个字段，用户可以在其中输入他们记录重量的日期。那么解决方案是什么呢？这很简单，如果打开键盘，我们让我们的工作表在它上面，我们可以实现这一点，给我们的容器一个边距的边缘。在 viewinset.bottom 中，我们将得到以下结果: 它开始看起来很漂亮，但是你不认为如果我们在纸上加一些半径会更平滑吗？让我们通过添加如下所示的 shapeproperty 来实现。 12345678showModalBottomSheet( isScrollControlled: true, context: context, shape: const RoundedRectangleBorder( borderRadius: BorderRadius.only( topLeft: Radius.circular(8), topRight: Radius.circular(8), )), 酷，现在让我们做我们的小工具来选择一个日期。通常，您会创建一个小部件来处理这个逻辑，并使用 ValueChanged 函数公开选定的值，但是为了说明您将来可能面临的问题，让我们在工作表本身内部创建所有逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void addWeight() &#123; showModalBottomSheet( isScrollControlled: true, context: context, shape: const RoundedRectangleBorder( borderRadius: BorderRadius.only( topLeft: Radius.circular(8), topRight: Radius.circular(8), )), builder: (context) &#123; return Container( height: 360, width: MediaQuery.of(context).size.width, margin: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom), padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), ), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Padding( padding: EdgeInsets.only(bottom: 24.0), child: Text( 'Register Weight', style: Styles.titleStyle, ), ), TextField( controller: weightInputController, keyboardType: TextInputType.number, decoration: InputDecoration( labelText: 'Weight (KG)', border: OutlineInputBorder( borderRadius: Styles.borderRadius, ), ), ), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: Row( children: [ Expanded( child: Text( 'Select a date', style: TextStyle( fontSize: 14, fontWeight: FontWeight.w500, ), ), ), Container( padding: const EdgeInsets.symmetric(horizontal: 4), margin: const EdgeInsets.symmetric(vertical: 8.0), height: 36, decoration: BoxDecoration( borderRadius: Styles.borderRadius, ), child: OutlinedButton( onPressed: () async &#123; final now = DateTime.now(); final result = await showDatePicker( context: context, initialDate: now, firstDate: now.subtract( const Duration( days: 90, ), ), lastDate: now); if (result != null) &#123; setState(() &#123; selectedDate = result; &#125;); &#125; &#125;, child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Padding( padding: const EdgeInsets.only(right: 16.0), child: Text('$&#123;formatDateToString(selectedDate)&#125;'), ), Icon(Icons.calendar_today_outlined), ], ), ), ), ], ), ) ], ), ); &#125;, ); &#125; 需要注意的是，我已经在我们的主页中添加了 selectedDatevariable，你可以在我最后提供的存储库链接中看到这一点。但是现在我们遇到了一个问题，尽管我们正在使用 setstateoutlinebutton 更新 selectedDate 的值，但是在重新打开工作表之前，仍然会显示旧的值，如下所示。 为了解决这个问题，我们需要将 OutlinedButton 传递给 StatefulBuilder (或者您可以创建一个新的小部件并使用回调公开更改，正如我前面所说的，顺便说一下，这是更正确的方法)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134void addWeight() &#123; showModalBottomSheet( isScrollControlled: true, context: context, shape: const RoundedRectangleBorder( borderRadius: BorderRadius.only( topLeft: Radius.circular(8), topRight: Radius.circular(8), )), builder: (context) &#123; return Container( height: 360, width: MediaQuery.of(context).size.width, margin: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom), padding: const EdgeInsets.all(16.0), decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), ), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const Padding( padding: EdgeInsets.only(bottom: 24.0), child: Text( 'Register Weight', style: Styles.titleStyle, ), ), TextField( controller: weightInputController, keyboardType: TextInputType.number, decoration: InputDecoration( labelText: 'Weight (KG)', border: OutlineInputBorder( borderRadius: Styles.borderRadius, ), ), ), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: Row( children: [ Expanded( child: Text( 'Select a date', style: TextStyle( fontSize: 14, fontWeight: FontWeight.w500, ), ), ), Container( padding: const EdgeInsets.symmetric(horizontal: 4), margin: const EdgeInsets.symmetric(vertical: 8.0), height: 36, decoration: BoxDecoration( borderRadius: Styles.borderRadius, ), child: StatefulBuilder( builder: (context, setState) &#123; return OutlinedButton( onPressed: () async &#123; final now = DateTime.now(); final result = await showDatePicker( context: context, initialDate: now, firstDate: now.subtract( const Duration( days: 90, ), ), lastDate: now); if (result != null) &#123; setState(() &#123; selectedDate = result; &#125;); &#125; &#125;, child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ Padding( padding: const EdgeInsets.only(right: 16.0), child: Text( '$&#123;formatDateToString(selectedDate)&#125;'), ), Icon(Icons.calendar_today_outlined), ], ), ); &#125;, )), ], ), ), Expanded(child: Container()), ButtonBar( children: [ ElevatedButton( onPressed: () =&gt; Navigator.pop(context), child: Text('Cancel', style: TextStyle( color: Theme.of(context).primaryColor, )), style: ElevatedButton.styleFrom( primary: Colors.white, // minimumSize: Size(96, 48), ), ), ElevatedButton( onPressed: () &#123; setState(() &#123; weights.insert( 0, WeightModel( value: double.parse(weightInputController.text), date: selectedDate, )); &#125;); Navigator.pop(context); &#125;, child: const Text('Register')), ], ), ], ), ); &#125;, ); &#125; 这是我们的 ModalBottomSheet 的最终版本！ https://github.com/evandrmb/bottom_sheet © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter开源项目 - 音乐播放器 BlackHole","date":"2021-05-16T16:00:00.000Z","path":"2021/05/17/flutter-opensource/flutter-music-player-blackhole/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat代码 https://github.com/Sangwan5688/BlackHole 特点Music SearchTop PlaylistsLocal and Global Top 200 songsStreaming (320kbps)Add Songs to FavoriteDownload Support (320kbps with ID3 tags)Play Online as well as Offline Songs 截图 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源项目https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"企业级Flutter项目-走出第一步","date":"2021-05-13T16:00:00.000Z","path":"2021/05/14/translation/flutter-in-business-first-steps/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://matteozajac.medium.com/flutter-in-business-first-steps-d8d0648c913b 参考 https://pub.dev/packages/flutter_bloc https://pub.dev/packages/chopper https://pub.dev/packages/json_serializable https://dart.dev/guides/language/effective-dart https://plugins.jetbrains.com/plugin/12400-flutter-pub-version-checker 正文大多数时候你必须为你的应用程序的技术债务付款。如果你在 MVP 之后没有良好的体系结构，那么现在是时候停下来，重构一下，让你的未来变得更加容易。事实上，在没有架构的情况下编写较小的应用程序更容易—- 很难不同意这一点—- 但是作为一个成熟的技术专家来考虑。 测试覆盖率，设计模式，代码分析，这些都是我正在考虑的。本文将介绍我们如何在提高代码质量和团队愉悦感的同时，交付出色的应用程序。 从架构开始Provider, BLoC, Redux ーー如果这些词听起来不熟悉，请在继续前进之前对它们有基本的了解。 它们都有优点和缺点，你可以自己选择。 拥有 Flutter 的知识和如何人们已经适应项目结构 BLoC 似乎是最简单的方式开始。 恕我直言，展示和理解 BLoC 如何工作的最好方式是看下面的图表。 表示层将事件发送到 BLoC 数据层异步执行较长的操作，例如从 API 或数据库获取数据 对用户界面产生返回值 就这么简单。 自己实现 BLoC 模式这真的是很好的锻炼，你应该一次性完全理解它背后的流程。如果你已经这样做了 然后使用..。 BLoC 库幸运的是，社区没有让人失望。你不必每次都写 BLoC，只需使用这个方便的 library ー FlutterBloc。 我想指出几个关键特征: Event — 没有样板的事件-状态通信, Dependency 依赖注入通过 BlocProvider, BlocBuilder 根据接收的状态构建小部件, BlocDelegate 使全局处理错误更加容易, BLoC 可以(也应该)进行测试 https://pub.dev/packages/flutter_bloc 采用 REST API 如果你创建了一个移动应用程序，你将连接到一个远程数据源。最常用的方法是 REST api 和 JSON。当然，你已经这样做了很多次，所以没有更多的解释。 来自 Android world 的消息表明你已经使用过 Retrofit、 GSON 或莫希 JSON 转换器。这些真的是非常棒的工具。 Flutter 中使用 chopper 库 https://pub.dev/packages/chopper 在这两种情况下，您都需要为您的 API 定义抽象类，并使用 flutter pub run build_runner build 生成它。 接下来，没有类似 GSON 的库可以将 JSON 转换为 POJO。您需要编写自己的映射器函数，或者使用 json_serializable，它通过注释 Dart 类自动生成转换到 JSON 和从 JSON 转换的代码。这个过程本身非常简单，你肯定会习惯的。 https://pub.dev/packages/json_serializable 本地持久化 在大多数情况下，当需要缓存我们的数据时，Sqflite 是我们的首选。它只是一个 SQLite Dart 实现，支持: 原始 SQL 查询, 插入/查询/更新/删除的方便助手, 批次ー避免性能问题。 分析代码在项目中拥有并保持代码样式对于团队来说可能是至关重要的。与体系结构一样，它也是维护项目和团队成员之间的质量、一致性的关键因素。 默认情况下，ide 集成了默认的静态分析，您可以根据需要扩展和调整这些分析。在他们的文档中很好地描述了 Effective 有自己的线头规则ーー Effective Dart。如果您喜欢这种风格(我确实喜欢) ，来自 Google 的开发团队就创建了一个带有这种规则集的包(pedantic | Dart 包) Effective Darthttps://dart.dev/guides/language/effective-dart pedantichttps://pub.dev/packages/pedantic 值得一提手动检查每个包的版本可能有点烦人。对于 Android Studio 用户，你可以查看这个插件 Flutter Pub Version Checker ー For IntelliJ IDEA，Android Studio 为你提供。突出显示带有新版本的软件包非常方便。 https://plugins.jetbrains.com/plugin/12400-flutter-pub-version-checker 待续这是一个关于我们公司内部使用的库和方法的快速总结。如果你正在寻找一些开始点，它也应该有助于你的项目，但作为 Flutter 已经演变，我们有许多可行的解决方案，共同的问题，这只是其中之一。在下一篇文章中，我将展示体系结构图，解释特定的层，并实现一个列表屏幕(从远程、本地持久化获取)。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ 开源https://ducafecat.tech/categories/%E5%BC%80%E6%BA%90/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter开源项目 - 响应式后台管理面板界面","date":"2021-05-11T16:00:00.000Z","path":"2021/05/12/flutter-opensource/flutter-responsive-admin-panel-or-dashboard/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat前言关于 Flutter V2 网络正式支持稳定的分支。今天我分享一个管理面板，或者你可以称它为仪表板 UI 。现在你可以使用 flutter 构建你的应用程序仪表板。这个仪表板包含几乎所有你需要的东西，如图表，表，显示信息的小卡片。它在网络、 macOS 应用程序、平板电脑以及安卓和 iOS 手机上都运行良好。是时候编写一次运行所有地方的代码了。是的，flutter 网络不是搜索引擎优化友好，但我们不需要搜索引擎优化的管理面板。 项目地址https://github.com/ducafecat/Flutter-Responsive-Admin-Panel-or-Dashboard 界面 代码分析核心代码 lib/responsive.dart通过 MediaQuery 查询界面宽高尺寸，来决定你是那个布局方案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import 'package:flutter/material.dart';class Responsive extends StatelessWidget &#123; final Widget mobile; final Widget tablet; final Widget desktop; const Responsive(&#123; Key key, @required this.mobile, this.tablet, @required this.desktop, &#125;) : super(key: key);// This size work fine on my design, maybe you need some customization depends on your design // This isMobile, isTablet, isDesktop helep us later static bool isMobile(BuildContext context) =&gt; MediaQuery.of(context).size.width &lt; 850; static bool isTablet(BuildContext context) =&gt; MediaQuery.of(context).size.width &lt; 1100 &amp;&amp; MediaQuery.of(context).size.width &gt;= 850; static bool isDesktop(BuildContext context) =&gt; MediaQuery.of(context).size.width &gt;= 1100; @override Widget build(BuildContext context) &#123; final Size _size = MediaQuery.of(context).size; // If our width is more than 1100 then we consider it a desktop if (_size.width &gt;= 1100) &#123; return desktop; &#125; // If width it less then 1100 and more then 850 we consider it as tablet else if (_size.width &gt;= 850 &amp;&amp; tablet != null) &#123; return tablet; &#125; // Or less then that we called it mobile else &#123; return mobile; &#125; &#125;&#125; 业务界面处理细节通过 if (!Responsive.isMobile(context)) 这样的方式去判断执行 lib/screens/main/main_screen.dart 12345678910111213141516171819202122232425262728class MainScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( key: context.read&lt;MenuController&gt;().scaffoldKey, drawer: SideMenu(), body: SafeArea( child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ // We want this side menu only for large screen if (Responsive.isDesktop(context)) Expanded( // default flex = 1 // and it takes 1/6 part of the screen child: SideMenu(), ), Expanded( // It takes 5/6 part of the screen flex: 5, child: DashboardScreen(), ), ], ), ), ); &#125;&#125; lib/screens/dashboard/dashboard_screen.dart 123456789101112131415161718192021222324252627282930313233343536373839404142class DashboardScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return SafeArea( child: SingleChildScrollView( padding: EdgeInsets.all(defaultPadding), child: Column( children: [ Header(), SizedBox(height: defaultPadding), Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ Expanded( flex: 5, child: Column( children: [ MyFiels(), SizedBox(height: defaultPadding), RecentFiles(), if (Responsive.isMobile(context)) SizedBox(height: defaultPadding), if (Responsive.isMobile(context)) StarageDetails(), ], ), ), if (!Responsive.isMobile(context)) SizedBox(width: defaultPadding), // On Mobile means if the screen is less than 850 we dont want to show it if (!Responsive.isMobile(context)) Expanded( flex: 2, child: StarageDetails(), ), ], ) ], ), ), ); &#125;&#125; © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 如何获取设备的唯一码","date":"2021-05-10T16:00:00.000Z","path":"2021/05/11/translation/how-to-get-unique-device-details-in-flutter/","text":"老铁记得 转发 ，猫哥会呈现更多 Flutter 好文~~~~微信 flutter 研修群 ducafecat原文 https://medium.com/flutterdevs/how-to-get-unique-device-details-in-flutter-ced2dbe5f8e5 猫哥说获取设备 id 是每一个 APP 都应该去做的，比如你访问唯一用户统计就需要。 前言 代码https://github.com/flutter-devs/flutter_device_details_demo 参考 https://pub.dev/packages/device_info 正文一般来说，制作一个移动应用程序是一个极其令人难以置信和测试的任务。有许多可用的框架，这些框架为创建移动应用程序提供了极好的亮点。为了创建移动应用，Android 提供了一个基于 Java 和 Kotlin 语言的本地结构框架，而 iOS 提供了一个依赖于 Objective-C/Swift 语言的系统。 随后，我们需要两种独特的语言和结构来为这两种操作系统创建应用程序。今天，为了打破这种错综复杂的结构，已经提出了几个框架来帮助桌面应用程序同时使用这两种操作系统。这类框架被称为 cross-platform 跨平台开发工具。 在这个博客，我们将探索如何获得独特的设备细节.我们将实现一个演示程序，并获得独特的设备细节，为安卓和 IOS 使用设备信息包在您的 Flutter 应用程序。 简介Flutter 中得到当前设备数据的应用。如何利用 device_info plugin 为 Android 和 IOS 提供独特的设备细节。在这一点上，当我们谈论一个独特的设备细节在本地，我们有 Settings.Secure.ANDROID_ID 获得一个独一无二的设备细节。 https://pub.dev/packages/device_info 演示 这个演示视频显示了如何获得一个独特的设备细节的 Flutter 。它显示了如何设备细节将工作使用设备信息包在您的 Flutter 应用程序。它会显示用户何时点击触发按钮，屏幕上显示的唯一设备 Andriod/Ios 信息，如设备名称、版本、标识符等。它会显示在你的设备上。 实施 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 1234dependencies: flutter: sdk: flutter device_info: ^0.4.0+4 第二步: 导入 1import 'package:device_info/device_info.dart'; 第三步: 在应用程序的根目录中运行 flutter 软件包。 代码实现如何实现 dart 文件中的代码: 在 lib 文件夹中创建一个新的 dart 文件，名为 device_detail_demo.dart。 首先，我们将创建一个用户界面。在主体部分，我们将添加一个中心小部件。在内部，我们将添加一个列小部件。在这个小部件中，我们将添加一个 mainAxisAlignmnet 为中心。它是 children’s property ，添加 RaisedButton()。在这个按钮中，我们将添加填充、颜色和 OnPressed 功能。它的子属性，我们将文本“Device Details”。 1234567891011121314Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ RaisedButton( padding: EdgeInsets.all(14), color: Colors.cyan[50], onPressed: ()&#123;&#125;, child: Text(\"Device Details\", style: TextStyle(color: Colors.black),), ), ], ),), 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 我们将创建三个字符串 deviceName、 deviceVersion 和 identifier。 123String deviceName ='';String deviceVersion ='';String identifier= ''; 现在，我们将添加程序的主函数。我们将添加 future _deviceDetails() 在内部，我们将添加一个最终的 deviceinfoplgin 等于新的 deviceinfoplgin()。我们将添加 try {} 方法，并为平台导入 dart:io。 1import 'dart:io'; 如果平台是 Andriod，那么构建就等于 deviceInfoPlugin 对于 Andriod 信息。添加 setState ()方法。在这个方法中，我们将所有的字符串加起来等于构建。如果平台是 Ios，那么构建版本就等于 Ios 信息的 deviceInfoPlugin。添加 setState ()方法。在这个方法中，我们将所有的字符串加起来等于构建。 123456789101112131415161718192021222324Future&lt;void&gt;_deviceDetails() async&#123; final DeviceInfoPlugin deviceInfoPlugin = new DeviceInfoPlugin(); try &#123; if (Platform.isAndroid) &#123; var build = await deviceInfoPlugin.androidInfo; setState(() &#123; deviceName = build.model; deviceVersion = build.version.toString(); identifier = build.androidId; &#125;); //UUID for Android &#125; else if (Platform.isIOS) &#123; var data = await deviceInfoPlugin.iosInfo; setState(() &#123; deviceName = data.name; deviceVersion = data.systemVersion; identifier = data.identifierForVendor; &#125;);//UUID for iOS &#125; &#125; on PlatformException &#123; print('Failed to get platform version'); &#125;&#125; 我们将为 PlatformException 导入服务 1import 'package:flutter/services.dart'; 现在，我们将在引发的按钮上添加按下的函子上的 _deviceDetails() 123onPressed: ()&#123; _deviceDetails();&#125;, 我们将添加设备版本、名称和标识符不是空的，然后显示 Column 小部件。在这个小部件中，我们将添加所有三个文本，如设备名称、设备版本和设备标识符将显示在您的设备上。否则，显示一个空容器。 12345678910111213141516171819deviceVersion.isNotEmpty &amp;&amp; deviceName.isNotEmpty &amp;&amp; identifier.isNotEmpty?Column( children: [ SizedBox(height: 30,), Text(\"Device Name:- \"+deviceName,style: TextStyle (color: Colors.red, fontWeight: FontWeight.bold)), SizedBox(height: 30,), Text(\"Device Version:- \"+deviceVersion,style: TextStyle (color: Colors.red, fontWeight: FontWeight.bold)), SizedBox(height: 30,), Text(\"Device Identifier:- \"+identifier,style: TextStyle (color: Colors.red, fontWeight: FontWeight.bold)), SizedBox(height: 30,), ],): Container(), 当用户点击按钮，然后，所有三个数据将显示在您的设备上。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 代码文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import 'dart:io';import 'package:device_info/device_info.dart';import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:flutter/services.dart';class DeviceDetailDemo extends StatefulWidget &#123; @override _DeviceDetailDemoState createState() =&gt; _DeviceDetailDemoState();&#125;class _DeviceDetailDemoState extends State&lt;DeviceDetailDemo&gt; &#123; String deviceName =''; String deviceVersion =''; String identifier= ''; Future&lt;void&gt;_deviceDetails() async&#123; final DeviceInfoPlugin deviceInfoPlugin = new DeviceInfoPlugin(); try &#123; if (Platform.isAndroid) &#123; var build = await deviceInfoPlugin.androidInfo; setState(() &#123; deviceName = build.model; deviceVersion = build.version.toString(); identifier = build.androidId; &#125;); //UUID for Android &#125; else if (Platform.isIOS) &#123; var data = await deviceInfoPlugin.iosInfo; setState(() &#123; deviceName = data.name; deviceVersion = data.systemVersion; identifier = data.identifierForVendor; &#125;);//UUID for iOS &#125; &#125; on PlatformException &#123; print('Failed to get platform version'); &#125; &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( backgroundColor: Colors.redAccent[100], title: Text(\"Flutter Device Details Demo\"), automaticallyImplyLeading: false, ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ RaisedButton( padding: EdgeInsets.all(14), color: Colors.cyan[50], onPressed: ()&#123; _deviceDetails(); &#125;, child: Text(\"Device Details\", style: TextStyle(color: Colors.black),), ), deviceVersion.isNotEmpty &amp;&amp; deviceName.isNotEmpty &amp;&amp; identifier.isNotEmpty? Column( children: [ SizedBox(height: 30,), Text(\"Device Name:- \"+deviceName,style: TextStyle (color: Colors.red, fontWeight: FontWeight.bold)), SizedBox(height: 30,), Text(\"Device Version:- \"+deviceVersion,style: TextStyle (color: Colors.red, fontWeight: FontWeight.bold)), SizedBox(height: 30,), Text(\"Device Identifier:- \"+identifier,style: TextStyle (color: Colors.red, fontWeight: FontWeight.bold)), SizedBox(height: 30,), ], ): Container(), ], ), ), ); &#125;&#125; 总结在本文中，我解释了如何获得独特的设备细节 Flutter 的基本结构，您可以根据自己的选择修改这个代码。这是一个小的介绍，以获得独特的设备细节的用户交互从我这边，它的工作使用 Flutter。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter Getx 05 - 嵌套导航、多语言、主题、Snackbar、Dialog、BottomSheet","date":"2021-05-08T16:00:00.000Z","path":"2021/05/09/flutter-getx/flutter-getx-05-nested-snack-dialog-bottom-lang-theme/","text":"本节目标 嵌套导航 多语言 主题 3 UI 组件 Snackbar Dialog BottomSheet 视频https://www.bilibili.com/video/BV1RU4y1t7DD/ 代码https://github.com/ducafecat/getx_quick_start 参考 https://pub.flutter-io.cn/packages/get 正文嵌套导航 几个 Navigator widget ，并排或者嵌套，他们是通过属性 key 来区分的，具体去哪里是通过 onGenerateRoute 实现的，在 getx 中 我们要把业务写到 controller中，状态切换用 Obx 控制 BottomNavigationBar，代码如下。 lib/pages/nested_navigation/controller.dart 1234567891011121314151617181920212223242526272829303132333435class NestedController extends GetxController &#123; static NestedController get to =&gt; Get.find(); var currentIndex = 0.obs; final pages = &lt;String&gt;['/list', '/detail', '/login']; void changePage(int index) &#123; currentIndex.value = index; Get.toNamed(pages[index], id: 1); &#125; Route? onGenerateRoute(RouteSettings settings) &#123; if (settings.name == '/login') return GetPageRoute( settings: settings, page: () =&gt; LoginView(), transition: Transition.topLevel, ); else if (settings.name == '/list') return GetPageRoute( settings: settings, page: () =&gt; ListIndexView(), transition: Transition.rightToLeftWithFade, ); else if (settings.name == '/detail') return GetPageRoute( settings: settings, page: () =&gt; DetailView(), transition: Transition.fadeIn, ); return null; &#125;&#125; lib/pages/nested_navigation/binding.dart 123456class NestedBinding extends Bindings &#123; @override void dependencies() &#123; Get.lazyPut(() =&gt; NestedController()); &#125;&#125; lib/pages/nested_navigation/index.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class NestedNavView extends GetView&lt;NestedController&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"嵌套路由\"), ), body: Container( color: Colors.amber, child: Column( children: [ Container( child: Text(\"占位条\"), height: 100, ), SizedBox( height: 300, child: Navigator( key: Get.nestedKey(1), initialRoute: '/list', onGenerateRoute: controller.onGenerateRoute, ), ), ], ), ), bottomNavigationBar: Obx( () =&gt; BottomNavigationBar( items: const &lt;BottomNavigationBarItem&gt;[ BottomNavigationBarItem( icon: Icon(Icons.list), label: '列表', ), BottomNavigationBarItem( icon: Icon(Icons.details), label: '详情', ), BottomNavigationBarItem( icon: Icon(Icons.login), label: '登录', ), ], currentIndex: controller.currentIndex.value, selectedItemColor: Colors.pink, onTap: controller.changePage, ), ), ); &#125;&#125; lib/common/routes/app_pages.dart 12345GetPage( name: AppRoutes.NestedNavigator, page: () =&gt; NestedNavView(), binding: NestedBinding(),), 多语言 编写多语言字典 文件名格式 [国家]_[语言].dart lib/common/lang/en_US.dart 1234const Map&lt;String, String&gt; en_US = &#123; 'title': 'This is Title!', 'login': 'logged in as @name with email @email',&#125;; lib/common/lang/zh_Hans.dart 1234const Map&lt;String, String&gt; zh_Hans = &#123; 'title': '这是标题', 'login': '登录用户 @name，邮箱账号 @email',&#125;; lib/common/lang/zh_HK.dart 1234const Map&lt;String, String&gt; zh_HK = &#123; 'title': '這是標題', 'login': '登錄用戶 @name，郵箱賬號 @email',&#125;; 继承 Translations lib/common/lang/translation_service.dart 12345678910class TranslationService extends Translations &#123; static Locale? get locale =&gt; Get.deviceLocale; static final fallbackLocale = Locale('en', 'US'); @override Map&lt;String, Map&lt;String, String&gt;&gt; get keys =&gt; &#123; 'en_US': en_US, 'zh_Hans': zh_Hans, 'zh_HK': zh_HK, &#125;;&#125; 初始 GetMaterialApp lib/main.dart 1234567891011121314class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return GetMaterialApp( ... locale: TranslationService.locale, fallbackLocale: TranslationService.fallbackLocale, translations: TranslationService(), ); &#125;&#125; locale 当前系统语言 fallbackLocale 如果找不到对应字典，默认值 translations 字典列表 切换 updateLocale 采用扩展操作符方式调用显示，点赞 xxx.tr, 切换语言 Get.updateLocale 123456\"title -&gt; \" + 'title'.tr,......var locale = Locale('zh', 'HK');Get.updateLocale(locale); lib/pages/lang/index.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class LangView extends StatelessWidget &#123; const LangView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"多语言\"), ), body: Center( child: Column( children: [ Text( \"title -&gt; \" + 'title'.tr, style: TextStyle(fontSize: 24), ), Divider(), Text( \"login -&gt; \" + 'login'.trParams( &#123;'name': 'ducafecat', 'email': 'ducafecat@gmail.com'&#125;)!, style: TextStyle(fontSize: 24), ), Divider(), ListTile( title: Text(\"切换语言\"), subtitle: Text('zh-HK'), onTap: () &#123; var locale = Locale('zh', 'HK'); Get.updateLocale(locale); &#125;, ), ListTile( title: Text(\"切换语言\"), subtitle: Text('zh-Hans'), onTap: () &#123; var locale = Locale('zh', 'Hans'); Get.updateLocale(locale); &#125;, ), ListTile( title: Text(\"切换语言\"), subtitle: Text('en-US'), onTap: () &#123; var locale = Locale('en', 'US'); Get.updateLocale(locale); &#125;, ), ], ), ), ); &#125;&#125; 主题 直接 Get.changeTheme 切换 ThemeData 数据。 1234onTap: () &#123; Get.changeTheme( Get.isDarkMode ? ThemeData.light() : ThemeData.dark());&#125;, lib/pages/theme/index.dart 123456789101112131415161718192021222324252627282930313233343536class ThemeView extends StatelessWidget &#123; const ThemeView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"主题\"), ), body: Center( child: Column( children: [ Container( height: 100, child: Align( alignment: Alignment.center, child: Text( \"是否黑色主题 -&gt; \" + Get.isDarkMode.toString(), style: TextStyle(fontSize: 24), )), ), Divider(), ListTile( title: Text(\"切换主题\"), subtitle: Text('Get.changeTheme'), onTap: () &#123; Get.changeTheme( Get.isDarkMode ? ThemeData.light() : ThemeData.dark()); &#125;, ), ], ), ), ); &#125;&#125; Snackbar 调用 1234onTap: () =&gt; Get.snackbar( \"标题\", \"消息\",), 参数 1234567891011121314151617181920212223242526272829303132333435363738394041void snackbar&lt;T&gt;( String title, String message, &#123; Color? colorText, Duration? duration, /// with instantInit = false you can put snackbar on initState bool instantInit = true, SnackPosition? snackPosition, Widget? titleText, Widget? messageText, Widget? icon, bool? shouldIconPulse, double? maxWidth, EdgeInsets? margin, EdgeInsets? padding, double? borderRadius, Color? borderColor, double? borderWidth, Color? backgroundColor, Color? leftBarIndicatorColor, List&lt;BoxShadow&gt;? boxShadows, Gradient? backgroundGradient, TextButton? mainButton, OnTap? onTap, bool? isDismissible, bool? showProgressIndicator, SnackDismissDirection? dismissDirection, AnimationController? progressIndicatorController, Color? progressIndicatorBackgroundColor, Animation&lt;Color&gt;? progressIndicatorValueColor, SnackStyle? snackStyle, Curve? forwardAnimationCurve, Curve? reverseAnimationCurve, Duration? animationDuration, double? barBlur, double? overlayBlur, SnackbarStatusCallback? snackbarStatus, Color? overlayColor, Form? userInputForm,&#125;) async &#123; Dialog 调用 12345678910111213onTap: () =&gt; Get.defaultDialog( title: \"标题\", content: Column( children: [ Text(\"第1行\"), Text(\"第2行\"), Text(\"第3行\"), ], ), textConfirm: \"确认\", textCancel: \"取消\", onConfirm: () =&gt; Get.back(),), 参数 123456789101112131415161718192021222324252627Future&lt;T?&gt; defaultDialog&lt;T&gt;(&#123; String title = \"Alert\", TextStyle? titleStyle, Widget? content, VoidCallback? onConfirm, VoidCallback? onCancel, VoidCallback? onCustom, Color? cancelTextColor, Color? confirmTextColor, String? textConfirm, String? textCancel, String? textCustom, Widget? confirm, Widget? cancel, Widget? custom, Color? backgroundColor, bool barrierDismissible = true, Color? buttonColor, String middleText = \"Dialog made in 3 lines of code\", TextStyle? middleTextStyle, double radius = 20.0, // ThemeData themeData, List&lt;Widget&gt;? actions, // onWillPop Scope WillPopCallback? onWillPop,&#125;) &#123; BottomSheet 调用 1234567891011121314 onTap: () =&gt; Get.bottomSheet( Container( height: 200, color: Colors.white, child: Column( children: [ Text(\"第1行\"), Text(\"第2行\"), Text(\"第3行\"), ], ), ), ),), 参数 123456789101112131415161718extension ExtensionBottomSheet on GetInterface &#123; Future&lt;T?&gt; bottomSheet&lt;T&gt;( Widget bottomsheet, &#123; Color? backgroundColor, double? elevation, bool persistent = true, ShapeBorder? shape, Clip? clipBehavior, Color? barrierColor, bool? ignoreSafeArea, bool isScrollControlled = false, bool useRootNavigator = false, bool isDismissible = true, bool enableDrag = true, RouteSettings? settings, Duration? enterBottomSheetDuration, Duration? exitBottomSheetDuration, &#125;) &#123; © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter getx","slug":"flutter-getx","permalink":"https://blog.ducafecat.tech/tags/flutter-getx/"}]},{"title":"Flutter 多个版本切换控制","date":"2021-05-06T23:43:37.000Z","path":"2021/05/07/translation/flutter-how-to-fluttering-from-one-version-to-other-versions/","text":"原文https://medium.com/litslink/flutter-how-to-fluttering-from-one-version-to-other-versions-cf242ffb15f7 猫哥说如果你和猫哥我一样，手上有几个 1 年前的项目，那么经常切换 sdk 版本，就成了必须做的事情，我可不会把老项目去升级新版本。 前言每次当技术改变为一个新的主版本时，将一个项目从较低的版本迁移到较高的版本是痛苦的。幸运的是，Dart 有一个迁移工具，可以帮助您将项目中的定义迁移到新的语法中。 但是即使你已经准备好切换到一个更新的版本，你也必须等待在你的项目中使用的一系列插件，即使在我的情况下，我确实帮助一些开源库迁移到 Null-Safety，这不足以将我的项目迁移到下一个版本。 社区每天都在成长，在大多数情况下，你会找到一些替代插件，这些插件还没有被迁移。如果您停留在以前的 Flutter 版本，本文将帮助您简化在项目之间的切换。 参考 https://flutter.dev/docs/development/tools/sdk/releases https://fvm.app/ 正文版本管理Flutter 版本有一个相关的 Dart SDK 版本，可以在本地缓存到 Flutter 缓存文件夹中，因此您应该记住一些约束。 作为一个开发者，你有几个选项可以在不同版本之间切换: 使用命令行脚本(CLI)进行手动编写 Flutter 版本管理器 CLI Sidekick GUI 图形用户界面 手动当你有两个或三个项目并在它们之间切换时，这个选项对你来说并不常见。 Flutter CLI 具有 git 控制的版本管理，因此即使使用 git checkout &lt;tag&gt; 命令也很容易切换。要查看可以签出的版本列表，只需运行 git tag-l，然后在找到所需版本时按 q 退出。 就是用 git 命令啦，没啥特别的，但是国内 github 很慢。。。 下载所需版本你可以访问 Flutter 发行版页面下载所需版本的快照，并替换环境变量版本以使用下载的版本 https://flutter.dev/docs/development/tools/sdk/releases 这是我之前常用的方法，免去了下载，每个版本包可是要 1G 了 Flutter CLI您可以尝试使用 flutter dider &lt;version&gt; 命令来降低它的等级，但是您将面临一个无法从 2.x 切换到 1.x 的问题。 Git幸运的是，Flutter SDK 使用 GIT 来管理版本，因此您可以有一个单一的目录来切换，而不像下载每个版本，并减少硬件上的空间。 假设你的 SDK 副本位于 ~/flutter 然后: 12345678910cd ~/flutter# Checkout needed versiongit checkout 1.22.6# Download Dart SDK, tools, etc.flutter doctor# Check Flutter and Dart versionflutter --version 最后，您将看到 flutter --version 命令的输出: 1234Flutter 1.22.6 • channel unknown • unknown sourceFramework • revision 9b2d32b605 (3 months ago) • 2021-01-22 14:36:39 -0800Engine • revision 2f0af37152Tools • Dart 2.10.5 当你需要切换回最新版本时，反之亦然: 1234567891011cd ~/flutter# Switch back to the stable channelflutter channel stable# Switch to latest version# flutter doctor will be invoked at this stepflutter upgrade# Check Dart and Flutter versionflutter --version 如果您对此步骤没有意见，可以通过调用 *.sh 来存储这些脚本并自动执行降级/升级过程。命令行中的 sh 文件。 FVM (Flutter Version Manager) 这也是猫哥我现在用的方式 以前，当我基于 React 和 ReactNative 开发应用程序时，我使用 NPM (节点包管理器)来管理项目中的依赖关系，Flutter 中的一个类似工具是 pub。有时候我需要更改 NPM 版本，但是它对 Node 版本有限制，所以我需要做同样的步骤，下载几个版本，替换目录等等。为了避免这个例程，我使用了 NVM (节点版本管理器) ，我的日子就要好起来了。 幸运的是，Flutter 有一个名为 FVM 的非官方工具，可以做同样的事情，它管理 Flutter 版本并将它们存储在您的硬件上。 https://fvm.app/ FVM 有两种使用方式: 全局指定 flutter 版本 指定你当前项目使用的版本 只需按照安装 https://fvm.app/docs/getting_started/installation 和配置说明的 https://fvm.app/docs/getting_started/configuration 来正确设置你的环境。 另一个令人惊奇的选择是 FVM 的 GUI，称为 Sidekick，它使得全局或本地(项目) Flutter SDK 版本管理更加舒适，如果你不是 CLI 的大粉丝。 老铁记得 点赞、转发 ，我将更有动力呈现 Flutter 好文~~~~ © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter BLoC 用户登录 1","date":"2021-05-05T16:00:00.000Z","path":"2021/05/06/translation/mastering-flutter-bloc-pattern-for-login-part-1/","text":"原文 https://medium.com/theotherdev-s/mastering-flutter-bloc-pattern-for-login-part-1-94082e139725 前言 首先，由于这不是一个基本的教程，我们理所当然地认为这是一个路线的知识，我们也包含了一点点的 validation 与 formoz 包来创建可重用的模型; 这不是本教程的目的，以显示这将如何工作，您将看到这在下一个教程。对于登录部分，出于教程的目的，我们还使用了 BLoC (Cubit) 的子集，因此您将看到这两者之间的区别。 代码，可以先阅读代码，再看文档https://github.com/Alessandro-v/bloc_login 参考 https://pub.flutter-io.cn/packages/equatable https://pub.flutter-io.cn/packages/validation https://pub.flutter-io.cn/packages/flutter_bloc https://pub.flutter-io.cn/packages/formoz 正文 开始在我们开始之前，让我们在 pubspec.yaml 中添加一些必要的包: 123equatable: ^2.0.0flutter_bloc: ^7.0.0formz: ^0.3.2 添加 equatable 包只会使您的工作更加容易，但是如果您想手动比较类的实例，只需要重写 “==” 和 hashCode。 登录状态让我们从一个包含表单状态和所有字段状态的类开始: 123456789101112131415161718192021222324252627class LoginState extends Equatable &#123; const LoginState(&#123; this.email = const Email.pure(), this.password = const Password.pure(), this.status = FormzStatus.pure, this.exceptionError, &#125;); final Email email; final Password password; final FormzStatus status; final String exceptionError; @override List&lt;Object&gt; get props =&gt; [email, password, status, exceptionError]; LoginState copyWith(&#123; Email email, Password password, FormzStatus status, String error, &#125;) &#123; return LoginState( email: email ?? this.email, password: password ?? this.password, status: status ?? this.status, exceptionError: error ?? this.exceptionError, ); &#125;&#125; 现在让我们创建我们的 LoginCubit，它将负责执行逻辑，例如通过 emit 获取电子邮件和输出新状态: 123456789101112131415161718192021222324252627282930313233class LoginCubit extends Cubit&lt;LoginState&gt; &#123; LoginCubit() : super(const LoginState()); void emailChanged(String value) &#123; final email = Email.dirty(value); emit(state.copyWith( email: email, status: Formz.validate([ email, state.password ]), )); &#125; void passwordChanged(String value) &#123; final password = Password.dirty(value); emit(state.copyWith( password: password, status: Formz.validate([ state.email, password ]), )); &#125; Future&lt;void&gt; logInWithCredentials() async &#123; if (!state.status.isValidated) return; emit(state.copyWith(status: FormzStatus.submissionInProgress)); try &#123; await Future.delayed(Duration(milliseconds: 500)); emit(state.copyWith(status: FormzStatus.submissionSuccess)); &#125; on Exception catch (e) &#123; emit(state.copyWith(status: FormzStatus.submissionFailure, error: e.toString())); &#125; &#125;&#125; 但是我们如何将腕尺与我们的用户界面连接起来呢？下面是对 BlocProvider 的解救，这是一个小部件，它使用: BlocProvider.of&lt;logincubit&gt;(context) 为其子部件提供一个区块 1234BlocProvider( create: (_) =&gt; LoginCubit(), child: LoginForm(),), 登入表格既然现在似乎都在他自己的地方，是时候解决我们的最后一块 puzzle，整个用户界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344class LoginForm extends StatelessWidget &#123; const LoginForm(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return BlocConsumer&lt;LoginCubit, LoginState&gt;( listener: (context, state) &#123; if (state.status.isSubmissionFailure) &#123; print('submission failure'); &#125; else if (state.status.isSubmissionSuccess) &#123; print('success'); &#125; &#125;, builder: (context, state) =&gt; Stack( children: [ Positioned.fill( child: SingleChildScrollView( padding: const EdgeInsets.fromLTRB(38.0, 0, 38.0, 8.0), child: Container( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, mainAxisAlignment: MainAxisAlignment.start, children: [ _WelcomeText(), _EmailInputField(), _PasswordInputField(), _LoginButton(), _SignUpButton(), ], ), ), ), ), state.status.isSubmissionInProgress ? Positioned( child: Align( alignment: Alignment.center, child: CircularProgressIndicator(), ), ) : Container(), ], ) ); &#125;&#125; 为了对 Cubit 发出的新状态做出反应，我们需要将我们的表单包裹在一个 BlocConsumer 中，现在我们将暴露一个监听者和一个建造者。 Listener 这里我们将监听状态更改，例如，在响应 API 调用时显示错误或执行导航。 Builder 在这里，我们将显示 ui 反应状态的变化，我们的 Cubit。 用户界面我们的用户界面由一个列和 5 个子元素组成，但是我们只展示 2 个简短的小部件: 123456789101112131415161718192021222324252627282930313233343536class _EmailInputField extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return BlocBuilder&lt;LoginCubit, LoginState&gt;( buildWhen: (previous, current) =&gt; previous.email != current.email, builder: (context, state) &#123; return AuthTextField( hint: 'Email', key: const Key('loginForm_emailInput_textField'), keyboardType: TextInputType.emailAddress, error: state.email.error.name, onChanged: (email) =&gt; context .read&lt;LoginCubit&gt;() .emailChanged(email), ); &#125;, ); &#125;&#125;class _LoginButton extends StatelessWidget &#123; const _LoginButton(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return BlocBuilder&lt;LoginCubit, LoginState&gt;( buildWhen: (previous, current) =&gt; previous.status != current.status, builder: (context, state) &#123; return CupertinoButton( child: Text('Login'), onPressed: state.status.isValidated ? () =&gt; context.read&lt;LoginCubit&gt;().logInWithCredentials() : null ); &#125;, ); &#125;&#125; 这两个小部件都包装在一个 BlocBuilder 中，只有当肘位为它们各自的评估属性发出新的状态时，BlocBuilder 才负责重新构建这些小部件，因此，例如，如果用户没有在 email 字段中键入任何内容，EmailInputField 将永远不会被重新构建。 相反，如果所有字段都经过验证，按钮将调用 logInWithCredentials() 函数，该函数将根据 API 响应发出一个新状态(失败或成功)。 老铁记得 点赞、转发 ，我将更有动力呈现 Flutter 好文~~~~ © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 添加APP启动 Story View","date":"2021-05-04T16:00:00.000Z","path":"2021/05/05/translation/story-view-in-flutter/","text":"原文 https://medium.com/flutterdevs/story-view-in-flutter-7bb4ae98b119 前言 在当前的快速市场中，一些社交渠道已经全面爆发，成为各个年龄段聚会的热门话题。漫步在数字环境中，你会注意到新的网络媒体应用程序，比如 Instagram，在过去的一年里热得像火一样。 当你听到“基于网络的媒体应用”这个词时，可能会出现 Facebook、 Instagram、 Twitter 或 Linkedin 等应用程序。然而，你有没有考虑过如何在 Instagram 这样的在线媒体应用程序上显示一个故事？在线媒体应用程序是一个开放的集会，您可以通过一个简单的用户界面与来自世界各地的个人进行联系。 在这个博客中，我们将探 Story View In Flutter 。我们将实现一个故事视图演示程序，以及如何在您的颤动应用程序中使用故事视图包创建类似 WhatsApp 的故事。 类库 https://pub.dev/packages/story_view/install 本文源码https://github.com/flutter-devs/flutter_story_view_demo 正文Flutter Story ViewStory View Flutter 组件工具对 Flutter 开发者很有帮助，通过使用这个类库，你可以显示社交媒体故事页面非常像 WhatsApp 状态故事或 Instagram 状态故事视图。同样可以像 Google 新闻应用程序一样使用内联/内部 ListView 或者 Column。伴随着手势暂停，向前，并进入后面的页面。 这个演示视频显示了如何创建一个 Flutter 的故事视图。它展示了如何在您的 Flutter 应用程序中使用故事视图包来工作。它可以像文本、图片、视频等一样显示你的故事。此外，用户将转发，先前，和手势暂停的情景。它会显示在你的设备上。 Features 功能Story View 的一些特性如下: 简单的文本状态故事 图像、 GIF 图像故事和视频故事(启用缓存) 为上一个、下一个和暂停故事做手势 每个故事项的标题 在每个故事视图的顶部有一个动画的进度指示器 Properties 属性Story View 的一些属性是: controller: 此属性用于控制 Story 的回放 onComplete: 此属性用于在显示 Story 的整个周期时进行回调。每当故事完成时，当 repeat 设置为 true 时，就会调用这个函数 storyItems: 此属性不为空，不显示页 onVerticalSwipeComplete: 此属性用于检测到垂直滑动手势时的回调。如果您不想收听这样的事件，请不要提供它 onStoryShow: 此属性用于当前显示故事时的回调 progressPosition: 此属性用于应放置进度指示符的位置 集成步骤 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 1234dependencies: flutter: sdk: flutter story_view: ^0.12.3 第二步: 导入 1import 'package:story_view/story_view.dart'; 第三步: 拉取包 1&gt; flutter packages get 代码实现你需要分别在你的代码中实现它: 在 lib 文件夹中创建一个名为 status_screen.dart 的新 dart 文件。 在这个屏幕上，我们将创建一个类似 WhatsApp 的用户界面。我们将添加一个容器小部件。在内部，我们将向 ListTile 添加网络图像、文本和 onTap 函数自动换行。在这个函数中，我们将导航到 StoryPageView() 类。 12345678910111213141516171819202122232425Container( height: 80, padding: const EdgeInsets.all(8.0), color: textfieldColor, child: ListView( children: &lt;Widget&gt;[ ListTile( leading: CircleAvatar( radius: 30, backgroundImage: NetworkImage( \"https://images.unsplash.com/photo-1581803118522-7b72a50f7e9f?ixid=MnwxMjA3fDB8MHxzZWFyY2h8MXx8bWFufGVufDB8fDB8fA%3D%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60\"), ), title: Text( \"Logan Veawer\", style: TextStyle(fontWeight: FontWeight.bold,color: white ), ), subtitle: Text(\"Today, 20:16 PM\",style: TextStyle(color:white.withOpacity(0.5)),), onTap: () =&gt; Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; StoryPageView())), ), ], ),), 当用户按下容器时，就会显示一个故事页面。我们将深入讨论下面的代码。当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 在 lib 文件夹中创建一个名为 story_page_view.dart 的新 dart 文件。 首先，我们将创建一个与 StoryController() 相等的 final_controller。 1final _controller = StoryController(); 我们将创建一个 storyItems 列表。首先，我们将添加 StoryItem.text 意味着只添加不同背景颜色的简单文本状态。其次，我们将添加 StoryItem.pageImage 的意思是用控制器添加图像的 URL 来控制故事。最后，我们将使用控制器和图像匹配添加 gif 视频的 URL。 123456789101112131415final List&lt;StoryItem&gt; storyItems = [ StoryItem.text(title: '''“When you talk, you are only repeating something you know. But if you listen, you may learn something new.” – Dalai Lama''', backgroundColor: Colors.blueGrey), StoryItem.pageImage( url: \"https://images.unsplash.com/photo-1553531384-cc64ac80f931?ixid=MnwxMjA3fDF8MHxzZWFyY2h8MXx8bW91bnRhaW58ZW58MHx8MHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60\", controller: controller), StoryItem.pageImage( url: \"https://wp-modula.com/wp-content/uploads/2018/12/gifgif.gif\", controller: controller, imageFit: BoxFit.contain),]; 我们将返回一个 Material() 方法。在这个方法中，我们将添加 StoryView()。在内部，我们将添加一个 storyItems、 controller、 inline means 列表，如果您希望将故事显示为整个页面，则将其设置为 false 。但是，如果您要将它作为页面的一部分(如 ListView 或 Column)显示，那么将其设置为 true。我们会添加重复意味着用户应该故事永远重复然后真实，否则，假。 12345678return Material( child: StoryView( storyItems: storyItems, controller: controller, inline: false, repeat: true, ),); 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 代码文件1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';import 'package:story_view/story_view.dart';class StoryPageView extends StatefulWidget &#123; @override _StoryPageViewState createState() =&gt; _StoryPageViewState();&#125;class _StoryPageViewState extends State&lt;StoryPageView&gt; &#123; final controller = StoryController(); @override Widget build(BuildContext context) &#123; final List&lt;StoryItem&gt; storyItems = [ StoryItem.text(title: '''“When you talk, you are only repeating something you know. But if you listen, you may learn something new.” – Dalai Lama''', backgroundColor: Colors.blueGrey), StoryItem.pageImage( url: \"https://images.unsplash.com/photo-1553531384-cc64ac80f931?ixid=MnwxMjA3fDF8MHxzZWFyY2h8MXx8bW91bnRhaW58ZW58MHx8MHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60\", controller: controller), StoryItem.pageImage( url: \"https://wp-modula.com/wp-content/uploads/2018/12/gifgif.gif\", controller: controller, imageFit: BoxFit.contain), ]; return Material( child: StoryView( storyItems: storyItems, controller: controller, inline: false, repeat: true, ), ); &#125;&#125; 总结在本文中，我已经解释了 Flutter 的基本结构的 Story View ; 您可以根据自己的选择修改这个代码。这是一个小的介绍 Story View 的用户交互从我这边，它的工作使用 Flutter。 老铁记得 点赞、转发 ，我将更有动力呈现 Flutter 好文~~~~ © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"这10个每个开发者都必须知道的Widgets","date":"2021-05-02T16:00:00.000Z","path":"2021/05/03/translation/these-10-flutter-widgets-every-developer-must-know/","text":"原文 https://genotechies.medium.com/these-10-flutter-widgets-every-developer-must-know-d0b61529796b 这些是我们将要讨论的 widgets: Dismissible SizedBox Draggable Flexible MediaQuery Spacer AnimatedIcon Placeholder RichText ReorderableListView 正文Dismissible滑动和隐藏是移动应用程序中常见的 UI 模式。要在 Flutter 做到这一点，可以使用 Dismissible widget。它有一个 child，background 和 key 。它将检测滑动手势和动画的 child 小部件。你也可以双向和垂直的交换。你可以用自己的方式使用更多的属性。您可以通过复制并粘贴下面的代码来尝试。 1234567891011121314151617181920212223242526272829303132333435class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; List&lt;String&gt; _values = ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5']; @override Widget build(BuildContext context) &#123; return ListView.separated( itemCount: _values.length, padding: const EdgeInsets.all(5.0), separatorBuilder: (context, index) =&gt; Divider( color: Colors.black, ), itemBuilder: (context, index) &#123; return Dismissible( key: Key('item $&#123;_values[index]&#125;'), onDismissed: (DismissDirection direction) &#123; if (direction == DismissDirection.startToEnd) &#123; print(\"Selected Item\"); &#125; else &#123; print('Delete item'); &#125; setState(() &#123; _values.removeAt(index); &#125;); &#125;, child: ListTile( leading: Icon(Icons.email, size: 50), title: Text(_values[index]), ), ); &#125; ); &#125;&#125; SizedBox这是一个小部件示例。当你有一个小部件，应该是固定的大小。例如，一个按钮的大小应该为 width = 100px 和 height = 50px。您需要将按钮包装在 SizedBox 中。下面是类的构造函数。 123456const SizedBox(&#123;Key key,double width,double height,Widget child&#125;) Draggable在许多应用程序中，我们可以看到拖动选项，如在电子邮件，文档拖动。有了这个 Flutter 小部件，很容易实现这个功能。在这里，我们拖动数据。这里我传递一个从 Draggable 到 DragTarget 的字符串。然后你需要说明你传递的数据是什么，子属性显示你的数据。DragTarget 目标是拖曳 Draggable 的着陆区。主要有三种调用方法。 onwillAccept: 以测试移动目标是否可以接受数据 onAccept: 调用有效的可拖动区域 onLeave: 当区域不成功时调用 Flexible大多数时候，我们使用行和列来显示一组子窗口小部件。但他们需要灵活的大小来显示与父母的相关性。您只需要将所有子窗口小部件包装在一个灵活的窗口小部件中。Flex 值决定每个子元素获得多少空间。当改变屏幕大小时，它不会改变儿童之间的比例。 12345678910111213141516171819202122child: Column( children: &lt;Widget&gt;[ Flexible( flex: 3, child: Container( color: Colors.red, ) ), Flexible( flex: 1, child: Container( color: Colors.green, ) ), Flexible( flex: 2, child: Container( color: Colors.blue, ) ), ],) MediaQuery如果你的目标是在手机和选项卡上运行你的应用程序，你的应用程序需要支持不同的用户界面大小。此外，有时用户有自己的 UI 期望，如字体大小或小，方向，填充等。使用这个 MediaQuery，您可以获得屏幕大小信息和用户首选项，并根据这些细节构建布局。 1234567891011121314151617const MediaQueryData(&#123; this.size = Size.zero, this.devicePixelRatio = 1.0, this.textScaleFactor = 1.0, this.platformBrightness = Brightness.light, this.padding = EdgeInsets.zero, this.viewInsets = EdgeInsets.zero, this.systemGestureInsets = EdgeInsets.zero, this.viewPadding = EdgeInsets.zero, this.alwaysUse24HourFormat = false, this.accessibleNavigation = false, this.invertColors = false, this.highContrast = false, this.disableAnimations = false, this.boldText = false, this.navigationMode = NavigationMode.traditional,&#125;) 这是一个提取屏幕尺寸的示例。 1MediaQueryData deviceInfo = MediaQuery.of(context); 输出 123I/flutter ( 6508): size: Size(360.0, 592.0)I/flutter ( 6508): padding: EdgeInsets(0.0, 24.0, 0.0, 0.0)I/flutter (6508) : Size: Size (360.0,592.0) i/flutter (6508) : padding: EdgeInsets (0.0,24.0,0.0,0.0) Spacer这是另一个小部件，您最好在事先自定义中使用它。在一行中，我们可以使用 MainAxisAlignment 定义子级之间的空间。但是使用 Spacer 小部件，你可以做得更多。只需在其他小部件之间添加间隔符即可。然后 children 扩展开来制造额外的空间。有一个 flex 属性来确定相对大小。 12345678910111213141516171819202122232425SizedBox( height: 50, child: Row( children: &lt;Widget&gt;[ Container( width: 50, color: Colors.red, ), Spacer(flex: 2,), Container( width: 50, color: Colors.green, ), Spacer(flex: 1,), Container( width: 50, color: Colors.blue, ), Container( width: 50, color: Colors.yellow, ), ], ),); AnimatedIcon已经有一个巨大的图标集已经在框架。也有动画图标，你可以在你的应用程序中使用。要使用这些，我们需要一个 AnimatedIcon 小部件。你需要提供图标和主要的进度属性。Flutter 提供了许多不同的动画图标供您使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import 'package:flutter/animation.dart';import 'package:flutter/material.dart';void main() =&gt; runApp(LogoApp());class LogoApp extends StatefulWidget &#123; _LogoAppState createState() =&gt; _LogoAppState();&#125;class _LogoAppState extends State&lt;LogoApp&gt; with SingleTickerProviderStateMixin &#123; bool isPlaying = false; Animation animation; AnimationController controller; @override void initState() &#123; super.initState(); controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( body: Center( child: IconButton( iconSize: 70, icon: AnimatedIcon( icon: AnimatedIcons.play_pause, progress: controller, ), onPressed: () =&gt; _onpressed(), )), ), ); &#125; @override void dispose() &#123; controller.dispose(); super.dispose(); &#125; _onpressed() &#123; setState(() &#123; isPlaying = !isPlaying; isPlaying ? controller.forward() : controller.reverse(); &#125;); &#125;&#125; Placeholder有时您需要为 UI 的特定组件保留空间，直到最后确定该组件的视图。因此，与其保留一个空间，我们可以在那里放置 Plaholder 以便进一步实现。在你可以开始实施它之后。这将填补所有提到的空间。 1234567891011121314151617181920212223Center( child: Column( children: &lt;Widget&gt;[ Container( child: Placeholder() ), Expanded( child: Row( children: &lt;Widget&gt;[ Flexible( flex: 1, child: Placeholder(color: Colors.red,), ), Flexible( flex: 4, child: Placeholder(color: Colors.green,), ), ], ), ) ], )), RichText文本是每个应用程序的主要 UI 组件之一。因此字体设计非常重要。你必须注意文字的样式和外观，如文字大小、字体、样式等。有时候你需要显示一个结合了不同风格的段落。用粗体表示强调，或用斜体表示，或用下划线表示，或用不同的颜色，不同的字体大小，或同时显示所有内容。你最好使用 RichText。下面是一个例子: 12345678910RichText( text: TextSpan( style: TextStyle(color: Colors.black, fontSize: 24), children: &lt;TextSpan&gt;[ TextSpan(text: 'Flutter ', style: TextStyle(color: Colors.red)), TextSpan(text: 'Placeholder '), TextSpan(text: 'Widget', style: TextStyle(decoration: TextDecoration.underline, fontStyle: FontStyle.italic)) ], ),) ReorderableListView在我们的应用程序中，我们使用列表视图来显示一组数据并滚动它们。通常，您不能移动和更改列表中的位置。ReorderbaleListView 是解决方案。有了它，用户可以长时间按下该项目，并将其放入一个新的他或她喜欢的地方。列表视图的每个项都有一个用于标识该项的键，在移动该项时，调用 onReorder 方法并跟踪移动和更改。下面是一个例子。 12345678910111213141516171819202122232425262728293031323334353637383940class _TopListState extends State&lt;TopList&gt; &#123; List&lt;String&gt; topMovies = [ \"It Happened One Night(1934)\", \"Black Panther(2018)\", \"Citizen Kane(1941)\", \"Parasite (Gisaengchung)(2019)\", \"Avengers: Endgame(2019)\", \"The Wizard of Oz(1939)\", \"Casablanca(1942)\", \"Knives Out(2019)\" ]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"ReorderableListView Example\"), ), body: ReorderableListView( onReorder: (int oldIndex, int newIndex) &#123;&#125;, children: getListItems(), ), ); &#125; List&lt;ListTile&gt; getListItems() =&gt; topMovies .asMap() .map((i, item) =&gt; MapEntry(i, buildTenableListTile(item, i))) .values .toList(); ListTile buildTenableListTile(String item, int index) &#123; return ListTile( key: ValueKey(item), title: Text(item), leading: Text(\"$&#123;index + 1&#125;\"), ); &#125;&#125; © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 移动安全 ー Ep.2 Strong Device/ Strong Pin","date":"2021-04-29T16:00:00.000Z","path":"2021/04/30/translation/mobile-security-via-flutter-ep-2-strong-device-strong-pin/","text":"原文 https://medium.com/kbtg-life/mobile-security-via-flutter-ep-2-strong-device-strong-pin-70b4322bffc2 前言 在本期节目中，我们将进一步强化您的移动应用程序。“但是怎么做呢?”你可能会好奇。让我们把它比作建造一座房子。为了确保它配备了最高级别的安保系统，你可能需要在房子周围安装所有的警报器和摄像头。但是如果你碰巧把钥匙留在门口，这些都不重要了！对于安全性，我们需要考虑一个坏黑客可能选择攻击的每一种可能性，所以这不仅仅是一个解决方案，然后，一切都完成了。我们必须确保外部和内部的应用程序都是安全的。 上一集，我们讨论了 SSL。你可以把它想象成房子周围高高的篱笆。虽然爬过去比较困难，但还是可以管理的。因此，在本期节目中，我们将确保没有人意外地把钥匙落在门口。 https://medium.com/kbtg-life/mobile-security-via-flutter-ep-1-ssl-pinning-c57f18b711f6 在 iOS/Android 中，已经有一个本地安全 API 来保护他们的应用程序不受外界的攻击，所以我们将使用这个 API 来实现 Flutter。让我们来看看什么是必要的，什么是美好的。 参考 https://pub.dev/packages/flutter_secure_storage https://www.macrumors.com/2020/12/16/ios-14-installed-81-percent-iphones/ https://pub.dev/packages/flutter_jailbreak_detection https://developer.apple.com/documentation/localauthentication/logging_a_user_into_your_app_with_face_id_or_touch_id https://frida.re/ https://developer.android.com/training/sign-in/biometric-auth#crypto https://medium.com/androiddevelopers/using-biometricprompt-with-cryptoobject-how-and-why-aace500ccdb7 https://github.com/zionspike/android-FingerAuthenSample-Asym https://www.researchgate.net/publication/313823128_Understanding_Human-Chosen_PINs_Characteristics_Distribution_and_Security 正文强制性安全的数据存储基本上有两件事你需要记住: 不要在应用程序中保存任何安全信息，比如名字、姓氏、电子邮件、用户名、密码、公民身份，或任何能让黑客追踪并查出用户身份的信息。如果你真的需要保存它，比如一个令牌或者任何你想用来改善用户体验的东西，确保你把它保存在两个操作系统平台都提供的安全的数据存储中。为此，我使用了这个库。 https://pub.dev/packages/flutter_secure_storage 对于 iOS，他们使用 Keychain，即使你删除了应用程序也不会被删除，而对于安卓，他们使用 KeyStore 来存储解密保存的数据的密钥。 额外的安全层总是加密的安全信息，即使 iOS/Android 已经有了安全存储。这是因为在未来，可能会有一种工具，可以让黑客破解设备上的加密。既然我们在讨论加密的话题，我们也需要讨论一下密钥。它应该是动态的和唯一的每个用户，所以我们决定使用用户自己的密码，因为我们可以肯定，只有应用程序所有者知道如何解密它与正确的密码和访问所有保存的数据。 然而，这意味着密码被秘密保存在设备上。如果一个黑客暴力破解了一个密码，他们就会知道这是正确的密码，这可能会更加危险。他们将有足够的时间解密，因为它是在设备上，所以我们的解决方案是使用另一层保护。我们允许黑客使用任何密钥解密，这样他们就不知道哪个是正确的密钥来调用我们的服务器。如果他们输入错误的密码 3 次，后端会自动锁定他们。这将解决这个问题。这里不提供使用任何密钥进行解密的解决方案。 关闭生产中的日志开发人员需要一个日志来查看他们的代码是否正常工作。这对于非生产环境来说没有问题，但是对于生产环境来说，您需要关闭它以防止任何人看到它。为此，我通过在 main.dart 中调用以下代码来覆盖 debugPrint 函数 1debugPrint = (String message, &#123;int wrapWidth&#125;) &#123;&#125;; 这意味着如果我们使用 debugPrint，它将不会打印任何东西。我把它划分为 main_dev。飞镖和主电极。然后把这个函数放在 main_prod 中。这样我们就看不到任何生产日志了。至于非刺激性构建，您可以就这样保留它。没有必要添加任何东西。我们为什么一定要关掉这根木头？这是因为我们不想让任何人看到幕后的应用程序。不要给黑客任何他们下一步行动应该是什么的线索。 从现在开始只使用 debugPrint 而不是 print 不支持旧版本操作系统我们必须把这个设置成本地，而不是 Flutter。我并不是真的担心 iOS，因为 iOS 用户倾向于根据本文的采用率频繁更新操作系统。 https://www.macrumors.com/2020/12/16/ios-14-installed-81-percent-iphones/ 在 iOS 14 发布后仅仅 3 个月，81% 的设备都更新了他们的操作系统。请记住，安全就像猫和老鼠，您需要一直远离潜在的威胁。我们不应该因为操作系统的安全漏洞而尝试支持过时的操作系统版本。在我看来，只支持最新版本或者更早的版本是可以的。例如，现在我们有 iOS 14，所以我们应该只支持 iOS 12,13 和 14。这将允许 98% 的用户使用你的应用程序。我们可以在 Xcode 设定一个最低目标来控制它。 与此同时，Android 是开源的，这意味着谷歌无法控制它。因此，收养率非常低。看看 Android 的公告，看看哪些 Android 操作系统正在变得过时，没有更多的安全补丁。现在他们仍然支持 Android 8.0，所以我们可能不得不将 minSdkVersion 的目标定为 build.gradle 为 26。 简而言之，iOS = 12 及以上/Android = 26 及以上 只在你需要的时候请求许可所有开发人员都应该知道的一件基本事情是，总是在需要时请求权限。不要从一开始就要求许可，只要求你需要的东西。例如，一些应用程序可能会要求访问您的 GPS 位置，即使没有任何功能需要它。你永远不应该这样做，因为两件事。首先，你在收集不必要的数据，这些数据是用户的私人数据。其次，如果这些数据没有被正确实现，黑客也可以访问这些数据。因此，为了安全起见，只问你需要什么和什么时候需要它。当用户第一次打开应用程序时，你不希望用户体验是 10 个弹出窗口。用户将离开，再也不会回来。 越狱检测对于 Flutter，我们使用了原生的越狱检测填充，比如用于安卓系统的 Rootbeer 和用于 iOS 系统的 DTTJailbreakDetection。这两个都是著名的。对于 Flutter，我使用这个库。 https://pub.dev/packages/flutter_jailbreak_detection 尽管对于有经验的黑客来说，它可能还不够强大，但至少我们有东西可以保护我们的应用免受没有经验的黑客的攻击。他们在商业 SDK 中有几个解决方案来保护这一个，但是他们不是强制性的。除非你的应用需要高安全级别，否则 Flutter 越狱检测应该足够了。 利用密码技术进行生物测定目前，许多应用程序为了更好的用户体验而实现了生物特征识别认证。然而，他们中的大多数人只是相信 iOS/Android，我并不真的推荐这样做。首先，我们可能会在 Swift 中看到这样的代码，甚至苹果也推荐这样的代码。 https://developer.apple.com/documentation/localauthentication/logging_a_user_into_your_app_with_face_id_or_touch_id 12345678let reason = “Log in to your account”context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: reason ) &#123; success, error in if success &#123; // Login Succeed, do something next &#125; else &#123; // Failed, somebody else!! &#125;&#125; 每个人都会相信他们的设备。为什么不呢? 嗯，实际上有一个工具叫做 Frida 脚本。 https://frida.re/ 浏览之后，你会发现使用这个工具绕过生物计量学工具是多么容易。 这里的教训是 DO n’t just trust boolean from devices。这里有一个来自谷歌的教程，其他人已经在 Android 版本中实现了它。 https://developer.android.com/training/sign-in/biometric-auth#crypto https://medium.com/androiddevelopers/using-biometricprompt-with-cryptoobject-how-and-why-aace500ccdb7 https://github.com/zionspike/android-FingerAuthenSample-Asym 这是生物识别和密码复查的结合。您可以使用同样的概念扑动。也就是说，如果你的应用程序没有任何金融或在线支付功能，你可以跳过这一部分。 不要用纯文本发送密码有些人可能会说 HTTPS 是足够安全的，为什么我们必须关心以纯文本发送密码？事实上，黑客可以使用 MITM (中间人攻击文档)以纯文本形式轻松检索你的信息。这就是为什么我们应该在离开移动应用程序之前对密码进行修改，以防黑客窃听，最好的方法就是用盐来修改密码。 hash(password + dynamic salt) 盐应该在短时间内频繁更换，我们可以做一些基本的事情。 hash(password + userID) 尽管用户 ID 是唯一的和动态的，但它并不总是变化的。尽管如此，对于基本安全来说，这是可以接受的。然而，如果你想要实现完全的安全性，你必须找到其他一直在改变的东西，并且使用缓慢的散列算法，比如 Bcrypt 而不是 SHA256，因为它们需要特殊的硬件来破解。 可选，最好去做这部分是针对需要额外安全性的金融或银行应用程序。 反调试对于安卓系统，我们将其分为多个功能 关闭 Debuggable 在 buildTypes 部分中添加此标志以 build.gradle。将 release 设置为 false，debug 设置为 true，或者如果需要，可以将两者都设置为 false。 1234567891011121314buildTypes &#123; release &#123; debuggable false signingConfig signingConfigs.release minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; debug &#123; debuggable true signingConfig signingConfigs.release &#125;&#125; 阻止调试器 12345678910111213141516171819// Open ADB Debuggingif (Settings.Secure.getInt(this.applicationContext.contentResolver, Settings.Global.ADB_ENABLED, 0) == 1) &#123;&#125;// Check by using `adb shell getprop ro.crypto.type`if ((applicationContext.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager).storageEncryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED) &#123;&#125;// flag debuggable in gradle is trueif ((0 != applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE || BuildConfig.DEBUG)) &#123;&#125;// Use Debugger in Android Studio to connect for getting logif (Debug.isDebuggerConnected() || Debug.waitingForDebugger()) &#123;&#125; 您可以复制上面的代码并将其粘贴到 MainActivity.kt。如果是真的，你可以把用户踢出去或者做任何你想做的事情。请允许我解释一下。 打开 ADB 调试防止用户打开 ADB 模式。虽然这没有必要，因为大多数 Android 开发人员总是在需要测试应用程序的时候打开它。这取决于你是否祝酒消息警告用户或评论它出来。 不支持 ENCRYPTION _ status _ unsupported 以检查设备是否支持存储加密。在安卓系统中，默认情况下它应该是开启的。如果它被关闭了，那么他们的设备就出了问题，因为用户通常不能自己做到这一点。为了防止上述风险，我们只是不允许任何人使用它。 ApplicationInfo.FLAG_DEBUGGABLE 检查我们在 Gradle 添加的标志调试是否为 true。如果没有，不要让用户使用它。和上一个一样，这是用户无法改变的东西，除非有人反向工程你的应用程序，并打包为 APK 再次。 来检查你的应用程序是否连接到了 Android Studio 调试器。如果是，不要让用户使用它。 至于 iOS，现在还没有简单的方法来实现它，但是你可以找到一些商业 SDK 来帮助你实现它。 检查设备是否有安全访问有些用户可能决定不在他们的设备上安装针、手指扫描或面部扫描。如果有人偷了他们的设备，他们只需要解锁就可以了。拥有这种类型的安全措施就像是安全的第一道门。 在 Android 中，我使用 Flutter 通道调用 Flutter 来配置 FlutterEngine 功能，让 Flutter 来决定如何处理这个用户。下面是 Android 的代码，用来检查设备是否有密码。 12345678private val CHANNEL = &quot;com.kbtg.flutter&quot;MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler &#123; call, result -&gt; if (call.method == &quot;getDeviceHasPasscode&quot;) &#123; result.success((getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager).isDeviceSecure) &#125; else &#123; result.notImplemented() &#125;&#125; 请拨打以下电话到 Flutter。 1234567891011121314try &#123; final hasPasscode =await Storage.platform.invokeMethod(&apos;getDeviceHasPasscode&apos;); if (!hasPasscode) &#123; Toast.show( &quot;No pin, DANGER DANGER&quot;, context, duration: 5, gravity: Toast.BOTTOM, ); &#125;&#125; on PlatformException catch (e) &#123; debugPrint(&quot;==== Failed to scan security &apos;$&#123;e.message&#125;&apos; ====&quot;);&#125; 如果 hasPasscode 是错误的，我们只是烤的消息，以警告用户，你没有一个针激活在您的设备。 如果需要，关闭第三方键盘有些第三方键盘可能是恶意的。你永远不会知道他们是否已经实现了秘密地将你输入的密码发送到他们的服务器上的功能。对于 Android 来说，没有简单的方法来防止这种情况，因为所有的键盘都算作第三方键盘，甚至 Android 自己的键盘。解决这个问题的办法是自己实现一个安全的键盘，方法是使用带有字母和数字的布局从头开始构建一个键盘。 但是，对于 iOS 系统，我们可以使用下面的函数来禁用它，只限制使用本地键盘 123override func application(_ application: UIApplication, shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplicationExtensionPointIdentifier) -&gt; Bool &#123; return extensionPointIdentifier != .keyboard&#125; 检查代码完整性可以对 IPA 和 APK 进行反编译，以更改内部的一些代码并重新构建以便再次发布。黑客修改的代码可能是你连接到同一个服务器，但是每个信息也会推送到黑客的服务器。对于 IPA 来说，我并不担心，因为从 App Store 以外安装应用程序是相当复杂的。你必须先安装证书并接受某些条件或破解你的设备才能安装它。至于安卓系统，它很容易伪造一个应用程序，因为它更开放，允许任何用户安装外部的 APK 只需要 1-2 次点击。 这就是代码完整性的用武之地。你可以计算你的应用程序的校验和，并在每次打开应用程序之前检查它是否仍然和你部署到应用程序商店的应用程序一样。这个概念听起来很简单，但是很难实现。幸运的是，有一个商业 SDK 可以解决这个问题，所以我们不需要自己动手。 代码混淆对于我们实现或保存到应用程序中的所有业务逻辑和安全逻辑，我们需要确保没有人能够反编译并查看源代码。如果黑客能看到它，他们就会知道我们用哪种逻辑来加密数据，或者我们在哪里存储安全信息。他们可以模仿这种逻辑，发送到他们的服务器，而不是使用我们的应用程序。对于代码混淆，可以使用商业 SDK 来加强应用程序。 你可能已经注意到我经常提到商业 SDK。有些人可能会想，“如果是这样的话，这篇文章的意义何在？我写这篇文章是为了寻找一种在应用程序中实现它的方法，而不是仅仅转到另一个链接。” 没有人什么都擅长。使用商业 SDK 就像拥有一个专注于安全工作的专业团队。你自己不能实现和关闭所有的安全漏洞，所以最好把它留给专家，他们知道他们在做什么，你做你最擅长的是开发应用程序。 现在你的应用外壳更加坚固，你的用户不再把钥匙留在门上，让我们确保房子的钥匙不容易被复制。我说的是密码和密码 Stronger PinPin 或 password 是一种确认你是账户真正所有者的方法。我们选择为应用程序设置一个密码，有两个原因。 更好的用户体验尽管密码更安全，但考虑到 A-Z、0-9 和特殊字符可以组成十亿种可能的组合，在设备上使用小键盘输入太难了。在进入你的应用程序之前，你可能会花费大量的时间。这就是为什么我们采用一个 6 位数的引脚来代替。虽然你只能用 4 个数字创建 10,000 个可能的引脚，但 6 个数字给你 1,000,000 个可能性，这是 100 倍的难度。 人们可以在 2-3 秒内输入一个密码，但是一个密码可能会花费他们 10-15 秒，这取决于它有多难。 易于记忆是的，我们希望让黑客难以破解密码，但我们也希望我们的用户能够不费吹灰之力地记住它。由于 pin 是 iOS/Android 的基本安全访问设备，它不应该发布任何挑战，因为用户已经习惯了 对于销子，我们不想让它变得太容易。“‘太容易’到底是什么意思?”你问。好吧，让我们说得更具体一点。 针没有标准，所以我从网上的研究中得出了一个想法。请看下面的链接。 https://www.researchgate.net/publication/313823128_Understanding_Human-Chosen_PINs_Characteristics_Distribution_and_Security 根据上述模式，我们得出以下规则 不允许有序列号，例如 123456、234567、345678 ー包括反序列号，例如 654321、543210 不要使用「同一行别针」 ，例如 123123、456456、789789 只允许 3 个或 3 个以上的唯一数字，例如 122112 个是不允许的，但 123321 个是可以的(即使这可能与上面的统计数据相矛盾)155115,133133,166661 是不允许的，因为只有两个不同的数字在密码中使用 有些人甚至建议禁用生日别针，比如如果你的生日是 1986 年 6 月 8 日，你就不能用 080686 作为别针来防止黑客利用这些信息入侵。但是，我不这样做只是因为我不在系统中保存用户的生日 我们不想制定太多的规则。否则，你会删除所有的密码组合，更糟糕的是，黑客更容易暴力破解它。我们可以制定更多的规则，但是如果 100 万种可能性变成 100-200 个引脚，那又有什么意义呢？ 使用上面的方法，我们仍然有大约 60,000 种可能性供用户使用。下面是实现它的示例代码。 12345678910111213141516171819202122static bool isPinComplexity(String pin) &#123; const notAllowListPin = [ &quot;123123&quot;, &quot;456456&quot;, &quot;789789&quot;, &quot;012345&quot;, &quot;123456&quot;, &quot;234567&quot;, &quot;345678&quot;, &quot;456789&quot;, &quot;567890&quot;, &quot;098765&quot;, &quot;987654&quot;, &quot;876543&quot;, &quot;765432&quot;, &quot;654321&quot;, &quot;543210&quot; ]; final pinSet = new Set.from(pin.split(&quot;&quot;)); final uniqueCharacter = pinSet.length &gt; 2; return uniqueCharacter &amp;&amp; !notAllowListPin.contains(pin);&#125; 您可以使用 isPinComplexity 来检查引脚。如果返回 true，我们允许用户添加它。不要忘记将所有可能的散列也添加到后端。我们在前端实现只是为了更好的用户体验，这样用户就不必打电话给网络，从服务器和服务器上被拒绝，以确保如果黑客试图绕过别针，服务器将不允许它。 你可以根据你的需要在 notAllowListPin 中添加更多的条件，但是我现在很好。 因此，对于我们实施的所有这些解决方案，我们要确保我们的应用程序配备了另一层保护。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 移动安全 ー Ep.1 SSL Pinning","date":"2021-04-28T16:00:00.000Z","path":"2021/04/29/translation/mobile-security-via-flutter-ep-1-ssl-pinning/","text":"原文 https://medium.com/kbtg-life/mobile-security-via-flutter-ep-1-ssl-pinning-c57f18b711f6 前言 这篇文章还是很好的，作者是一个银行从业者，简单说就是在你的程序里指定 ssl 通讯证书，提供安全性。 为啥这样做呢，比如你用公共 wifi ，这时候打开 www.taobaomy.com 竟然证书显示机构 “淘宝官方”，这显然是伪造的。 还有你确实访问了 www.taobao.com ，但是被公共 wifi 中间劫持替换证书，重定向去了他的网站，你输入的 用户名、密码 都被窃取了。 所以说呢，验证通讯证书很有必要。 如果觉得好，请分享到朋友圈。 参考 https://owasp.org/ https://api.flutter.dev/flutter/dart-io/HttpClient/badCertificateCallback.html https://github.com/dart-lang/sdk/issues/39425#issuecomment-680312787 https://pub.dev/packages/ssl_pinning_plugin 正文由于 2019 冠状病毒疾病的流行，我们看到移动应用程序的使用量有了很大的增长。开发人员必须不断跟上新特性的发展，或者改善更好的用户体验。随着一切都在网上进行，越来越多的钱涌入这个行业，这些自然而然的坏家伙(也就是坏黑客)想要利用它。我敢肯定我们都知道设计思维和如何与用户产生共鸣，因为如果我们从未使用过我们的产品，或者更糟糕的是，喜欢它，你还能指望用户如何喜欢我们的产品吗？是时候设身处地为别人着想了。在 KBTG，我们有一个叫做“狗食”的程序。你们中的一些人可能听说过这个成语“吃自己的狗粮”。这意味着你必须在别人喜欢你的产品之前使用你的产品，坚持使用你的产品，并且热爱你的产品。有些人可能会认为用户喜欢的是前沿的特性或者很酷的设计，但是在 KBTG，我们不仅仅局限于其中的两个。 安全是我们同情用户的另一个重要组成部分。他们信任我们，向我们提供他们有价值的私人信息，所以我们的荣誉和责任就是为我们的系统提供完全的内部和外部保护。所谓内部人员，我们指的是像我们这样的开发人员。出于数据隐私的原因，我们根本没有能力查看我们的数据库或查看用户的信息。所有的东西都是加密的，我们的团队中没有人可以访问这个密钥。这个过程表明我们是多么关心我们的用户。对我们来说困难的部分是当我们遇到一个问题，它是很难调查，因为我们没有访问原始数据来解决它，但我们接受这个挑战，因为我们自豪地保护我们的用户隐私。 在本系列文章中，我将分享我从银行业工作中获得的知识，我坚信这些知识体现了最高安全性的领域。我的向导没那么难。我只是遵循 OWASP 的标准。 https://owasp.org/ 我会告诉你如何在 Flutter 中实现这个。我们还没有尝试开发一个具有超级安全性的应用程序，但这将是指导所有移动应用程序的基本的，必须具备的安全性。实现过程并不复杂。这可能需要你 10 天左右的时间来开发。是的，只有 10 天！与通常需要 80-90 天的功能相比，这听起来几乎没什么。让我们从 SSL 钉住开始本系列的第一集。 SSL PinningSSL Pinning 可以防止 MITM (Man in the Middle Attack) ，但那到底是什么呢？ 简而言之，当你连接到一个公共 WIFI 或热点时，负责网络的 IT 人员，无论好坏，都可以把流量从你的移动设备传送到你连接的服务器。想了解更多细节，你可以去专业网站上查找，比如下面的一个。底线是不要使用公共 WIFI 或任何其他人的热点！ Credit 信用 https://www.guardsquare.com/en/blog/iOS-SSL-certificate-pinning-bypassing 开始实现如果您正在调查 Stackoverflow 关于 Flutter 或 Dart 中 SSL pinting 的内容，那么您可能会找到一个关于 badCertificateCallback 的解决方案。 https://api.flutter.dev/flutter/dart-io/HttpClient/badCertificateCallback.html 基本上，您可以通过告诉 Flutter 不要信任任何证书(除了您在移动应用程序中提供的证书)来覆盖 Flutter。下面是如何实现的方法。 12345HttpClient _client = new HttpClient(context: await globalContext);_client.badCertificateCallback =(X509Certificate cert, String host, int port) =&gt; false;var _ioClient = new IOClient(_client);_ioClient.get(url) 创建 HttpClient，将 globalContext 传递给它，并将 badcertificateecallback 分配为 false。 获得 ioClient 之后，可以使用它调用 GET、 POST、 PUT、 DELETE。上面的代码表明我只会信任其中的两个证书，因此如果其他证书在移动应用程序有请求时被发送，它将在获得 badCertificateCallback 后停止工作。 以下是获取 GlobalContext 的方法。 1234567891011Future&lt;SecurityContext&gt; get globalContext async &#123; // Note: Not allowed to load the same certificate final sslCert1 = await rootBundle.load('assets/cert/certificate.pem'); final sslCert2 = await rootBundle.load('assets/cert/certificate2.pem'); SecurityContext sc = new SecurityContext(withTrustedRoots: false); sc.setTrustedCertificatesBytes(sslCert1.buffer.asInt8List()); sc.setTrustedCertificatesBytes(sslCert2.buffer.asInt8List());return sc;&#125; 为了获得 certificate.pem，我使用这个脚本从服务器获得公钥，并在 Terminal 中运行这个命令以获得 certificate.pem 文件。不要忘记在没有 HTTP 或 HTTPs 的情况下将“ your-url. com”更改为您的网站。 1openssl s_client -showcerts -connect your-url.com:443 -servername your-url.com &lt;/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; certificate.pem 一旦你获得了 certificate.pem，把你的证书放到你的目标资产中，并将你的资产添加到 pubspec.yaml 中。我将它添加到 cert 文件夹中。 12assets: - assets/cert/ 您可以设置任意多的信任证书，但我通常只设置四个证书。原因是你拥有的越多，你就越容易被黑客攻击。但是为什么是四个呢？对于防火墙，我使用 Akamai 在到达服务器之前阻止和过滤请求，消除系统中的坏请求、匿名请求和 DDoS 攻击。因此，两个证书是为 Akamai，而其他两个是为了更新证书在未来。我曾经试图固定相同的证书或无效的证书，结果 Dart 像预期的那样抛给我一个错误。 一旦我们完成了以上所有的工作，一切似乎都在工作。如果您更改了服务器上的证书，应用程序将停止工作。呜呼！任务完成了，对吧？一开始是我..。 直到我发现了 badCertificateCallback 的一个大问题。 https://github.com/dart-lang/sdk/issues/39425#issuecomment-680312787 原来 badCertificateCallback 在没有检查通用名称的情况下就固定了中间证书，这造成了一个严重的安全问题，因为坏的黑客也可以创建这些证书。例如，在我的例子中，我将 Let’s Encrypt 作为一个中间证书，因此如果一个黑客创建了假证书并将其发送到我们的应用程序，它将接受这个请求！因为我们不检查通用名称，并假设证书来自同一证书提供程序。 为了解决这个问题，我还必须使用另一种方法检查该证书的 SHA256。 123456Future&lt;bool&gt; get _isAllowList async &#123; const myAllowList = \"xxxxxxx\"; final x509Cert1 = await _readPemCert('assets/cert/certificate.pem'); X509CertificateData data = X509Utils.x509CertificateFromPem(x509Cert1); return data.sha256Thumbprint == myAllowList&#125; 来自下面的函数。这可能不是一个好的解决方案，因为我不知道证书是如何工作的，所以我只使用字符串操作: p 基本上，我只是削减了证书的其他部分，只得到最后一部分。 12345678Future&lt;String&gt; _readPemCert(String path) async &#123; final sslCert = await rootBundle.load(path); final data = sslCert.buffer.asUint8List(); final pemString = utf8.decode(data); final pemArray = pemString.split(\"-----END CERTIFICATE-----\"); final cert = [pemArray[0], \"-----END CERTIFICATE-----\"].join(\"\"); return cert;&#125; 然后，我使用 libs basic_utils 来解析证书。把这个加到你的 pubspec.yaml 里。我不能用 basic 语言解析整个证书，所以我必须这样做。 1basic_utils: ^2.7.0-rc.4 使用 get X509Utils 获得 sha256 来与允许列表进行比较，这个允许列表在省道中保存为常量。现在，我们可以使用两个方法(badCertCallback 和 X509Utils)再次检查安全性，以查看添加到允许列表中的证书和来自服务器的 Sha256 是否相同。 最近，在我实现了我的方法之后，我发现了一个关于 SSL 固定的新的库。 https://pub.dev/packages/ssl_pinning_plugin 由于我的解决方案已经被移动安全渗透测试接受，我还没有测试过这个解决方案，所以我决定坚持使用旧的解决方案。它可能看起来不那么干净，但是它正如预期的那样工作，所以我称之为成功。 © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 中使用 HUD Progress 组件","date":"2021-04-27T16:00:00.000Z","path":"2021/04/28/translation/hud-progress-in-flutter/","text":"原文 https://medium.com/flutterdevs/hud-progress-in-flutter-281ed0f644d0 前言在 flutter 中，我们显示任何进度指示器，因为我们的应用程序是繁忙的或在搁置，为此，我们显示一个循环的进度指示器。覆盖加载屏幕显示一个进度指示器，也称为模态进度 HUD 或平视显示，这通常意味着应用程序正在加载或执行一些工作。 在本文中，我们将利用 HUD 进程程序包来探讨平视显示器在 flutter 方面的进展。有了这个软件包，我们可以很容易地实现平视显示的颤振进度。那么让我们开始吧。 pub.devhttps://pub.dev/packages/flutter_progress_hud https://pub.dev/packages/flutter_progress_hud/example 正文HUD ProgressFlutter HUD Progress 是一种进度指示器库，就像一个循环的进度指示器。在这里，HUD 意味着一个抬头显示器/进度弹出对话框将打开以上的屏幕，将有一个循环的进度指示器。使用这个库，我们可以使用我们的 flutter 。应用程序可以显示循环进度指示器。 属性 borderColor:边框/颜色: 边框颜色属性用于更改指示符背景边框颜色 backgroundColor:背景颜色: 背景颜色属性用于更改指示器背景的颜色 indicatorColor:标志/颜色: 背景颜色属性用于更改指示器背景的颜色 textStyle:文字样式: 属性用于指示符下面显示的文本，文本的颜色和样式可以在该属性中更改 安装 第一步: 添加依赖项 将依赖项添加到 pubspec ー yaml 文件。 12dependencies: flutter_progress_hud: ^2.0.0 第二步: 导包 1import 'package:flutter_progress_hud/flutter_progress_hud.dart'; 第三步: 启用 AndriodX 1234org.gradle.jvmargs=-Xmx1536Mandroid.enableR8=trueandroid.useAndroidX=trueandroid.enableJetifier=true 例子在 lib 目录中创建一个名为 progress_hud_demo.dart 的新 dart 文件。 在创建 Flutter HUD Progress 之前，我们包装了一个进度遮光罩的容器，其次是建设者类。在内部，我们使用了我们的小部件，并定义了进度指示器的边框颜色和背景颜色。让我们详细地了解一下这一点。 1234567891011ProgressHUD( borderColor:Colors.orange, backgroundColor:Colors.blue.shade300, child:Builder( builder:(context)=&gt;Container( height:DeviceSize.height(context), width:DeviceSize.width(context), padding:EdgeInsets.only(left:20,right:20,top:20), ), ),), 现在我们已经采取了一个按钮，在其中指示器设置持续时间 5 秒的指示器时间未来。delayed() 并显示进度的文本。 123456789101112131415Container( margin: EdgeInsets.only( left:20.0, right:20.0, top:55.0), child: CustomButton( mainButtonText:'Submit', callbackTertiary:()&#123; final progress = ProgressHUD.of(context); progress.showWithText('Loading...'); Future.delayed(Duration(seconds:5), () &#123; progress.dismiss(); &#125;); &#125;, color:Colors.blue, ),), 当我们运行应用程序时，我们应该得到屏幕的输出，就像下面的屏幕截图一样。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import 'package:flutter/material.dart';import 'package:progress_hud_demo/shared/custom_button.dart';import 'package:progress_hud_demo/shared/custom_text_field.dart';import 'package:progress_hud_demo/themes/device_size.dart';import 'package:flutter_progress_hud/flutter_progress_hud.dart';class ProgressHudDemo extends StatefulWidget &#123; @override _ProgressHudDemoState createState() =&gt; _ProgressHudDemoState();&#125;class _ProgressHudDemoState extends State&lt;ProgressHudDemo&gt; &#123; bool _isInAsyncCall = false; @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor:Colors.white, appBar:AppBar( backgroundColor:Colors.blue, title:Text('Flutter HUD Progress Demo'), elevation:0.0, ), body:ProgressHUD( borderColor:Colors.orange, backgroundColor:Colors.blue.shade300, child:Builder( builder:(context)=&gt;Container( height:DeviceSize.height(context), width:DeviceSize.width(context), padding:EdgeInsets.only(left:20,right:20,top:20), child:Column( crossAxisAlignment:CrossAxisAlignment.start, children: [ Column( crossAxisAlignment:CrossAxisAlignment.start, children: [ Text('Sign In',style:TextStyle(fontFamily:'Roboto Bold',fontSize:27,fontWeight:FontWeight.bold),), ], ), SizedBox(height:50,), Column( children: [ CustomTextField(hintText: 'Email', type:TextInputType.text, obscureText: false), SizedBox(height:35,), CustomTextField(hintText: 'Password', type:TextInputType.text, obscureText: true), ], ), Container( margin: EdgeInsets.only( left:20.0, right:20.0, top:55.0), child: CustomButton( mainButtonText:'Submit', callbackTertiary:()&#123; final progress = ProgressHUD.of(context); progress.showWithText('Loading...'); Future.delayed(Duration(seconds:5), () &#123; progress.dismiss(); &#125;); &#125;, color:Colors.blue, ), ), ], ), ), ), ), ); &#125;&#125; © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合译文https://ducafecat.tech/categories/%E8%AF%91%E6%96%87/ Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"flutter 交互式用户指导，以及如何在布局中创造一个洞","date":"2021-04-26T16:00:00.000Z","path":"2021/04/27/translation/flutter-interactive-user-guidanc-e-or-how-to-make-a-hole-in-layout/","text":"原文https://medium.com/litslink/flutter-interactive-user-guidanc-e-or-how-to-make-a-hole-in-layout-d72bf6eb27f9 代码https://github.com/alex-melnyk/flutter_user_guidance 正文 大家好！我想给你看一个有趣的 Flutter 特征。我们可以建立交互式的用户指导使用 blending 混合颜色。 这个简单的技巧可以让你在应用程序中建立有趣的用户指南，而不仅仅是一张图片。它可以真正与动画等互动。 布局首先，要构建覆盖，您需要将目标页面的 Scaffold 小部件包装到 Stack 小部件中，并将 Scaffold 小部件作为第一个项目保留。 12345678910111213141516171819202122232425262728293031323334353637383940@overrideWidget build(BuildContext context) &#123; final theme = Theme.of(context); return Stack( children: [ Scaffold( appBar: AppBar( title: Text('Flutter User Guidance Example'), centerTitle: false, actions: [ IconButton( icon: Icon(Icons.slideshow), onPressed: () =&gt; _userGuidanceController.show(), ), ], ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: theme.textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _handleFABPressed, tooltip: 'Increment', child: Icon(Icons.add), ), ), ], );&#125; 对于第二个地方，创建一个覆盖整个脚手架的覆盖图，使用一点透明的深/浅背景。Root ColorFiltered 具有混合模式“ source out”，内部 Container 在后台具有“ destination out”，这允许我们剪切小部件以在 root ColorFiltered 小部件中剪切它们。 123456789101112131415161718192021222324252627Positioned.fill( child: ColorFiltered( colorFilter: ColorFilter.mode( Colors.black87, BlendMode.srcOut, ), child: Stack( children: [ Positioned.fill( child: Container( decoration: BoxDecoration( color: Colors.black, backgroundBlendMode: BlendMode.dstOut, ), ), ), Center( child: Container( width: 150, height: 150, color: Colors.white, ), ), ], ), ),), 例如，在这个例子中，我们有一个容器，大小为 150x150，颜色为白色，需要混合的颜色，不应该是完全透明的，否则你不会看到它。因此，颜色是需要混合，以了解什么地区剪出来。 使用者指引当然，您需要添加一些单词或元素来引导用户浏览指南。在这种情况下，您可以将小部件放在同一个 Stack 中经过过滤的 root ColorFiltered 上。 123456789101112131415161718192021222324Align( alignment: Alignment.bottomLeft, child: Material( color: Colors.transparent, child: Container( margin: EdgeInsets.only( left: 16, bottom: 38, ), padding: EdgeInsets.symmetric( horizontal: 16, vertical: 8, ), decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(5), ), child: Text( 'Hello Interactive User Guidance!\\n' 'Tap on + button to increase the number...' ), ), ),), 请记住，Stack 小部件来自 Scaffold 并且没有任何 Material 支持，所以用一个 Material 小部件包装它就足够了。 这里有一个完整的例子，如果你把所有这些步骤都做对了，你会看到同样的图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@overrideWidget build(BuildContext context) &#123; final theme = Theme.of(context); return Stack( children: [ Scaffold( appBar: AppBar( title: Text('Flutter User Guidance Example'), centerTitle: false, actions: [ IconButton( icon: Icon(Icons.slideshow), onPressed: () =&gt; _userGuidanceController.show(), ), ], ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: theme.textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _handleFABPressed, tooltip: 'Increment', child: Icon(Icons.add), ), ), Positioned.fill( child: ColorFiltered( colorFilter: ColorFilter.mode( Colors.black87, BlendMode.srcOut, ), child: Stack( children: [ Positioned.fill( child: Container( decoration: BoxDecoration( color: Colors.black, backgroundBlendMode: BlendMode.dstOut, ), ), ), Align( alignment: Alignment.bottomRight, child: Container( margin: EdgeInsets.only( right: 9, bottom: 27, ), width: 70, height: 70, decoration: BoxDecoration( color: Colors.white, shape: BoxShape.circle, ), ), ), ], ), ), ), Align( alignment: Alignment.bottomLeft, child: Material( color: Colors.transparent, child: Container( margin: EdgeInsets.only( left: 16, bottom: 38, ), padding: EdgeInsets.symmetric( horizontal: 16, vertical: 8, ), decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(5), ), child: Text( 'Hello Interactive User Guidance!\\n' 'Tap on + button to increase the number...' ), ), ), ), ], );&#125; 动画和步骤我准备了一个简单的例子，通过动画剪辑区域从矩形切换到圆形并移动，从一个指导切换到另一个。只要查看我的仓库，就能获得这种体验。 完整的项目源代码可以在 GitHub 上找到。 https://github.com/alex-melnyk/flutter_user_guidance © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter Getx 04 - GetConnect、StateMixin、SuperController、GetController + Dio","date":"2021-04-22T16:00:00.000Z","path":"2021/04/23/flutter-getx/flutter-getx-04-getconnect-statemixin-dio/","text":"本节目标 GetConnect StateMixin GetController + Dio SuperController 视频https://www.bilibili.com/video/BV17B4y1c7eF 代码https://github.com/ducafecat/getx_quick_start 参考 https://pub.flutter-io.cn/packages/get#getconnect 正文GetConnect 瞎聊设计模式 Provider 提供者模式 位于高层 由他来决定从哪里、提供什么 相对应的有 Consumer 消费者模式 Repository 模式，这层有 OO 面向对象的意思，用来处理拉取数据细节，这样到 Controller 控制器 这一层只要处理业务就行，可方便测试 DAO 就是纯粹的数据访问层，没有 00 的概念 Service Model Entity … 前端其实对数据加工、面向服务、领域模型偏弱，更多的是组件拆分、样式、布局，这才是要关系的，就算是测试也是 E2E 侧重不同。 E2E（End To End）即端对端测试，属于黑盒测试，通过编写测试用例，自动化模拟用户操作，确保组件间通信正常，程序流数据传递如预期。 封装 GetConnect lib/common/utils/base_provider.dart 1234567891011121314151617class BaseProvider extends GetConnect &#123; @override void onInit() &#123; httpClient.baseUrl = SERVER_API_URL; // 请求拦截 httpClient.addRequestModifier&lt;void&gt;((request) &#123; request.headers['Authorization'] = '12345678'; return request; &#125;); // 响应拦截 httpClient.addResponseModifier((request, response) &#123; return response; &#125;); &#125;&#125; Provider lib/pages/getConnect/provider.dart 12345678910111213141516171819abstract class INewsProvider &#123; Future&lt;Response&lt;NewsPageListResponseEntity&gt;&gt; getNews();&#125;class NewsProvider extends BaseProvider implements INewsProvider &#123; // 新闻分页 // @override // Future&lt;Response&lt;NewsPageListResponseEntity&gt;&gt; getNews() =&gt; get(\"/news\"); @override Future&lt;Response&lt;NewsPageListResponseEntity&gt;&gt; getNews() async &#123; var response = await get(\"/news\"); var data = NewsPageListResponseEntity.fromJson(response.body); return Response( statusCode: response.statusCode, statusText: response.statusText, body: data, ); &#125;&#125; Repository lib/pages/getConnect/repository.dart 123456789101112131415161718abstract class INewsRepository &#123; Future&lt;NewsPageListResponseEntity&gt; getNews();&#125;class NewsRepository implements INewsRepository &#123; NewsRepository(&#123;required this.provider&#125;); final INewsProvider provider; @override Future&lt;NewsPageListResponseEntity&gt; getNews() async &#123; final response = await provider.getNews(); if (response.status.hasError) &#123; return Future.error(response.statusText!); &#125; else &#123; return response.body!; &#125; &#125;&#125; Controller lib/pages/getConnect/controller.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class NewsController extends SuperController&lt;NewsPageListResponseEntity&gt; &#123; NewsController(&#123;required this.repository&#125;); final INewsRepository repository; @override void onInit() &#123; super.onInit(); //Loading, Success, Error handle with 1 line of code // append(() =&gt; repository.getNews); &#125; // 拉取新闻列表 Future&lt;void&gt; getNewsPageList() async &#123; append(() =&gt; repository.getNews); &#125; @override void onReady() &#123; print('The build method is done. ' 'Your controller is ready to call dialogs and snackbars'); super.onReady(); &#125; @override void onClose() &#123; print('onClose called'); super.onClose(); &#125; @override void didChangeMetrics() &#123; print('the window size did change'); super.didChangeMetrics(); &#125; @override void didChangePlatformBrightness() &#123; print('platform change ThemeMode'); super.didChangePlatformBrightness(); &#125; @override Future&lt;bool&gt; didPushRoute(String route) &#123; print('the route $route will be open'); return super.didPushRoute(route); &#125; @override Future&lt;bool&gt; didPopRoute() &#123; print('the current route will be closed'); return super.didPopRoute(); &#125; @override void onDetached() &#123; print('onDetached called'); &#125; @override void onInactive() &#123; print('onInative called'); &#125; @override void onPaused() &#123; print('onPaused called'); &#125; @override void onResumed() &#123; print('onResumed called'); &#125;&#125; GetView lib/pages/getConnect/view.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class NewsView extends GetView&lt;NewsController&gt; &#123; NewsView(&#123;Key? key&#125;) : super(key: key); _buildListView(NewsPageListResponseEntity? state) &#123; return ListView.separated( itemCount: state != null ? state.items!.length : 0, itemBuilder: (context, index) &#123; final NewsItem item = state!.items![index]; return ListTile( onTap: () =&gt; null, title: Text(item.title), trailing: Text(\"分类 $&#123;item.category&#125;\"), ); &#125;, separatorBuilder: (BuildContext context, int index) &#123; return Divider(); &#125;, ); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"GetConnect Page\"), ), body: controller.obx( (state) =&gt; _buildListView(state), onEmpty: Text(\"onEmpty\"), onLoading: Center( child: Column( children: [ Text(\"没有数据\"), ElevatedButton( onPressed: () &#123; controller.getNewsPageList(); &#125;, child: Text('拉取数据'), ), ], ), ), onError: (err) =&gt; Text(\"onEmpty\" + err.toString()), ), ); &#125;&#125; Bindings lib/pages/getConnect/bindings.dart 12345678class NewsBinding implements Bindings &#123; @override void dependencies() &#123; Get.lazyPut&lt;INewsProvider&gt;(() =&gt; NewsProvider()); Get.lazyPut&lt;INewsRepository&gt;(() =&gt; NewsRepository(provider: Get.find())); Get.lazyPut(() =&gt; NewsController(repository: Get.find())); &#125;&#125; 路由 lib/common/routes/app_pages.dart 12345GetPage( name: AppRoutes.GetConnect, binding: NewsBinding(), page: () =&gt; NewsView(),), StateMixin 雷同代码不再重复 控制器 Mixin 如下 lib/pages/getConnect_stateMixin/controller.dart 123456789101112131415161718192021class NewsStateMixinController extends GetxController with StateMixin&lt;NewsPageListResponseEntity&gt; &#123; final NewsStateMixinProvider provider; NewsStateMixinController(&#123;required this.provider&#125;); // 拉取新闻列表 Future&lt;void&gt; getNewsPageList() async &#123; // 获取数据 final Response response = await provider.getNews(); // 判断，如果有错误 if (response.hasError) &#123; // 改变数据，传入错误状态，在ui中会处理这些错误 change(null, status: RxStatus.error(response.statusText)); &#125; else &#123; // 否则，存储数据，改变状态为成功 var data = NewsPageListResponseEntity.fromJson(response.body); change(data, status: RxStatus.success()); &#125; &#125;&#125; 这种方式确实简化了很多代码 GetController + Dio这种方式就是之前 Flutter 新闻客户端 的写法，能复用原来的 dio 代码。 dio 基础类 lib/common/utils/http.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * http 操作类 * * 手册 * https://github.com/flutterchina/dio/blob/master/README-ZH.md * * 从 3 升级到 4 * https://github.com/flutterchina/dio/blob/master/migration_to_4.x.md*/class HttpUtil &#123; static HttpUtil _instance = HttpUtil._internal(); factory HttpUtil() =&gt; _instance; late Dio dio; HttpUtil._internal() &#123; // BaseOptions、Options、RequestOptions 都可以配置参数，优先级别依次递增，且可以根据优先级别覆盖参数 BaseOptions options = new BaseOptions( // 请求基地址,可以包含子路径 baseUrl: SERVER_API_URL, // baseUrl: storage.read(key: STORAGE_KEY_APIURL) ?? SERVICE_API_BASEURL, //连接服务器超时时间，单位是毫秒. connectTimeout: 10000, // 响应流上前后两次接受到数据的间隔，单位为毫秒。 receiveTimeout: 5000, // Http请求头. headers: &#123;&#125;, /// 请求的Content-Type，默认值是\"application/json; charset=utf-8\". /// 如果您想以\"application/x-www-form-urlencoded\"格式编码请求数据, /// 可以设置此选项为 `Headers.formUrlEncodedContentType`, 这样[Dio] /// 就会自动编码请求体. contentType: 'application/json; charset=utf-8', /// [responseType] 表示期望以那种格式(方式)接受响应数据。 /// 目前 [ResponseType] 接受三种类型 `JSON`, `STREAM`, `PLAIN`. /// /// 默认值是 `JSON`, 当响应头中content-type为\"application/json\"时，dio 会自动将响应内容转化为json对象。 /// 如果想以二进制方式接受响应数据，如下载一个二进制文件，那么可以使用 `STREAM`. /// /// 如果想以文本(字符串)格式接收响应数据，请使用 `PLAIN`. responseType: ResponseType.json, ); dio = new Dio(options); // Cookie管理 CookieJar cookieJar = CookieJar(); dio.interceptors.add(CookieManager(cookieJar)); &#125; /// restful get 操作 Future get( String path, &#123; dynamic? queryParameters, Options? options, &#125;) async &#123; var response = await dio.get( path, queryParameters: queryParameters, options: options, ); return response.data; &#125;&#125; api 定义 lib/common/apis/news.dart 123456789101112/// 新闻class NewsAPI &#123; /// 翻页 static Future&lt;NewsPageListResponseEntity&gt; newsPageList( &#123;NewsRecommendRequestEntity? param&#125;) async &#123; var response = await HttpUtil().get( '/news', queryParameters: param?.toJson(), ); return NewsPageListResponseEntity.fromJson(response); &#125;&#125; 控制器 lib/pages/getController_dio/controller.dart 1234567891011121314151617181920class NewsDioController extends GetxController &#123; var newsPageList = Rx&lt;NewsPageListResponseEntity&gt;(NewsPageListResponseEntity()); @override void onInit() &#123; super.onInit(); print(\"onInit\"); &#125; @override void onClose() &#123; super.onClose(); print(\"onClose\"); &#125; getPageList() async &#123; newsPageList.value = await NewsAPI.newsPageList(); &#125;&#125; © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter getx","slug":"flutter-getx","permalink":"https://blog.ducafecat.tech/tags/flutter-getx/"}]},{"title":"Flutter Getx 03 - 状态管理、依赖加载","date":"2021-04-15T16:00:00.000Z","path":"2021/04/16/flutter-getx/flutter-getx-03-state-dependency/","text":"本节目标 4 种状态管理 Obx GetX GetBuilder ValueBuilder 防抖、限流 函数 ever once debounce interval 依赖注入 Get.put Get.lazyPut 视图组件 GetView 视频https://www.bilibili.com/video/BV1PA411V7qc/ 代码https://github.com/ducafecat/getx_quick_start 参考 https://pub.flutter-io.cn/packages/get#reactive-state-manager https://dart.dev/guides/language/extension-methods 正文状态管理Obx lib/pages/state_obx/index.dart 12345678910111213141516171819202122232425262728293031class StateObxView extends StatelessWidget &#123; StateObxView(&#123;Key? key&#125;) : super(key: key); final count = 0.obs; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"Obx(...)\"), ), body: Center( child: Column( children: [ Obx(() =&gt; Text(\"count1 -&gt; \" + count.toString())), Obx(() =&gt; Text(\"count2 -&gt; \" + count.toString())), // Divider(), ElevatedButton( onPressed: () &#123; count.value++; &#125;, child: Text('add'), ), ], ), ), ); &#125;&#125; obs、extension、RxInt、Rx 1234567891011121314151617181920212223242526...extension StringExtension on String &#123; /// Returns a `RxString` with [this] `String` as initial value. RxString get obs =&gt; RxString(this);&#125;extension IntExtension on int &#123; /// Returns a `RxInt` with [this] `int` as initial value. RxInt get obs =&gt; RxInt(this);&#125;extension DoubleExtension on double &#123; /// Returns a `RxDouble` with [this] `double` as initial value. RxDouble get obs =&gt; RxDouble(this);&#125;extension BoolExtension on bool &#123; /// Returns a `RxBool` with [this] `bool` as initial value. RxBool get obs =&gt; RxBool(this);&#125;extension RxT&lt;T&gt; on T &#123; /// Returns a `Rx` instace with [this] `T` as initial value. Rx&lt;T&gt; get obs =&gt; Rx&lt;T&gt;(this);&#125; 小结 适合界面上 简单状态管理，写起来很快。 GetX 编写控制器 lib/pages/state_getx/controller.dart 123456789101112class CountController extends GetxController &#123; final _count = 0.obs; set count(value) =&gt; this._count.value = value; get count =&gt; this._count.value; final _count2 = 0.obs; set count2(value) =&gt; this._count2.value = value; get count2 =&gt; this._count2.value; add() =&gt; _count.value++; add2() =&gt; _count2.value++;&#125; 编写视图 lib/pages/state_getx/index.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class StateGetxView extends StatelessWidget &#123; StateGetxView(&#123;Key? key&#125;) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"Getx\"), ), body: Center( child: Column( children: [ GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetX - 1\"); return Text('value 1 -&gt; $&#123;_.count&#125;'); &#125;, ), GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetX - 2\"); return Text('value 2 -&gt; $&#123;_.count&#125;'); &#125;, ), Divider(), // GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetX - 3\"); return Column( children: [ Text('value 3 -&gt; $&#123;_.count&#125;'), ElevatedButton( onPressed: () &#123; _.add(); &#125;, child: Text('count1'), ) ], ); &#125;, ), Divider(), // count2 GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetX - 4\"); return Text('value 4 -&gt; $&#123;_.count2&#125;'); &#125;, ), Divider(), // 按钮 ElevatedButton( onPressed: () &#123; controller.add(); &#125;, child: Text('count1'), ), ElevatedButton( onPressed: () &#123; controller.add2(); &#125;, child: Text('count2'), ), ], ), ), ); &#125;&#125; 小结 适合控制多控制器、多状态更新，可精细控制初始、局部渲染。 GetBuilder 控制器 lib/pages/state_getBuilder/controller.dart 同上，不再重复 视图 lib/pages/state_getBuilder/index.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class StateGetBuilderView extends StatelessWidget &#123; StateGetBuilderView(&#123;Key? key&#125;) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"GetBuilder\"), ), body: Center( child: Column( children: [ GetBuilder&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetBuilder - 1\"); return Text('value -&gt; $&#123;_.count&#125;'); &#125;, ), GetBuilder&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetBuilder - 2\"); return Text('value -&gt; $&#123;_.count&#125;'); &#125;, ), Divider(), // GetBuilder&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetBuilder - 3\"); return Column( children: [ Text('value -&gt; $&#123;_.count&#125;'), ElevatedButton( onPressed: () &#123; _.add(); &#125;, child: Text('GetBuilder -&gt; add'), ) ], ); &#125;, ), Divider(), // count2 GetBuilder&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetBuilder - 4\"); return Text('value count2 -&gt; $&#123;_.count2&#125;'); &#125;, ), Divider(), // id2 GetBuilder&lt;CountController&gt;( id: \"id2\", init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; print(\"GetBuilder - 4\"); return Text('id2 -&gt; value count2 -&gt; $&#123;_.count2&#125;'); &#125;, ), Divider(), // 按钮 ElevatedButton( onPressed: () &#123; controller.add(); &#125;, child: Text('add'), ), ElevatedButton( onPressed: () &#123; controller.add2(); &#125;, child: Text('add2'), ), ElevatedButton( onPressed: () &#123; controller.update(); &#125;, child: Text('controller.update()'), ), ElevatedButton( onPressed: () &#123; controller.update([\"id2\"]); &#125;, child: Text('controller.update(id2)'), ), ], ), ), ); &#125;&#125; 小结 和 GetX 比起来，多了手动控制更新，有两点需要注意。 controller.update(); 触发更新 id: &quot;id2&quot;, 标记哪个 builder ，触发方式 controller.update([&quot;id2&quot;]); ，可传多个 Array 类型。 ValueBuilder lib/pages/state_valueBuilder/index.dart 123456789101112131415161718192021222324252627282930313233343536373839404142class StateValueBuilderView extends StatelessWidget &#123; StateValueBuilderView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"ValueBuilder\"), ), body: Column( children: [ Center( child: ValueBuilder&lt;int?&gt;( initialValue: 10, builder: (value, updateFn) &#123; return Column( children: [ Text(\"count -&gt; \" + value.toString()), ElevatedButton( onPressed: () &#123; updateFn(value! + 1); &#125;, child: Text('ValueBuilder -&gt; add'), ) ], ); &#125;, // builder: (value, updateFn) =&gt; Switch( // value: value, // onChanged: // updateFn, // same signature! you could use ( newValue ) =&gt; updateFn( newValue ) // ), // if you need to call something outside the builder method. onUpdate: (value) =&gt; print(\"Value updated: $value\"), onDispose: () =&gt; print(\"Widget unmounted\"), ), ), ], ), ); &#125;&#125; 小结 适合局部的状态管理，很灵活。 防抖、限流 控制器 lib/pages/state_workers/controller.dart 12345678910111213141516171819202122232425262728293031323334353637383940class CountController extends GetxController &#123; final _count = 0.obs; set count(value) =&gt; this._count.value = value; get count =&gt; this._count.value; add() =&gt; _count.value++; @override void onInit() &#123; super.onInit(); // 每次 ever(_count, (value) &#123; print(\"ever -&gt; \" + value.toString()); &#125;); // 第一次 once(_count, (value) &#123; print(\"once -&gt; \" + value.toString()); &#125;); // 防抖 2 秒内 debounce( _count, (value) &#123; print(\"debounce -&gt; \" + value.toString()); &#125;, time: Duration(seconds: 2), ); // 定时器 1 秒 interval( _count, (value) &#123; print(\"interval -&gt; \" + value.toString()); &#125;, time: Duration(seconds: 1), ); &#125;&#125; 视图 lib/pages/state_workers/index.dart 123456789101112131415161718192021222324252627282930313233343536class StateWorkersView extends StatelessWidget &#123; StateWorkersView(&#123;Key? key&#125;) : super(key: key); final controller = CountController(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"GetBuilder\"), ), body: Center( child: Column( children: [ // 显示 GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; return Text('value -&gt; $&#123;_.count&#125;'); &#125;, ), // 按钮 ElevatedButton( onPressed: () &#123; controller.add(); &#125;, child: Text('add'), ), ], ), ), ); &#125;&#125; 小结 ever 适合做监听、日志收集 debounce 适合做搜索输入框 依赖注入Get.put 控制器 lib/pages/dependency_put_find/controller.dart 12345678910111213141516171819class CountController extends GetxController &#123; final _count = 0.obs; set count(value) =&gt; this._count.value = value; get count =&gt; this._count.value; add() =&gt; _count.value++; @override void onInit() &#123; super.onInit(); print(\"onInit\"); &#125; @override void onClose() &#123; super.onClose(); print(\"onClose\"); &#125;&#125; 第一个视图 lib/pages/dependency_put_find/index.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344class StateDependencyPutFindView extends StatelessWidget &#123; StateDependencyPutFindView(&#123;Key? key&#125;) : super(key: key); final controller = Get.put&lt;CountController&gt;(CountController()); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"Dependency\"), ), body: Center( child: Column( children: [ GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; return Text('value -&gt; $&#123;_.count&#125;'); &#125;, ), Divider(), // 按钮 ElevatedButton( onPressed: () &#123; controller.add(); &#125;, child: Text('add'), ), // 跳转 ElevatedButton( onPressed: () &#123; Get.to(NextPageView()); &#125;, child: Text('next page'), ), ], ), ), ); &#125;&#125; 第二个视图 lib/pages/dependency_put_find/next_page.dart 12345678910111213141516171819202122232425262728class NextPageView extends StatelessWidget &#123; NextPageView(&#123;Key? key&#125;) : super(key: key); final controller = Get.find&lt;CountController&gt;(); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"NextPage\"), ), body: Center( child: Column( children: [ GetX&lt;CountController&gt;( init: controller, initState: (_) &#123;&#125;, builder: (_) &#123; return Text('value -&gt; $&#123;_.count&#125;'); &#125;, ), Divider(), ], ), ), ); &#125;&#125; Get.lazyPut + GetView 懒加载 控制器 lib/pages/dependency_lazyPut/controller.dart 12345678910111213141516171819class CountController extends GetxController &#123; final _count = 0.obs; set count(value) =&gt; this._count.value = value; get count =&gt; this._count.value; add() =&gt; _count.value++; @override void onInit() &#123; super.onInit(); print(\"onInit\"); &#125; @override void onClose() &#123; super.onClose(); print(\"onClose\"); &#125;&#125; 第一个视图 lib/pages/dependency_lazyPut/index.dart 123456789101112131415161718192021222324252627282930313233343536373839404142class StateDependencyLazyPutView extends StatelessWidget &#123; StateDependencyLazyPutView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"Dependency - LazyPut\"), ), body: Center( child: Column( children: [ GetX&lt;CountController&gt;( init: Get.find&lt;CountController&gt;(), initState: (_) &#123;&#125;, builder: (_) &#123; return Text('value -&gt; $&#123;_.count&#125;'); &#125;, ), Divider(), // 按钮 ElevatedButton( onPressed: () &#123; Get.find&lt;CountController&gt;().add(); &#125;, child: Text('add'), ), // 跳转 ElevatedButton( onPressed: () &#123; Get.to(NextPageView()); &#125;, child: Text('Next GetView Page'), ), ], ), ), ); &#125;&#125; 第二个视图 lib/pages/dependency_lazyPut/next_getview_page.dart 12345678910111213141516171819202122232425262728class NextPageView extends GetView&lt;CountController&gt; &#123; NextPageView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"GetView Page\"), ), body: Center( child: Column( children: [ Obx(() =&gt; Text('value -&gt; $&#123;controller.count&#125;')), Divider(), // 按钮 ElevatedButton( onPressed: () &#123; controller.add(); &#125;, child: Text('add'), ), ], ), ), ); &#125;&#125; 绑定 lib/pages/dependency_lazyPut/bindings.dart 123456class DependencyLazyPutBinding implements Bindings &#123; @override void dependencies() &#123; Get.lazyPut&lt;CountController&gt;(() =&gt; CountController()); &#125;&#125; 路由 lib/common/routes/app_pages.dart 1234GetPage( name: AppRoutes.DependencyLazyPut, binding: DependencyLazyPutBinding(), page: () =&gt; StateDependencyLazyPutView()), © 猫哥 https://ducafecat.tech/ https://github.com/ducafecat 往期开源GetX Quick Starthttps://github.com/ducafecat/getx_quick_start 新闻客户端https://github.com/ducafecat/flutter_learn_news strapi 手册译文https://getstrapi.cn 微信讨论群 ducafecat系列集合Dart 编程语言基础https://space.bilibili.com/404904528/channel/detail?cid=111585 Flutter 零基础入门https://space.bilibili.com/404904528/channel/detail?cid=123470 Flutter 实战从零开始 新闻客户端https://space.bilibili.com/404904528/channel/detail?cid=106755 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter 组件开发https://space.bilibili.com/404904528/channel/detail?cid=144262 Flutter Blochttps://space.bilibili.com/404904528/channel/detail?cid=177519 Flutter Getx4https://space.bilibili.com/404904528/channel/detail?cid=177514 Docker Yapihttps://space.bilibili.com/404904528/channel/detail?cid=130578","tags":[{"name":"flutter getx","slug":"flutter-getx","permalink":"https://blog.ducafecat.tech/tags/flutter-getx/"}]},{"title":"Flutter Getx 02 - 空安全、更健全的代码","date":"2021-04-08T16:00:00.000Z","path":"2021/04/09/flutter-getx/flutter-getx-02-null-safety/","text":"本节目标 空安全意味着什么 如何迁移代码 如何禁用空安全 代码规范示例 视频https://www.bilibili.com/video/bv1g5411c7hF 代码https://github.com/ducafecat/getx_quick_start 参考 https://dart.cn/null-safety https://dart.cn/null-safety/migration-guide https://dart.cn/null-safety/understanding-null-safety https://dart.cn/null-safety/unsound-null-safety https://dart.cn/null-safety/faq 正文空安全意味着什么 默认不可空 1String title = 'ducafecat'; type? 操作符 1String? title = null; value! 操作符 12String? title = 'ducafecat';String newTitle = title!; value? 操作符 12String? title = 'ducafecat';bool isEmpty = title?.isEmpty(); value?? 操作符 12String? title = 'ducafecat';String newTitle = title ?? 'cat'; late 会在运行时检查。所以请您仅在确定它被使用前一定会被初始化的情况下使用 12late String? title;title = 'ducafecat'; List、泛型 类型 集合是否可空 数据项是否可空 List no no List? yes no List&lt;String?&gt; no yes List&lt;String?&gt;? yes yes Map 类型 集合是否可空 数据项是否可空 Map&lt;String, int&gt; no no* Map&lt;String, int&gt;? yes no* Map&lt;String, int?&gt; no yes Map&lt;String, int?&gt;? yes yes * 可能返回空 12345678// 有可能返回 nullint value = &lt;String, int&gt;&#123;'one': 1&#125;['one']; // ERROR// 需要加上 type?int? value = &lt;String, int&gt;&#123;'one': 1&#125;['one']; // OK// 或者 value!int value = &lt;String, int&gt;&#123;'one': 1&#125;['one']!; // OK 带来的好处 代码更健康 用户体验好 运行更快 编译文件更小 开启和迁移 pubspec.yaml 12environment: sdk: &quot;&gt;=2.12.0 &lt;3.0.0&quot; 迁移顺序 我们强烈建议您按顺序迁移代码，先迁移依赖关系中的处于最末端的依赖。例如，如果 C 依赖了 B，B 依赖了 A，那么应该按照 A -&gt; B -&gt; C 的顺序进行迁移。 检查依赖项目 12345# Dart 版本是否为 2.12 或更高&gt; dart --version# 依赖包的迁移状态&gt; dart pub outdated --mode=null-safety 升级依赖 12345# 该命令会更改您的 pubspec.yaml 文件&gt; dart pub upgrade --null-safety# 升级包&gt; dart pub upgrade 迁移工具 1&gt; dart migrate 分析 1&gt; dart analyze 禁用空安全 cli 命令 12&gt; dart --no-sound-null-safety run&gt; flutter run --no-sound-null-safety .vscode/launch.json 123456789101112131415&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"getx_quick_start\", \"request\": \"launch\", \"type\": \"dart\", \"program\": \"lib/main.dart\", \"args\": [\"--no-sound-null-safety\"] &#125; ]&#125; 范例、规范https://dart.cn/null-safety/understanding-null-safety 明确处理空状态 1234567makeCoffee(String coffee, [String? dairy]) &#123; if (dairy != null) &#123; print('$coffee with $dairy'); &#125; else &#123; print('Black $coffee'); &#125;&#125; 顶层变量和静态字段必须包含一个初始化方法。由于它们能在程序里的任何位置被访问到，编译器无法保证它们在被使用前已被赋值。唯一保险的选项是要求其本身包含初始化表达式，以确保产生匹配的类型的值。 12345int topLevel = 0;class SomeClass &#123; static int staticField = 0;&#125; 实例的字段也必须在声明时包含初始化方法，可以为常见初始化形式，也可以在实例的构造方法中进行初始化。 12345678class SomeClass &#123; int atDeclaration = 0; int initializingFormal; int initializationList; SomeClass(this.initializingFormal) : initializationList = 0;&#125; 局部变量的灵活度最高。一个非空的变量 不一定需要 一个初始化方法。 1234567891011int tracingFibonacci(int n) &#123; int result; if (n &lt; 2) &#123; result = n; &#125; else &#123; result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1); &#125; print(result); return result;&#125; 流程分析，在这里 Dart 将 object 的类型从它声明的 Object 提升到了 List。在空安全引入以前，下面的程序无法运行。 12345678910111213141516// With (or without) null safety:bool isEmptyList(Object object) &#123; if (object is List) &#123; return object.isEmpty; // &lt;-- OK! &#125; else &#123; return false; &#125;&#125;-&gt;// Without null safety:bool isEmptyList(Object object) &#123; if (object is! List) return false; return object.isEmpty;&#125; 绝对的赋值分析 1234567891011int tracingFibonacci(int n) &#123; final int result; if (n &lt; 2) &#123; result = n; &#125; else &#123; result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1); &#125; print(result); return result;&#125; 无用代码的警告 123456String checkList(List list) &#123; if (list?.isEmpty) &#123; return 'Got nothing'; &#125; return 'Got something';&#125; 懒加载的变量， late 修饰符是“在运行时而非编译时对变量进行约束”。这就让 late 这个词语约等于 何时 执行对变量的强制约束。 123456789101112131415161718192021// Using null safety:class Coffee &#123; String? _temperature; void heat() &#123; _temperature = 'hot'; &#125; void chill() &#123; _temperature = 'iced'; &#125; String serve() =&gt; _temperature! + ' coffee';&#125;-&gt;// Using null safety:class Coffee &#123; late String _temperature; void heat() &#123; _temperature = 'hot'; &#125; void chill() &#123; _temperature = 'iced'; &#125; String serve() =&gt; _temperature + ' coffee';&#125; late 与 final 结合使用，与普通的 final 字段不同，您不需要在声明或构造时就将其初始化。您可以稍后在运行中的某个地方加载它。但是您只能对其进行 一次 赋值，并且它在运行时会进行校验。 123456789// Using null safety:class Coffee &#123; late final String _temperature; void heat() &#123; _temperature = 'hot'; &#125; void chill() &#123; _temperature = 'iced'; &#125; String serve() =&gt; _temperature + ' coffee';&#125; 毕传参数，这里的所有参数都必须通过命名来传递。参数 a 和 c 是可选的，可以省略。参数 b 和 d 是必需的，调用时必须传递。在这里请注意，是否必需和是否可空无关。 12// Using null safety:function(&#123;int? a, required int? b, int? c, required int? d&#125;) &#123;&#125; 抽象字段 12345678910abstract class Cup &#123; Beverage get contents; set contents(Beverage);&#125;-&gt;abstract class Cup &#123; abstract Beverage contents;&#125; 一些赋值计算可以移动到静态的初始化中。 12345678910111213141516171819// Initalized without valuesListQueue _context;Float32List _buffer;dynamic _readObject;Vec2D(Map&lt;String, dynamic&gt; object) &#123; _buffer = Float32List.fromList([0.0, 0.0]); _readObject = object['container']; _context = ListQueue&lt;dynamic&gt;();&#125;-&gt;// Initalized with valuesfinal ListQueue _context = ListQueue&lt;dynamic&gt;();final Float32List _buffer = Float32List.fromList([0.0, 0.0]);final dynamic _readObject;Vec2D(Map&lt;String, dynamic&gt; object) : _readObject = object['container']; 可能返回 null 的工厂方法 12345678910111213141516171819202122factory StreamReader(dynamic data) &#123; StreamReader reader; if (data is ByteData) &#123; reader = BlockReader(data); &#125; else if (data is Map) &#123; reader = JSONBlockReader(data); &#125; return reader;&#125;-&gt;factory StreamReader(dynamic data) &#123; if (data is ByteData) &#123; // Move the readIndex forward for the binary reader. return BlockReader(data); &#125; else if (data is Map) &#123; return JSONBlockReader(data); &#125; else &#123; throw ArgumentError('Unexpected type for data'); &#125;&#125; © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter getx","slug":"flutter-getx","permalink":"https://blog.ducafecat.tech/tags/flutter-getx/"}]},{"title":"Flutter Getx 01 - 路由、中间件、鉴权、传值、跳转","date":"2021-04-04T16:00:00.000Z","path":"2021/04/05/flutter-getx/flutter-getx-01-router-middleware/","text":"Getx https://pub.flutter-io.cn/packages/get vscode 插件 Android Studio/Intellij 插件 本节目标 GetPage 对象 路由层级控制 路由中间件、鉴权 404 处理 路由跳转、替换、清除 路由传值、返回值 路由转场动画 开发环境 Flutter 2.1.0-12.1.pre Dart 2.13.0 get: ^3.26.0 参考 getx example getx_pattern GetX Snippets 视频https://www.bilibili.com/video/BV1yU4y1876r/ 代码https://github.com/ducafecat/getx_quick_start 正文初始 getx 项目 pubspec.yaml 123dependencies: ... get: ^3.26.0 lib/pages/home/index.dart 12345678910111213141516171819202122import 'package:flutter/material.dart';import 'package:get/get.dart';class HomeView extends StatelessWidget &#123; const HomeView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"首页\"), ), body: ListView( children: [ // 路由&amp;导航 Divider(), ], ), ); &#125;&#125; lib/common/routes/app_routes.dart 12345part of 'app_pages.dart';abstract class AppRoutes &#123; static const Home = '/home';&#125; lib/common/routes/app_pages.dart 1234567891011121314import 'package:get/get.dart';part 'app_routes.dart';class AppPages &#123; static const INITIAL = AppRoutes.Home; static final routes = [ GetPage( name: AppRoutes.Home, page: () =&gt; HomeView(), ), ];&#125; lib/main.dart 12345678910111213141516Future&lt;void&gt; main() async &#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return GetMaterialApp( debugShowCheckedModeBanner: false, initialRoute: AppPages.INITIAL, getPages: AppPages.routes, ); &#125;&#125; 编写 GetPage 定义 lib/pages/list/index.dart 123456789101112class ListView extends StatelessWidget &#123; const ListView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"列表页\"), ), ); &#125;&#125; lib/pages/list_detail/index.dart 123456789101112131415161718192021class DetailView extends StatelessWidget &#123; const DetailView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"详情页\"), ), body: ListView( children: [ ListTile( title: Text(\"导航-返回\"), subtitle: Text('Get.back()'), onTap: () =&gt; Get.back(), ), ], ), ); &#125;&#125; lib/common/routes/app_routes.dart 1234abstract class AppRoutes &#123; static const Home = '/home'; static const List = '/list'; static const Detail = '/detail'; lib/common/routes/app_pages.dart 12345678910111213141516GetPage( name: AppRoutes.Home, page: () =&gt; HomeView(), children: [ GetPage( name: AppRoutes.List, page: () =&gt; ListView(), children: [ GetPage( name: AppRoutes.Detail, page: () =&gt; DetailView(), ), ], ), ],), 导航操作 命名、视图对象 lib/pages/home/index.dart 123456789101112131415ListTile( title: Text(\"导航-命名路由 home &gt; list\"), subtitle: Text('Get.toNamed(\"/home/list\")'), onTap: () =&gt; Get.toNamed(\"/home/list\"),),ListTile( title: Text(\"导航-命名路由 home &gt; list &gt; detail\"), subtitle: Text('Get.toNamed(\"/home/list/detail\")'), onTap: () =&gt; Get.toNamed(\"/home/list/detail\"),),ListTile( title: Text(\"导航-类对象\"), subtitle: Text(\"Get.to(DetailView())\"), onTap: () =&gt; Get.to(DetailView()),), 导航-清除上一个 lib/pages/home/index.dart 12345ListTile( title: Text(\"导航-清除上一个\"), subtitle: Text(\"Get.off(DetailView())\"), onTap: () =&gt; Get.off(DetailView()),), 导航-清除所有 lib/pages/home/index.dart 12345ListTile( title: Text(\"导航-清除所有\"), subtitle: Text(\"Get.offAll(DetailView())\"), onTap: () =&gt; Get.offAll(DetailView()),), 导航-arguments 传值+返回值 lib/pages/home/index.dart 12345678910ListTile( title: Text(\"导航-arguments传值+返回值\"), subtitle: Text( 'Get.toNamed(\"/home/list/detail\", arguments: &#123;\"id\": 999&#125;)'), onTap: () async &#123; var result = await Get.toNamed(\"/home/list/detail\", arguments: &#123;\"id\": 999&#125;); Get.snackbar(\"返回值\", \"success -&gt; \" + result[\"success\"].toString()); &#125;,), lib/pages/list_detail/index.dart 1234567891011121314151617181920212223242526272829303132_buildBackListTileRow(Map? val) &#123; return val == null ? Container() : ListTile( title: Text(\"传值 id = \" + val[\"id\"].toString()), subtitle: Text('Get.back(result: &#123;\"success\": true&#125;'), onTap: () =&gt; Get.back(result: &#123;\"success\": true&#125;), );&#125;@overrideWidget build(BuildContext context) &#123; final details = Get.arguments as Map; final parameters = Get.parameters; return Scaffold( appBar: AppBar( title: Text(\"详情页\"), ), body: ListView( children: [ ListTile( title: Text(\"导航-返回\"), subtitle: Text('Get.back()'), onTap: () =&gt; Get.back(), ), _buildBackListTileRow(details), _buildBackListTileRow(parameters), ], ), );&#125; 导航-parameters 传值+返回值 lib/pages/home/index.dart 12345678ListTile( title: Text(\"导航-parameters传值+返回值\"), subtitle: Text('Get.toNamed(\"/home/list/detail?id=666\")'), onTap: () async &#123; var result = await Get.toNamed(\"/home/list/detail?id=666\"); Get.snackbar(\"返回值\", \"success -&gt; \" + result[\"success\"].toString()); &#125;,), lib/pages/list_detail/index.dart 123@overrideWidget build(BuildContext context) &#123; final parameters = Get.parameters; 导航-参数传值+返回值 lib/common/routes/app_routes.dart 1static const Detail_ID = '/detail/:id'; lib/common/routes/app_pages.dart 12345...GetPage( name: AppRoutes.Detail_ID, page: () =&gt; DetailView(),), lib/pages/home/index.dart 12345678ListTile( title: Text(\"导航-参数传值+返回值\"), subtitle: Text('Get.toNamed(\"/home/list/detail/777\")'), onTap: () async &#123; var result = await Get.toNamed(\"/home/list/detail/777\"); Get.snackbar(\"返回值\", \"success -&gt; \" + result[\"success\"].toString()); &#125;,), 导航-not found lib/pages/notfound/index.dart 1234567891011121314151617class NotfoundView extends StatelessWidget &#123; const NotfoundView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"路由没有找到\"), ), body: ListTile( title: Text(\"返回首页\"), subtitle: Text('Get.offAllNamed(AppRoutes.Home)'), onTap: () =&gt; Get.offAllNamed(AppRoutes.Home), ), ); &#125;&#125; lib/common/routes/app_routes.dart 1static const NotFound = '/notfound'; lib/common/routes/app_pages.dart 1234static final unknownRoute = GetPage( name: AppRoutes.NotFound, page: () =&gt; NotfoundView(),); lib/main.dart 1234567@overrideWidget build(BuildContext context) &#123; return GetMaterialApp( ... unknownRoute: AppPages.unknownRoute, );&#125; 导航-中间件-认证 Auth lib/pages/login/index.dart 1234567891011121314151617class LoginView extends StatelessWidget &#123; const LoginView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"登录\"), ), body: ListTile( title: Text(\"返回首页\"), subtitle: Text('Get.offAllNamed(AppRoutes.Home)'), onTap: () =&gt; Get.offAllNamed(AppRoutes.Home), ), ); &#125;&#125; lib/pages/my/index.dart 1234567891011121314151617class MyView extends StatelessWidget &#123; const MyView(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"我的\"), ), body: ListTile( title: Text(\"返回首页\"), subtitle: Text('Get.offAllNamed(AppRoutes.Home)'), onTap: () =&gt; Get.offAllNamed(AppRoutes.Home), ), ); &#125;&#125; lib/common/routes/app_routes.dart 12static const Login = '/login';static const My = '/my'; lib/common/middleware/router_auth.dart 123456789101112class RouteAuthMiddleware extends GetMiddleware &#123; @override int priority = 0; RouteAuthMiddleware(&#123;required this.priority&#125;); @override RouteSettings? redirect(String route) &#123; Future.delayed(Duration(seconds: 1), () =&gt; Get.snackbar(\"提示\", \"请先登录APP\")); return RouteSettings(name: AppRoutes.Login); &#125;&#125; lib/common/routes/app_pages.dart 12345678910111213// 白名单GetPage( name: AppRoutes.Login, page: () =&gt; LoginView(),),GetPage( name: AppRoutes.My, page: () =&gt; MyView(), middlewares: [ RouteAuthMiddleware(priority: 1), ],), lib/pages/home/index.dart 12345ListTile( title: Text(\"导航-中间件-认证Auth\"), subtitle: Text('Get.toNamed(AppRoutes.My)'), onTap: () =&gt; Get.toNamed(AppRoutes.My),), Transition 转场动画 lib/common/routes/app_pages.dart 12345GetPage( name: AppRoutes.Detail_ID, page: () =&gt; DetailView(), transition: Transition.downToUp,), © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter getx","slug":"flutter-getx","permalink":"https://blog.ducafecat.tech/tags/flutter-getx/"}]},{"title":"Flutter Bloc 03 - 基础对象 同步、异步 await yield 操作","date":"2021-03-15T16:00:00.000Z","path":"2021/03/16/flutter-bloc/flutter-bloc-03-sync-async-await-yield/","text":"本节目标 同步、异步 sync async 关键字 await yield 加上 * 的区别 视频https://www.bilibili.com/video/BV1JZ4y1w7hX/ 代码https://github.com/ducafecat/flutter-bloc-learn/tree/master/sync-async 正文在 BLOC 中常见 yield yield* Stream计算器 Bloc 代码 我们可以发现在 bloc 模块中，非常多 yield* yield async* ，如何正确使用还是很重要的，所以这篇文章把同步、异步的对应的操作符都整理出来。 12345678910111213141516171819202122232425262728class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; &#123; CounterBloc() : super(CounterInitial(0)); int counterNum = 0; @override Stream&lt;CounterState&gt; mapEventToState( CounterEvent event, ) async* &#123; if (event is CounterIncrementEvent) &#123; yield* _mapIncrementEventToState(event); &#125; else if (event is CounterSubductionEvent) &#123; yield* _mapSubductionEventToState(event); &#125; &#125; Stream&lt;CounterState&gt; _mapIncrementEventToState( CounterIncrementEvent event) async* &#123; this.counterNum += 1; yield CounterChange(this.counterNum); &#125; Stream&lt;CounterState&gt; _mapSubductionEventToState( CounterSubductionEvent event) async* &#123; this.counterNum -= 1; yield CounterChange(this.counterNum); &#125;&#125; 同步 sync* + yield同步 sync 后返回 Iterable 可序列化对象 代码 123456789main() &#123; getList(10).forEach(print);&#125;Iterable&lt;int&gt; getList(int count) sync* &#123; for (int i = 0; i &lt; count; i++) &#123; yield i; &#125;&#125; 输出 12345678910110123456789Exited 我如果把 sync 的 * 去掉,编辑器会提示这是固定格式。 同步 sync + yield带上 * 因为 yield 返回对象是 Iterable 代码 12345678910111213main() &#123; getList(10).forEach(print);&#125;Iterable&lt;int&gt; getList(int count) sync* &#123; yield* generate(count);&#125;Iterable&lt;int&gt; generate(int count) sync* &#123; for (int i = 0; i &lt; count; i++) &#123; yield i; &#125;&#125; 输出 12345678910110123456789Exited 我把 yield 的 * 去掉后，提示返回 Iterable&lt;T&gt; 必须带上 * 异步 async + awaitFuture + async + await 经典配合 常见场景，等待异步完成，比如拉取数据、 IO 操作 代码 12345678910111213141516main() &#123; print(\"start..........\"); getList(10).then(print);&#125;Future&lt;int&gt; getList(int count) async &#123; await sleep(); for (int i = 0; i &lt; count; i++) &#123; return i; &#125; return 99;&#125;Future sleep() async &#123; return Future.delayed(Duration(seconds: 3));&#125; 输出 123start..........0Exited 这里就直接返回了, 没有后续的任何操作。 异步 async* + yield带上 * 后，yield 返回 Stream 对象 接收方用 listen(…) 代码 12345678910main() &#123; getList(10).listen(print);&#125;Stream&lt;int&gt; getList(int count) async* &#123; for (int i = 0; i &lt; count; i++) &#123; await Future.delayed(Duration(seconds: 1)); yield i; &#125;&#125; 输出 12345678910110123456789Exited yield 必须和 async* 或 sync* 配套使用 异步 async + yieldyield* 后返回的是另一个 Stream 对象 代码 1234567891011121314main() &#123; getList(10).listen(print);&#125;Stream&lt;int&gt; getList(int count) async* &#123; yield* generate(count);&#125;Stream&lt;int&gt; generate(int count) async* &#123; for (int i = 0; i &lt; count; i++) &#123; await Future.delayed(Duration(seconds: 1)); yield i; &#125;&#125; 输出 12345678910110123456789Exited 返回 Stream&lt;T&gt; 类型必须是用 yield* 的方式 © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter bloc","slug":"flutter-bloc","permalink":"https://blog.ducafecat.tech/tags/flutter-bloc/"}]},{"title":"2021 关于 Flutter v2 我整理了16个重要特性","date":"2021-03-07T16:00:00.000Z","path":"2021/03/08/flutter-daily/flutter-daily-2021-flutter2-top-engage/","text":"谷歌开发者官文https://mp.weixin.qq.com/s/EzS3dtpZB_i9p358qqlBpg 7 大平台 -&gt; windows、macos、linux、web、embedded、ios、android https://flutter.gskinner.com/ https://github.com/gskinnerTeam/flutter-folio web 平台优化、进入稳定版 3 个方向 pwa: 缓存、push 推送服务、桌面快捷、消息提示 spa: 单页程序类似 vue rect expanding mobile: 快速迁移 app、复用代码 irobot 构建基于 flutter https://edu.irobot.com/the-latest/building-a-coding-experience-for-all 技术架构 2D 3D 渲染 WebGL Skia WebAssembly Canvas 稳定的版本 性能 HTML renderer: HTML 渲染器: Uses a combination of HTML elements, CSS, Canvas elements, and SVG elements. This renderer has a smaller download size. 使用 HTML 元素、 CSS、 Canvas 元素和 SVG 元素的组合 CanvasKit renderer: CanvasKit 渲染器: This renderer is fully consistent with Flutter mobile and desktop, has faster performance with higher widget density, but adds about 2MB in download size. 试水项目 编辑器https://rive.app/ 动画https://flutterplasma.dev/ invoicehttps://www.invoiceninja.com/ canonical 支持https://medium.com/flutter/announcing-flutter-linux-alpha-with-canonical-19eb824590a9 https://canonical.com/ Canonical 公司是一个私营公司，由南非的企业家马克·沙特尔沃思创建，主要为了促进开源软件项目。 Canonical 在马恩岛登记注册，其雇员分布在世界各地，其主要办事处在伦敦，在蒙特利尔也有办事处。Canonical 公司支持并创建了几个项目，主要都是自由/开源软件（FOSS）或是一些旨在改善自由软件开发者和贡献者的工具。 why canonical 大力推 flutter !，主要以下几点 快速增长的 flutter 应用 多平台支持 设备优化的好 丰富的组件库 IDE 环境成熟 Visual Studio Code, Android Studio, and IntelliJ 简易安装 https://snapcraft.io/flutter 123$ snap install --classic flutter$ snap install --classic code$ code --install-extension dart-code.flutter 快速模板 1234567$ flutter channel dev$ flutter upgrade$ flutter config --enable-linux-desktop$ flutter create counter$ cd counter$ flutter run -d linux 现有项目升级 12$ cd my_flutter_app$ flutter create . 代码示例 https://github.com/flutter/samples/tree/master/experimental/desktop_photo_search https://github.com/flutter/gallery 教程 Write a Flutter desktop application https://codelabs.developers.google.com/codelabs/flutter-github-graphql-client/index.html#0 组件库升级、对 ios 支持加强 新增 iOS 功能 CupertinoSearchTextFieldhttps://api.flutter-io.cn/flutter/cupertino/CupertinoSearchTextField-class.html CupertinoFormSection、CupertinoFormRow 和 CupertinoTextFormFieldRowhttps://api.flutter.cn/flutter/cupertino/CupertinoFormSection-class.htmlhttps://api.flutter.cn/flutter/cupertino/CupertinoFormRow-class.htmlhttps://api.flutter.cn/flutter/cupertino/CupertinoTextFormFieldRow-class.html 整体性能优化https://github.com/flutter/flutter/issues/60267#issuecomment-762786388 新增 Widget: Autocomplete 和 ScaffoldMessenger AutocompleteCorehttps://github.com/flutter/flutter/pull/62927 ScaffoldMessengerhttps://github.com/flutter/flutter/pull/64101 Flutter for Surface Duo &amp; 折叠屏 https://docs.microsoft.com/zh-cn/dual-screen/flutter/ https://docs.microsoft.com/zh-cn/dual-screen/flutter/mediaquery 混合编程https://flutter.cn/docs/development/add-to-app 过去，额外 Flutter 实例的内存占用量与第一个 Flutter 实例相同。在 Flutter 2 中，我们将创建额外 Flutter 引擎的静态内存占用量降低了约 99%，使每个实例的占用量大约为 180kB。 Dart Null SafetyDart 是一种类型安全的语言，这意味着当开发者获取某种类型的变量时，编译器可以保证它是该类型，但是类型安全本身不能保证变量不是 null。 Null errors 非常常见的问题，在 GitHub 上 可以搜索到成千上万由于 null 导致 Dart 代码出现异常的问题，甚至有成千上万的 commits 试图解决这些问题。 https://dartpad.dev/ https://nullsafety.dartpad.dev/ 123456789void main() &#123; ps(null);&#125;void ps(List&lt;String&gt; files) &#123; for (var file in files) &#123; print(file.isEmpty()); &#125;&#125; 最后，个人的额外提醒，目前在根目录的 analysis_options.yaml 添加如下配置就可以开启 null safety，另外 Flutter 需要 dart sdk 2.9 。 123analyzer: enable-experiment: - non-nullable flutter fix 统计 1dart fix --dry-run 应用 1dart fix --apply flutter DevTools 开发工具升级 性能监控 https://flutter.dev/docs/perf/rendering/ui-performance .vscode/launch.json 12345678910111213141516171819&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"flutter_learn_news-1.0.15\", \"request\": \"launch\", \"type\": \"dart\" &#125;, &#123; \"name\": \"profile\", \"request\": \"launch\", \"type\": \"dart\", \"flutterMode\": \"profile\" &#125; ]&#125; Invert Oversized Images DevTools 的另一个新功能是能够轻松发现所显示的分辨率低于其实际分辨率的图像，这有助于追踪应用过大和内存占用过多等情况。若要启用此功能，请在 Flutter Inspector 中启用 Invert Oversized Images。 弹性布局 Android Studio/IntelliJ 扩展我们也为 IntelliJ 系列 IDE 的 Flutter 插件添加了一些适用于 Flutter 2 的新功能。首先，我们在其中新增了一个项目向导，该向导与 IntelliJ 中的新向导风格一致。 Visual Studio Code 扩展适用于 Visual Studio Code 的 Flutter 扩展也针对 Flutter 2 进行了优化，我们首先引入了一些测试增强功能，例如重新运行失败测试的能力。 经过两年的逐步发展，对 Dart 的 LSP (语言服务器协议) 支持已经成为在 Flutter 扩展中将 Dart 分析器集成到 Visual Studio Code 中的默认方式。LSP 支持为 Flutter 开发带来了许多改进，包括在当前的 Dart 文件中应用特定的所有修复，以及能够补全代码以生成完整函数调用 (包括括号和所需参数) 的能力。 LSP 支持不仅限于 Dart，它还支持 pubspec.yaml 及 analysis_options.yaml 文件中的代码补全。 sentry 升级对 flutter 的支持https://docs.sentry.io/platforms/flutter/ 整合了对设备端错误的收集 upgraded firebase plugins for flutterhttps://firebase.flutter.dev/ Flutter Community Plus Pluginshttps://plus.fluttercommunity.dev/ google mobile ads for flutter DartPad 升级到支持 Flutter 2 https://dartpad.dev/ 配置 flutter 2 下载 Dev channel (macOS) https://flutter.dev/docs/development/tools/sdk/releases?tab=macos fvm 切换 https://github.com/leoafarias/fvm 复制 sdk 到 /Users/{youname}/.fvm/versions 12fvm listfvm use 2.1.0 启用特性 123flutter config --enable-macos-desktopflutter config --enable-windows-desktopflutter config --enable-linux-desktop 编译 123456flutter run -d windowsflutter run -d macosflutter run -d linuxflutter run -d androidflutter run -d iosflutter run -d web 参考 https://flutter.gskinner.com/ https://github.com/gskinnerTeam/flutter-folio https://mp.weixin.qq.com/s/EzS3dtpZB_i9p358qqlBpg https://docs.sentry.io/platforms/flutter/ https://snapcraft.io/flutter https://plus.fluttercommunity.dev/ https://medium.com/flutter/flutter-web-support-hits-the-stable-milestone-d6b84e83b425 https://rive.app/ https://medium.com/flutter/announcing-flutter-linux-alpha-with-canonical-19eb824590a9 https://www.windowscentral.com/surface-duo © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter Bloc 02 - 基础对象 Stream 流操作","date":"2021-02-19T16:00:00.000Z","path":"2021/02/20/flutter-bloc/flutter-bloc-02-stream/","text":"本节目标 Stream 创建 StreamController 控制 StreamSubscription 订阅 StreamTransformer 转换 Sink、StreamSink、EventSink 修改数据 视频代码https://github.com/ducafecat/flutter-bloc-learn/tree/master/stream 正文核心类 名称 说明 Stream 事件流或者管道 StreamController 事件管理者 StreamSubscription 管理事件订阅，如 cacenl、pause StreamSink 流 Sink 入口，提供如 add、addStream 等 EventSink 事件 Sink 入口 StreamTransformer 流转换 准备函数12345678910111213141516// 打印流列表printStream(Stream&lt;Object&gt; stream) async &#123; await for (var val in stream) &#123; print(val); &#125;&#125;// 异步函数iFuture&lt;int&gt; funi = Future(() &#123; return 100;&#125;);// 异步函数iiFuture&lt;int&gt; funii = Future(() &#123; return 200;&#125;); stream 创建延迟间隔123456789101112periodic() async &#123; Stream&lt;int&gt; stream = Stream&lt;int&gt;.periodic(Duration(seconds: 1), (val) =&gt; val); await printStream(stream);&#125;&gt;&gt;123456 futrue 数据源12345678fromFuture() async &#123; Stream&lt;int&gt; stream = Stream&lt;int&gt;.fromFuture(funi); await printStream(stream);&#125;&gt;&gt;100 futrues 多数据源123456789101112fromFutures() async &#123; Stream&lt;int&gt; stream = Stream&lt;int&gt;.fromFutures([ funi, funii, ]); await printStream(stream);&#125;&gt;&gt;100200 stream 监听单对单12345678910111213141516171819202122listen() async &#123; Stream&lt;int&gt; stream = Stream&lt;int&gt;.periodic(Duration(seconds: 1), (val) =&gt; val); stream.listen( (event) &#123; print(event); &#125;, onError: (err) &#123; print(err); &#125;, onDone: () &#123;&#125;, cancelOnError: true, );&#125;&gt;&gt;123456 广播1234567891011121314151617181920212223boardcast() async &#123; Stream&lt;int&gt; stream = Stream&lt;int&gt;.periodic(Duration(seconds: 1), (val) =&gt; val) .asBroadcastStream(); stream.listen((event) &#123; print(event); &#125;); stream.listen((event) &#123; print(event); &#125;);&#125;&gt;&gt;1122334455 操作 task skip12345678910111213141516171819opt() async &#123; Stream&lt;int&gt; stream = Stream&lt;int&gt;.fromIterable([1, 2, 3, 4, 5]); stream = stream.take(3); // stream = stream.skip(2); stream.listen((event) &#123; print(event); &#125;);&#125;&gt;&gt; take(3)123&gt;&gt; skip(2)345 StreamController 流控制类 单点12345678910111213141516171819202122232425262728293031scListen() async &#123; StreamController sc = StreamController( onListen: () =&gt; print(\"onListen\"), onPause: () =&gt; print(\"onPause\"), onResume: () =&gt; print(\"onResume\"), onCancel: () =&gt; print(\"onCancel\"), sync: false); // 订阅对象 StreamSubscription ss = sc.stream.listen(((event) &#123; print(event); &#125;)); sc.add(100); // 暂停 ss.pause(); // 恢复 ss.resume(); // 取消 ss.cancel(); // 关闭流 sc.close();&#125;&gt;&gt;onListenonPauseonCancel 广播123456789101112131415161718192021222324scBroadcast() async &#123; StreamController sc = StreamController.broadcast(); StreamSubscription ss1 = sc.stream.listen(print); StreamSubscription ss2 = sc.stream.listen(print); sc.addStream(Stream.fromIterable([1, 2, 3, 4, 5])); await Future.delayed(Duration(seconds: 2)); sc.close();&#125;&gt;&gt;1122334455 StreamTransformer 流转换 123456789101112131415161718192021222324252627282930313233343536scTransformer() async &#123; StreamController sc = StreamController&lt;int&gt;.broadcast(); StreamTransformer stf = StreamTransformer&lt;int, double&gt;.fromHandlers( handleData: (int data, EventSink sink) &#123; sink.add((data * 2).toDouble()); &#125;, handleError: (error, stacktrace, sink) &#123; sink.addError('wrong: $error'); &#125;, handleDone: (sink) &#123; sink.close(); &#125;, ); Stream stream = sc.stream.transform(stf); stream.listen(print); stream.listen(print); sc.addStream(Stream&lt;int&gt;.fromIterable([1, 2, 3, 4, 5])); await Future.delayed(Duration(seconds: 2)); sc.close();&#125;&gt;&gt;224466881010 执行123456789101112131415161718main(List&lt;String&gt; args) async &#123; print('--- start ---'); // await periodic(); // await fromFuture(); // await fromFutures(); // await listen(); // await boardcast(); // await opt(); // await scListen(); // await scBroadcast(); // await scTransformer(); print('--- end ---');&#125; © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter bloc","slug":"flutter-bloc","permalink":"https://blog.ducafecat.tech/tags/flutter-bloc/"}]},{"title":"Flutter Bloc 01 - 快速上手 计算器","date":"2020-12-07T16:00:00.000Z","path":"2020/12/08/flutter-bloc/flutter-bloc-01-counter-quick-start/","text":"本节目标 为什么要用 bloc bloc vs provider 学习路线推荐 安装 bloc vscode 插件 配置 bloc 依赖包 编写计算器示例 视频https://www.bilibili.com/video/BV1ef4y1e79o/ 代码https://github.com/ducafecat/flutter-bloc-learn/tree/master/ducafecat_bloc_start_example 正文为什么要用 bloc 状态管理（这是必须的） 三层分离 表现层（Presentation) 业务逻辑（Business Logic) 数据层（Data) 数据源/库（Repository) 数据提供者（Data Provider) 规范组内开发 方便的 测试、记录 用户行为 123456789101112131415161718192021222324252627class SimpleBlocDelegate extends BlocDelegate &#123; @override void onEvent(Bloc bloc, Object event) &#123; super.onEvent(bloc, event); print('$&#123;bloc.runtimeType&#125; $event'); // 所有的UI事件 // 可用 umeng 这样平台 进行跟踪 &#125; @override void onError(Bloc bloc, Object error, StackTrace stacktrace) &#123; super.onError(bloc, error, stacktrace); print('$&#123;bloc.runtimeType&#125; $error'); // 所有发生的错误 // 用 sentry 记录错误 &#125; @override void onTransition(Bloc bloc, Transition transition) &#123; super.onTransition(bloc, transition); print(transition); // 所有的 State 变化 &#125;&#125; bloc vs provider bloc 是一种 mvvm 基于 事件、状态 驱动的 provider 是基于方法的 bloc 学习路线 Flutter Bloc 快速上手 -&gt; Stream -&gt; Cubit -&gt; Bloc 理解基于 mvvm 组件化拆分 安装 bloc vscode 插件bloc 创建项目 pubspec.yaml 12345678name: ducafecat_bloc_start_example...dependencies: ... bloc: ^6.1.0 flutter_bloc: ^6.1.0 equatable: ^1.2.5 目录结构 counter 计算器业务下创建 bloc view 目录，这样就分离了 编写 bloc lib/counter/bloc/counter_bloc.dart 12345678910111213141516171819202122232425262728293031323334353637import 'dart:async';import 'package:bloc/bloc.dart';import 'package:equatable/equatable.dart';import 'package:meta/meta.dart';part 'counter_event.dart';part 'counter_state.dart';class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; &#123; CounterBloc() : super(CounterInitial(0)); int counterNum = 0; @override Stream&lt;CounterState&gt; mapEventToState( CounterEvent event, ) async* &#123; if (event is CounterIncrement) &#123; yield* _mapIncrementEventToState(event); &#125; else if (event is CounterSubduction) &#123; yield* _mapSubductionEventToState(event); &#125; &#125; Stream&lt;CounterState&gt; _mapIncrementEventToState( CounterIncrement event) async* &#123; this.counterNum += 1; yield CounterChange(this.counterNum); &#125; Stream&lt;CounterState&gt; _mapSubductionEventToState( CounterSubduction event) async* &#123; this.counterNum -= 1; yield CounterChange(this.counterNum); &#125;&#125; lib/counter/bloc/counter_event.dart 1234567891011part of 'counter_bloc.dart';@immutableabstract class CounterEvent extends Equatable &#123; @override List&lt;Object&gt; get props =&gt; [];&#125;class CounterIncrement extends CounterEvent &#123;&#125;class CounterSubduction extends CounterEvent &#123;&#125; lib/counter/bloc/counter_state.dart 12345678910111213141516171819part of 'counter_bloc.dart';@immutableabstract class CounterState extends Equatable &#123; final int value; const CounterState(this.value); @override List&lt;Object&gt; get props =&gt; [value];&#125;class CounterInitial extends CounterState &#123; CounterInitial(int value) : super(value);&#125;class CounterChange extends CounterState &#123; CounterChange(int value) : super(value);&#125; 编写 view lib/counter/view/page.dart 12345678910111213141516import 'package:ducafecat_bloc_start_example/counter/bloc/counter_bloc.dart';import 'package:ducafecat_bloc_start_example/counter/view/view.dart';import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';class CounterPage extends StatelessWidget &#123; const CounterPage(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return BlocProvider( create: (context) =&gt; CounterBloc(), child: CounterView(), ); &#125;&#125; lib/counter/view/view.dart 12345678910111213141516171819202122232425262728293031323334353637import 'package:ducafecat_bloc_start_example/counter/bloc/counter_bloc.dart';import 'package:flutter/material.dart';import 'package:flutter_bloc/flutter_bloc.dart';class CounterView extends StatelessWidget &#123; const CounterView(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('Counter')), body: Center( child: Column( children: [ BlocBuilder&lt;CounterBloc, CounterState&gt;( builder: (context, state) &#123; return Text('$&#123;state.value&#125;'); &#125;, ), RaisedButton( child: Text('加法'), onPressed: () &#123; BlocProvider.of&lt;CounterBloc&gt;(context).add(CounterIncrement()); &#125;, ), RaisedButton( child: Text('加法'), onPressed: () &#123; BlocProvider.of&lt;CounterBloc&gt;(context).add(CounterSubduction()); &#125;, ) ], ), ), ); &#125;&#125; 替换主程序 widget lib/main.dart 12345678910class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( ... home: CounterPage(), //MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125; 参考 https://bloclibrary.dev/ https://pub.flutter-io.cn/packages/bloc https://pub.flutter-io.cn/packages/flutter_bloc https://pub.flutter-io.cn/packages/equatable https://pub.flutter-io.cn/packages/provider © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter bloc","slug":"flutter-bloc","permalink":"https://blog.ducafecat.tech/tags/flutter-bloc/"}]},{"title":"Flutter 2020 开源项目推荐 第一弹","date":"2020-11-02T16:00:00.000Z","path":"2020/11/03/flutter-daily/flutter-2020-learn-opensource/","text":"视频https://www.bilibili.com/video/BV13D4y1R71r/ 关注点 目录文件结构 是否符合官方的包管理规范， 组件拆分 页面、组件、通用、业务 工具类设计 通讯、持久化、安全、字符、数字、浮点 第三方组件 流媒体、播放器、编辑器、图片、Web 视图、原生扩展 状态管理 bloc、provider 云服务 firebase、google cloud、AWS、serverless 业务完整性 可运行、业务全 ★ Prism 壁纸 ★https://github.com/Hash-Studios/Prism ★ Flutter-Movies4U 电影资讯 ★https://github.com/webaddicted/Flutter-Movies4U ★ anytime_podcast_player podcast 播放器 ★https://github.com/amugofjava/anytime_podcast_player ★ gcloud-dota-app dota 游戏资讯 全栈项目 ★flutter + react + go + firebase + google cloud https://github.com/alvarowolfx/gcloud-dota-app ★ LunaSea 多媒体网盘管理 ★https://github.com/CometTools/LunaSea ★ passwall-mobile 密码管理 全栈项目 ★flutter + electron + go https://github.com/aeosmanoglu/passwall-mobilehttps://github.com/passwall/passwall-serverhttps://github.com/passwall/passwall-desktophttps://passwall.io restofinder 美食https://github.com/yusriltakeuchi/restofinder SongTube-App 音乐播放下载https://github.com/SongTube/SongTube-App © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"2020 macbook pro 16寸 前端开发，看看我都装了哪些软件","date":"2020-10-11T16:00:00.000Z","path":"2020/10/12/flutter-daily/macbook-pro-16-tools-2020/","text":"视频https://www.bilibili.com/video/BV1854y1R7LG/ 系统Homebrew包管理工具，主要安装命令行工具 https://brew.sh/index_zh-cn homebrew-cask包管理扩展工具，主要安装 gui 工具 https://github.com/Homebrew/homebrew-cask git源码控制 1$ brew install git iTerm2shell 工具 https://www.iterm2.com/ powerline font字体 https://github.com/powerline/fonts firacode font字体 https://github.com/tonsky/FiraCode zshshell 工具 1$ brew install zsh oh-my-zshzsh 集成工具 https://ohmyz.sh/ https://github.com/ohmyzsh/ohmyzsh/wiki/themes 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; autojumpzsh 插件 快速导航目录 https://github.com/wting/autojump zsh-autosuggestionszsh 插件 快速提示历史输入 https://github.com/zsh-users/zsh-autosuggestions zsh-syntax-highlightingzsh 插件 美化显示 https://github.com/zsh-users/zsh-syntax-highlighting node &amp; nvmnode 版本管理 https://github.com/nvm-sh/nvm whistle抓包管理 https://github.com/avwo/whistle Charles抓包管理 俗称水瓶 https://www.charlesproxy.com/ Bartender 3顶部菜单项隐藏 https://www.macbartender.com/ CleanMyMac X清理电脑 https://macpaw.com/cleanmymac Docker容器管理 https://www.docker.com/ ClashX科学上网 https://github.com/yichengchen/clashX/ V2rayU科学上网 https://github.com/yanue/V2rayU/releases Keka压缩解压 https://www.keka.io/en/ Mountyntfs 磁盘读写 https://mounty.app/ 工具chrome浏览器 https://www.google.cn/chrome/ edge浏览器 https://www.microsoft.com/en-us/edge firefox浏览器 http://www.firefox.com.cn/ sourcetreegit 管理 https://www.sourcetreeapp.com/ CheatSheet快捷键提示 https://www.mediaatelier.com/CheatSheet/ alfred阿芙管家 https://www.alfredapp.com/ snipaste截图 https://docs.snipaste.com/zh-cn/ iShot截图 https://apps.apple.com/cn/app/ishot-%E6%88%AA%E5%9B%BE-%E5%BD%95%E5%B1%8F-2020%E5%85%A8%E6%96%B0%E9%AB%98%E5%BA%A6/id1485844094?mt=12 licecapgif 录制 https://www.cockos.com/licecap/ 有道笔记知识管理 http://note.youdao.com/ notion知识管理 https://www.notion.so/ trello知识管理 https://trello.com/ typoramarkdown 写作 https://typora.io/ 语雀知识管理 https://www.yuque.com/ 印象笔记知识管理 https://yinxiang.com/ securecrtssh 客户端 https://www.vandyke.com/products/securecrt/ finalshellssh 客户端 https://www.hostbuf.com/ 网页 MuMuandroid 模拟器 https://mumu.163.com/mac/index.html 百度网盘网盘 https://pan.baidu.com/ Downie 4下载油管视频 https://software.charliemonroe.net/downie/ EasyRes屏幕分辨率切换 http://easyresapp.com/ Free Download Manager下载工具 https://www.freedownloadmanager.org/zh/ iStat Menus状态管理 https://setapp.com/ pap.er壁纸管理 https://paper.meiyuan.in/ Parallels Desktop虚拟机管理 工作用 https://www.parallels.com/ virtualbox虚拟机管理 试验用 https://www.virtualbox.org/ vmware虚拟机管理 试验用 https://www.vmware.com/hk.html SwitchHosts!切换 host https://github.com/oldj/SwitchHosts Reeder 4rss 阅读器 https://apps.apple.com/cn/app/reeder-4/id1449412482?mt=12 ScreenFlow录视频 https://www.telestream.net/screenflow/overview.htm TeamViewer远程写作 https://www.teamviewer.cn draw.io画图 https://www.diagrams.net/ Foxmail轻巧邮件管理 https://www.foxmail.com/ Microsoft To Do任务管理 https://todo.microsoft.com/ Microsoft Remote Desktop远程 windows https://www.microsoft.com/en-us/download/details.aspx?id=50042 WPS Officeword ppt excel https://www.wps.cn/ 通讯QQ、微信、企业微信、Telegram 央视影音看电视 比赛 直播 https://app.cctv.com/appkhdxz/ysyymac/ IINA播放器 https://iina.io/ solarized theme多端样式配色 https://ethanschoonover.com/solarized/ 开发sublimehttp://www.sublimetext.com/ vscodehttps://code.visualstudio.com/ xcodehttps://developer.apple.com/xcode/ android stuidohttps://developer.android.com/studio HBuilderXhttps://www.dcloud.io/hbuilderx.html 微信开发者工具https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html TinyPNG4Mac图片压缩 https://github.com/kyleduo/TinyPNG4Mac/blob/master/README_ZH.md 1$ brew cask install tinypng4mac dash离线文档工具 https://kapeli.com/dash postmanapi 调试 https://www.postman.com/ adobe ps xd设计 https://www.adobe.com/cn/ sketch设计 https://www.sketch.com/ axure原型设计 https://www.axure.com/ pxcook标注工具 https://www.fancynode.com.cn/pxcook mindnode思维脑图 https://apps.apple.com/cn/app/mindnode-mind-map/id1289197285?mt=12 diffmerge文件比较 http://sourcegear.com/diffmerge RedisDesktopManagerredis 管理客户端 https://github.com/uglide/RedisDesktopManager DBeaver多数据库 客户端 https://dbeaver.io/ Navicat Premiummysql 客户端 http://www.navicat.com.cn/store/navicat-premium pdman关系数据库设计工具 https://gitee.com/robergroup/pdman GoLandhttps://www.jetbrains.com/go/ IDEAhttps://www.jetbrains.com/ © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"macbook","slug":"macbook","permalink":"https://blog.ducafecat.tech/tags/macbook/"}]},{"title":"HarmonyOS 真的是套壳么，我也好奇的玩了下","date":"2020-09-17T16:00:00.000Z","path":"2020/09/18/flutter-daily/harmonyos-2020-v2-research/","text":"上手一个 Hello Word!https://developer.harmonyos.com/cn/develop/deveco-studio#download 了解下 HUAWEIhttps://www.huawei.com 总结 华为是做基建、通讯设备的公司 行业跨度大，企事业+个人业务 趋势 IoT 设备互联是资源整合的 HarmonyOS 源码https://openharmony.gitee.com 核心 kernel_liteos_a 适用于 cpu 内存 大的 https://gitee.com/openharmony/kernel_liteos_a kernel_liteos_m 适用于建议设备 https://gitee.com/openharmony/kernel_liteos_m 基于开源项目 http://nuttx.apache.org/ 开发板卡https://device.harmonyos.com/cn/docs/start/introduce/oem_start_guide-0000001054913231https://gitee.com/openharmony/docs/blob/master/quick-start/Hi3861开发板介绍.md 引用 华为官网 开发者 开发版卡 HarmonyOS 文档 HarmonyOS 源码 © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://blog.ducafecat.tech/tags/HarmonyOS/"}]},{"title":"Flutter 2020 学习心得、学习路线","date":"2020-09-02T16:00:00.000Z","path":"2020/09/03/flutter-daily/flutter-2020-how-to-learn-flutter-develop/","text":"视频https://www.bilibili.com/video/BV1CT4y1L7At/ 新人上手情况 语言基础 数据结构 网络通信 前端布局 动画 优化点 前端遇到的最大问题 原生调试 原生组件开发 聊聊学习动机 单位工作需要 自己兴趣开发 APP 毕业设计 漫无目的、漫无目的的学习 学习路线https://github.com/olexale/flutter_roadmap 资源 官网 darthttps://dart.dev/guides/language/language-tour 官网 flutterhttps://flutter.dev/https://flutter.cn/ juejinhttps://juejin.im/tag/Flutter mediumhttps://medium.com/tag/flutter flutter awesome githubhttps://github.com/Solido/awesome-flutterhttps://github.com/crazycodeboy/awesome-flutter-cn flutter awesome webhttps://flutterawesome.com/ otherhttps://twitter.com/search?q=flutterdevhttps://www.facebook.com/search/groups/?q=flutter%20dev 总结最快的学习方式有个目标、看优秀源代码，完成你的作品、上线！ © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 混合开发 - 03 百度地图定位功能 ios 篇","date":"2020-08-20T16:00:00.000Z","path":"2020/08/21/flutter-daily/flutter-plugins-03-baidu-map-ios/","text":"本节目标 创建 ios flutter 插件流程 集成百度定位功能 视频https://www.bilibili.com/video/BV1HT4y1L73i/ 代码https://github.com/ducafecat/flutter_baidu_plugin_ducafecat/releases/tag/v1.0.3 百度平台部分设置 AKhttps://lbsyun.baidu.com/apiconsole/key#/home 添加应用 查看 Bundle Identifier IOS 部分自动部署 CocoaPods 安装工具 1sudo gem install cocoapods ios/flutter_baidu_plugin_ducafecat.podspec 123456789 ... s.dependency &apos;Flutter&apos; s.platform = :ios, &apos;8.0&apos; s.dependency &apos;BMKLocationKit&apos; # Flutter.framework does not contain a i386 slice. Only x86_64 simulators are supported. s.pod_target_xcconfig = &#123; &apos;DEFINES_MODULE&apos; =&gt; &apos;YES&apos;, &apos;VALID_ARCHS[sdk=iphonesimulator*]&apos; =&gt; &apos;x86_64&apos; &#125;end 安装百度 sdk 包 1pod install 升级 1pod repo update pod search 无法搜索到类库的解决办法（找不到类库） 1234567891011（1）执行pod setup（2）删除~/Library/Caches/CocoaPods目录下的search_index.json文件 pod setup成功后会生成~/Library/Caches/CocoaPods/search_index.json文件 终端输入rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行pod search（3）执行pod search Info.plist 定位授权example/ios/Runner/Info.plist 123&lt;dict&gt; &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;需要定位&lt;/string&gt; 消息通知 BdmapFlutterStreamManager ios/Classes/BdmapFlutterStreamManager.h 123456789101112131415161718192021222324//// Header.h// bdmap_location_flutter_plugin//// Created by Wang,Shengzhan on 2020/2/4.//#import &lt;Foundation/Foundation.h&gt;#import &lt;Flutter/Flutter.h&gt;NS_ASSUME_NONNULL_BEGIN@class BdmapFlutterStreamHandler;@interface BdmapFlutterStreamManager : NSObject+ (instancetype)sharedInstance ;@property (nonatomic, strong) BdmapFlutterStreamHandler* streamHandler;@end@interface BdmapFlutterStreamHandler : NSObject&lt;FlutterStreamHandler&gt;@property (nonatomic, strong) FlutterEventSink eventSink;@endNS_ASSUME_NONNULL_END ios/Classes/BdmapFlutterStreamManager.m 123456789101112131415161718192021222324252627282930313233343536373839//// BdmapFlutterStreamManager.m// bdmap_location_flutter_plugin//// Created by Wang,Shengzhan on 2020/2/4.//#import \"BdmapFlutterStreamManager.h\"@implementation BdmapFlutterStreamManager+ (instancetype)sharedInstance &#123; static dispatch_once_t onceToken; static BdmapFlutterStreamManager *manager = nil; dispatch_once(&amp;onceToken, ^&#123; manager = [[BdmapFlutterStreamManager alloc] init]; BdmapFlutterStreamHandler * streamHandler = [[BdmapFlutterStreamHandler alloc] init]; manager.streamHandler = streamHandler; &#125;); return manager;&#125;@end@implementation BdmapFlutterStreamHandler- (FlutterError*)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)eventSink &#123; self.eventSink = eventSink; return nil;&#125;- (FlutterError*)onCancelWithArguments:(id)arguments &#123; return nil;&#125;@end 地图接口业务 FlutterBaiduPluginDucafecatPlugin ios/Classes/FlutterBaiduPluginDucafecatPlugin.h 1234#import &lt;Flutter/Flutter.h&gt;@interface FlutterBaiduPluginDucafecatPlugin : NSObject&lt;FlutterPlugin&gt;@end ios/Classes/FlutterBaiduPluginDucafecatPlugin.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358#import \"FlutterBaiduPluginDucafecatPlugin.h\"#import \"BMKLocationkit/BMKLocationComponent.h\"#import \"BdmapFlutterStreamManager.h\"@interface FlutterBaiduPluginDucafecatPlugin()&lt;BMKLocationManagerDelegate&gt;@property (nonatomic,strong) BMKLocationManager *locManager;@property (nonatomic, copy) FlutterResult flutterResult;@end@implementation FlutterBaiduPluginDucafecatPlugin+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; // FlutterMethodChannel* channel = [FlutterMethodChannel // methodChannelWithName:@\"flutter_baidu_plugin_ducafecat\" // binaryMessenger:[registrar messenger]]; // FlutterBaiduPluginDucafecatPlugin* instance = [[FlutterBaiduPluginDucafecatPlugin alloc] init]; // [registrar addMethodCallDelegate:instance channel:channel]; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@\"flutter_baidu_plugin_ducafecat\" binaryMessenger:[registrar messenger]]; FlutterBaiduPluginDucafecatPlugin* instance = [[FlutterBaiduPluginDucafecatPlugin alloc] init]; [registrar addMethodCallDelegate:instance channel:channel]; FlutterEventChannel *eventChanel = [FlutterEventChannel eventChannelWithName:@\"flutter_baidu_plugin_ducafecat_stream\" binaryMessenger:[registrar messenger]]; [eventChanel setStreamHandler:[[BdmapFlutterStreamManager sharedInstance] streamHandler]];&#125;// - (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123;// if ([@\"getPlatformVersion\" isEqualToString:call.method]) &#123;// result([@\"iOS \" stringByAppendingString:[[UIDevice currentDevice] systemVersion]]);// &#125;// else if ([@\"duAddOne\" isEqualToString:call.method]) &#123;// NSInteger val = 100;// val += [[call.arguments objectForKey:@\"num\"] intValue];// result([NSNumber numberWithLong:val]);// &#125;// else &#123;// result(FlutterMethodNotImplemented);// &#125;// &#125;- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123; if ([@\"getPlatformVersion\" isEqualToString:call.method]) &#123; result([@\"iOS \" stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); &#125; else if ([@\"startLocation\" isEqualToString:call.method])&#123; // 开始定位// NSLog((@\"\\n[bdmap_loc_flutter_plugin:%s]\"), \"startLocation...\"); [self startLocation:result]; &#125;else if ([@\"stopLocation\" isEqualToString:call.method])&#123; // 停止定位// NSLog((@\"\\n[bdmap_loc_flutter_plugin:%s]\"), \"stopLocation...\"); [self stopLocation]; result(@YES); &#125; else if ([@\"updateOption\" isEqualToString:call.method] ) &#123; // 设置定位参数 result(@([self updateOption:call.arguments])); &#125; else if ([@\"setApiKey\" isEqualToString:call.method])&#123; // 设置ios端ak// NSLog((@\"\\n[bdmap_loc_flutter_plugin:%s]\"), \"setApiKey...\"); [[BMKLocationAuth sharedInstance] checkPermisionWithKey:call.arguments authDelegate:self]; result(@YES); &#125; else &#123; result(FlutterMethodNotImplemented); &#125;&#125;/** 获取设置的期望定位精度 */-(double)getDesiredAccuracy:(NSString*)str&#123; if([@\"kCLLocationAccuracyBest\" isEqualToString:str]) &#123; return kCLLocationAccuracyBest; &#125; else if ([@\"kCLLocationAccuracyNearestTenMeters\" isEqualToString:str]) &#123; return kCLLocationAccuracyNearestTenMeters; &#125; else if ([@\"kCLLocationAccuracyHundredMeters\" isEqualToString:str]) &#123; return kCLLocationAccuracyHundredMeters; &#125; else if ([@\"kCLLocationAccuracyKilometer\" isEqualToString:str]) &#123; return kCLLocationAccuracyKilometer; &#125; else &#123; return kCLLocationAccuracyBest; &#125;&#125;/** 获取设置的经纬度坐标系类型 */-(int)getCoordinateType:(NSString*)str&#123; if([@\"BMKLocationCoordinateTypeBMK09LL\" isEqualToString:str]) &#123; return BMKLocationCoordinateTypeBMK09LL; &#125; else if ([@\"BMKLocationCoordinateTypeBMK09MC\" isEqualToString:str]) &#123; return BMKLocationCoordinateTypeBMK09MC; &#125; else if ([@\"BMKLocationCoordinateTypeWGS84\" isEqualToString:str]) &#123; return BMKLocationCoordinateTypeWGS84; &#125; else if ([@\"BMKLocationCoordinateTypeGCJ02\" isEqualToString:str]) &#123; return BMKLocationCoordinateTypeGCJ02; &#125; else &#123; return BMKLocationCoordinateTypeGCJ02; &#125;&#125;/** 获取设置的应用位置类型 */-(int)getActivityType:(NSString*)str&#123; if ([@\"CLActivityTypeOther\" isEqualToString:str]) &#123; return CLActivityTypeOther; &#125; else if ([@\"CLActivityTypeAutomotiveNavigation\" isEqualToString:str]) &#123; return CLActivityTypeAutomotiveNavigation; &#125; else if ([@\"CLActivityTypeFitness\" isEqualToString:str]) &#123; return CLActivityTypeFitness; &#125; else if ([@\"CLActivityTypeOtherNavigation\" isEqualToString:str]) &#123; return CLActivityTypeOtherNavigation; &#125; else &#123; return CLActivityTypeAutomotiveNavigation; &#125;&#125;/** 解析flutter端所设置的定位SDK参数 */-(BOOL)updateOption:(NSDictionary*)args &#123; if(self.locManager) &#123;// NSLog(@\"定位参数配置:%@\",args); self.locManager.isNeedNewVersionReGeocode = YES; // 设置期望定位精度 if ([[args allKeys] containsObject:@\"desiredAccuracy\"]) &#123; [self.locManager setDesiredAccuracy:[ self getDesiredAccuracy: args[@\"desiredAccuracy\"]]]; &#125; // 设置定位的最小更新距离 if ([[args allKeys] containsObject:@\"distanceFilter\"]) &#123; self.locManager.distanceFilter = [args[@\"distanceFilter\"] doubleValue];// NSLog(@\"最小更新距离值:%f\", [args[@\"distanceFilter\"] doubleValue]); &#125; // 设置返回位置坐标系类型 if ([[args allKeys] containsObject:@\"BMKLocationCoordinateType\"]) &#123; [self.locManager setCoordinateType:[ self getCoordinateType: args[@\"desiredAccuracy\"]]]; &#125; // 设置应用位置类型 if ([[args allKeys] containsObject:@\"activityType\"]) &#123; [self.locManager setActivityType:[ self getActivityType: args[@\"desiredAccuracy\"]]]; &#125; // 设置是否需要返回新版本rgc信息 if ([[args allKeys] containsObject:@\"isNeedNewVersionRgc\"]) &#123; if ((bool)args[@\"desiredAccuracy\"]) &#123;// NSLog(@\"需要返回新版本rgc信息\"); self.locManager.isNeedNewVersionReGeocode = YES; &#125; else &#123;// NSLog(@\"不需要返回新版本rgc信息\"); self.locManager.isNeedNewVersionReGeocode = NO; &#125; &#125; // 指定定位是否会被系统自动暂停 if ([[args allKeys] containsObject:@\"pausesLocationUpdatesAutomatically\"]) &#123; if ((bool)args[@\"pausesLocationUpdatesAutomatically\"]) &#123;// NSLog(@\"设置定位被系统自动暂停\"); self.locManager.isNeedNewVersionReGeocode = YES; &#125; else &#123;// NSLog(@\"设置定位不能被系统自动暂停\"); self.locManager.isNeedNewVersionReGeocode = NO; &#125; &#125; // 设置是否允许后台定位 if ([[args allKeys] containsObject:@\"allowsBackgroundLocationUpdates\"]) &#123; if ((bool)args[@\"allowsBackgroundLocationUpdates\"]) &#123;// NSLog(@\"设置允许后台定位\"); self.locManager.isNeedNewVersionReGeocode = YES; &#125; else &#123;// NSLog(@\"设置不允许后台定位\"); self.locManager.isNeedNewVersionReGeocode = NO; self.locManager.distanceFilter = kCLDistanceFilterNone; &#125; &#125; // 设置定位超时时间 if ([[args allKeys] containsObject:@\"locationTimeout\"]) &#123; [self.locManager setLocationTimeout:[args[@\"locationTimeout\"] integerValue]]; self.locManager.coordinateType = BMKLocationCoordinateTypeGCJ02; &#125; // 设置逆地理超时时间 if ([[args allKeys] containsObject:@\"reGeocodeTimeout\"]) &#123; [self.locManager setReGeocodeTimeout:[args[@\"reGeocodeTimeout\"] integerValue]]; &#125; return YES; &#125; return NO;&#125;/** 启动定位 */- (void)startLocation:(FlutterResult)result&#123; self.flutterResult = result; [self.locManager startUpdatingLocation];&#125;/** 停止定位 */- (void)stopLocation&#123; self.flutterResult = nil; [self.locManager stopUpdatingLocation];&#125;- (BMKLocationManager *)locManager &#123; if (!_locManager) &#123; _locManager = [[BMKLocationManager alloc] init]; _locManager.locatingWithReGeocode = YES; _locManager.delegate = self; &#125; return _locManager;&#125;/** * @brief 连续定位回调函数 * @param manager 定位 BMKLocationManager 类。 * @param location 定位结果。 */- (void)BMKLocationManager:(BMKLocationManager * _Nonnull)manager didUpdateLocation:(BMKLocation * _Nullable)location orError:(NSError * _Nullable)error&#123; if (error) &#123;// NSLog(@\"locError:&#123;%ld - %@&#125;;\", (long)error.code, error.localizedDescription); &#125; if (location) &#123; // 得到定位信息，添加annotation NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithCapacity:1]; if (location) &#123; if (location.location.timestamp) &#123; [dic setObject:[self getFormatTime:location.location.timestamp] forKey:@\"locTime\"]; // 定位时间 &#125; if (location.location.horizontalAccuracy) &#123; [dic setObject:@(location.location.horizontalAccuracy) forKey:@\"radius\"]; // 定位精度 &#125; if (location.location.coordinate.latitude) &#123; [dic setObject:@(location.location.coordinate.latitude) forKey:@\"latitude\"]; // 纬度 &#125; if (location.location.coordinate.longitude) &#123; [dic setObject:@(location.location.coordinate.longitude) forKey:@\"longitude\"]; // 经度 &#125; if (location.location.altitude) &#123;// NSLog(@\"返回海拔高度信息\"); [dic setObject:@(location.location.altitude) forKey:@\"altitude\"];// 高度 &#125; if (location.rgcData) &#123; [dic setObject:[location.rgcData country] forKey:@\"country\"]; // 国家 [dic setObject:[location.rgcData province] forKey:@\"province\"]; // 省份 [dic setObject:[location.rgcData city] forKey:@\"city\"]; // 城市 if (location.rgcData.district) &#123; [dic setObject:[location.rgcData district] forKey:@\"district\"]; // 区县 &#125; if (location.rgcData.street) &#123; [dic setObject:[location.rgcData street] forKey:@\"street\"]; // 街道 &#125; if (location.rgcData.description) &#123; // 地址信息 [dic setObject:[location.rgcData description] forKey:@\"address\"]; &#125; if (location.rgcData.poiList) &#123; NSString* poilist; if (location.rgcData.poiList.count == 1) &#123; for (BMKLocationPoi * poi in location.rgcData.poiList) &#123; poilist = [[poi name] stringByAppendingFormat:@\",%@,%@\", [poi tags], [poi addr]]; &#125; &#125; else &#123; for (int i = 0; i &lt; location.rgcData.poiList.count - 1 ; i++) &#123; poilist = [poilist stringByAppendingFormat:@\"%@,%@,%@|\", location.rgcData.poiList[i].name,location.rgcData.poiList[i].tags,location.rgcData.poiList[i].addr]; &#125; poilist = [poilist stringByAppendingFormat:@\"%@,%@,%@\", location.rgcData.poiList[location.rgcData.poiList.count-1].name,location.rgcData.poiList[location.rgcData.poiList.count-1].tags,location.rgcData.poiList[location.rgcData.poiList.count-1].addr]; &#125; [dic setObject: poilist forKey:@\"poiList\"]; // 周边poi信息 &#125; &#125; &#125; else &#123; [dic setObject: @1 forKey:@\"errorCode\"]; // 定位结果错误码 [dic setObject:@\"location is null\" forKey:@\"errorInfo\"]; // 定位错误信息 &#125; // 定位结果回调时间 [dic setObject:[self getFormatTime:[NSDate date]] forKey:@\"callbackTime\"]; [[BdmapFlutterStreamManager sharedInstance] streamHandler].eventSink(dic);// NSLog(@\"x=%f,y=%f\",location.location.coordinate.latitude,location.location.coordinate.longitude); &#125;&#125;/** 格式化时间 */- (NSString *)getFormatTime:(NSDate*)date&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@\"YYYY-MM-dd HH:mm:ss\"]; NSString *timeString = [formatter stringFromDate:date]; return timeString;&#125;@end Flutter 部分设置 AK12345678910@overridevoid initState() &#123; super.initState(); _requestPermission(); // 执行权限请求 if (Platform.isIOS == true) &#123; FlutterBaiduPluginDucafecat.setApiKeyForIOS( \"dkYT07blcAj3drBbcN1eGFYqt16HP1pR\"); &#125;&#125; 其它代码和 android 同接口 无影响 参考 https://lbsyun.baidu.com/apiconsole/key#/home https://flutter.dev/docs/development/packages-and-plugins/developing-packages#step-2c-add-ios-platform-code-swifthm http://lbsyun.baidu.com/index.php?title=ios-locsdk/guide/create-project/cocoapods-create http://lbsyun.baidu.com/index.php?title=ios-locsdk © 猫哥 https://ducafecat.tech https://ducafecat.gitee.io","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 混合开发 - 02 百度地图定位功能 android 篇","date":"2020-08-03T16:00:00.000Z","path":"2020/08/04/flutter-daily/flutter-plugins-02-baidu-map-android/","text":"本节目标 百度地图业务 百度组件初始 编写定位代码 android 篇 环境1234567$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, 1.20.1, on Mac OS X 10.15.6 19G73, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)[✓] Xcode - develop for iOS and macOS (Xcode 11.6)[✓] Android Studio (version 4.0)[✓] VS Code (version 1.47.3) 视频https://www.bilibili.com/video/BV1iK411T7LC/ 代码https://github.com/ducafecat/flutter_baidu_plugin_ducafecat/releases/tag/v1.0.2 可以直接用 👇 v1.0.3 https://github.com/ducafecat/flutter_baidu_plugin_ducafecat/releases/tag/v1.0.3 正文创建组件的几种方式现成轮子直接用 官方仓库搜索 https://pub.dev/flutter/packages https://pub.flutter-io.cn/flutter/packages 可参考的组件代码 通过仓库，查找 github 代码仓 网站、客服索取代码 参考官方集成文档编写组件 官网文档 http://lbsyun.baidu.com/index.php?title=flutter/loc 组件代码百度应用管理，创建 AK 应用管理 https://lbsyun.baidu.com/apiconsole/key#/home 查询 SHA1 http://lbsyun.baidu.com/index.php?title=FAQ/SHA1 1keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey 设置 AK example/android/app/src/main/AndroidManifest.xml 12345678910... &lt;!-- 在这里设置android端ak--&gt; &lt;meta-data android:name=\"com.baidu.lbsapi.API_KEY\" android:value=\"aCUtcLDufllGi4nEaKgU8FmBqufFyekh\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 设置 Android 权限 文档 http://lbsyun.baidu.com/index.php?title=android-locsdk/guide/create-project/android-studio android/src/main/AndroidManifest.xml 1234567891011121314151617181920212223242526272829303132&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"tech.ducafecat.flutter_baidu_plugin_ducafecat\"&gt; &lt;!-- 这个权限用于进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"&gt;&lt;/uses-permission&gt; &lt;!-- 这个权限用于访问GPS定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"&gt;&lt;/uses-permission&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"&gt;&lt;/uses-permission&gt; &lt;!-- 获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"&gt;&lt;/uses-permission&gt; &lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"&gt;&lt;/uses-permission&gt; &lt;!-- 用于读取手机当前的状态--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt; &lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; &lt;!-- 访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;!-- 读取系统信息，包含系统版本等信息，用作统计--&gt; &lt;uses-permission android:name=\"com.android.launcher.permission.READ_SETTINGS\" /&gt; &lt;!-- 程序在手机屏幕关闭后后台进程仍然运行--&gt; &lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; &lt;application&gt; &lt;!-- 声明service组件 --&gt; &lt;service android:name=\"com.baidu.location.f\" android:enabled=\"true\" android:process=\":remote\" &gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 添加 android libs 库文件 目录 android/libs android/build.gradle 123456789101112131415161718192021...android &#123; compileSdkVersion 28 sourceSets &#123; main &#123; jniLibs.srcDir 'libs' &#125; &#125; defaultConfig &#123; minSdkVersion 16 &#125; lintOptions &#123; disable 'InvalidPackage' &#125;&#125;dependencies &#123; implementation files('libs/BaiduLBS_Android.jar')&#125; 编写 Flutter 组件代码 目录 lib 地理信息 lib/entity/flutter_baidu_location.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/// 百度定位结果类，用于存储各类定位结果信息class BaiduLocation &#123; /// 定位成功时间 final String locTime; /// 定位结果类型 final int locType; /// 半径 final double radius; /// 纬度 final double latitude; /// 经度 final double longitude; /// 海拔 final double altitude; /// 国家 final String country; /// 省份 final String province; /// 城市 final String city; /// 区县 final String district; /// 街道 final String street; /// 地址 final String address; /// 位置语义化描述，例如\"在百度大厦附近\" final String locationDetail; /// 周边poi信息，每个poi之间用\"|\"隔开 final String poiList; /// 定位结果回调时间 final String callbackTime; /// 错误码 final int errorCode; /// 定位失败描述信息 final String errorInfo; BaiduLocation( &#123;this.locTime, this.locType, this.radius, this.latitude, this.longitude, this.altitude, this.country, this.province, this.city, this.district, this.street, this.address, this.locationDetail, this.poiList, this.callbackTime, this.errorCode, this.errorInfo&#125;); /// 根据传入的map生成BaiduLocation对象 factory BaiduLocation.fromMap(dynamic value) &#123; return new BaiduLocation( locTime: value['locTime'], locType: value['locType'], radius: value['radius'], latitude: value['latitude'], longitude: value['longitude'], altitude: value['altitude'], country: value['country'], province: value['province'], city: value['city'], district: value['district'], street: value['street'], address: value['address'], locationDetail: value['locationDetail'], poiList: value['poiList'], callbackTime: value['callbackTime'], errorCode: value['errorCode'], errorInfo: value['errorInfo'], ); &#125; /// 获取对本类所有变量赋值后的map键值对 Map getMap() &#123; return &#123; \"locTime\": locTime, \"locType\": locType, \"radius\": radius, \"latitude\": latitude, \"longitude\": longitude, \"altitude\": altitude, \"country\": country, \"province\": province, \"city\": city, \"district\": district, \"street\": street, \"address\": address, \"locationDescribe\": locationDetail, \"poiList\": poiList, \"callbackTime\": callbackTime, \"errorCode\": errorCode, \"errorInfo\": errorInfo, &#125;; &#125;&#125; android 配置项 lib/entity/flutter_baidu_location_android_option.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/// 设置android端定位参数类class BaiduLocationAndroidOption &#123; /// 坐标系类型 String coorType; /// 是否需要返回地址信息 bool isNeedAddres; /// 是否需要返回海拔高度信息 bool isNeedAltitude; /// 是否需要返回周边poi信息 bool isNeedLocationPoiList; /// 是否需要返回新版本rgc信息 bool isNeedNewVersionRgc; /// 是否需要返回位置描述信息 bool isNeedLocationDescribe; /// 是否使用gps bool openGps; /// 可选，设置发起定位请求的间隔，int类型，单位ms /// 如果设置为0，则代表单次定位，即仅定位一次，默认为0 /// 如果设置非0，需设置1000ms以上才有效 int scanspan; /// 设置定位模式，可选的模式有高精度、仅设备、仅网络。默认为高精度模式 int locationMode; /// 可选，设置场景定位参数，包括签到场景、运动场景、出行场景 int locationPurpose; /// 可选，设置返回经纬度坐标类型，默认GCJ02 /// GCJ02：国测局坐标； /// BD09ll：百度经纬度坐标； /// BD09：百度墨卡托坐标； /// 海外地区定位，无需设置坐标类型，统一返回WGS84类型坐标 void setCoorType(String coorType) &#123; this.coorType = coorType; &#125; /// 是否需要返回地址信息 void setIsNeedAddres(bool isNeedAddres) &#123; this.isNeedAddres = isNeedAddres; &#125; /// 是否需要返回海拔高度信息 void setIsNeedAltitude(bool isNeedAltitude) &#123; this.isNeedAltitude = isNeedAltitude; &#125; /// 是否需要返回周边poi信息 void setIsNeedLocationPoiList(bool isNeedLocationPoiList) &#123; this.isNeedLocationPoiList = isNeedLocationPoiList; &#125; /// 是否需要返回位置描述信息 void setIsNeedLocationDescribe(bool isNeedLocationDescribe) &#123; this.isNeedLocationDescribe = isNeedLocationDescribe; &#125; /// 是否需要返回新版本rgc信息 void setIsNeedNewVersionRgc(bool isNeedNewVersionRgc) &#123; this.isNeedNewVersionRgc = isNeedNewVersionRgc; &#125; /// 是否使用gps void setOpenGps(bool openGps) &#123; this.openGps = openGps; &#125; /// 可选，设置发起定位请求的间隔，int类型，单位ms /// 如果设置为0，则代表单次定位，即仅定位一次，默认为0 /// 如果设置非0，需设置1000ms以上才有效 void setScanspan(int scanspan) &#123; this.scanspan = scanspan; &#125; /// 设置定位模式，可选的模式有高精度、仅设备、仅网络，默认为高精度模式 void setLocationMode(LocationMode locationMode) &#123; if (locationMode == LocationMode.Hight_Accuracy) &#123; this.locationMode = 1; &#125; else if (locationMode == LocationMode.Device_Sensors) &#123; this.locationMode = 2; &#125; else if (locationMode == LocationMode.Battery_Saving) &#123; this.locationMode = 3; &#125; &#125; /// 可选，设置场景定位参数，包括签到场景、运动场景、出行场景 void setLocationPurpose(BDLocationPurpose locationPurpose) &#123; if (locationPurpose == BDLocationPurpose.SignIn) &#123; this.locationPurpose = 1; &#125; else if (locationPurpose == BDLocationPurpose.Transport) &#123; this.locationPurpose = 2; &#125; else if (locationPurpose == BDLocationPurpose.Sport) &#123; this.locationPurpose = 3; &#125; &#125; BaiduLocationAndroidOption( &#123;this.coorType, this.isNeedAddres, this.isNeedAltitude, this.isNeedLocationPoiList, this.isNeedNewVersionRgc, this.openGps, this.isNeedLocationDescribe, this.scanspan, this.locationMode, this.locationPurpose&#125;); /// 根据传入的map生成BaiduLocationAndroidOption对象 factory BaiduLocationAndroidOption.fromMap(dynamic value) &#123; return new BaiduLocationAndroidOption( coorType: value['coorType'], isNeedAddres: value['isNeedAddres'], isNeedAltitude: value['isNeedAltitude'], isNeedLocationPoiList: value['isNeedLocationPoiList'], isNeedNewVersionRgc: value['isNeedNewVersionRgc'], openGps: value['openGps'], isNeedLocationDescribe: value[''], scanspan: value['scanspan'], locationMode: value['locationMode'], locationPurpose: value['LocationPurpose'], ); &#125; /// 获取对本类所有变量赋值后的map键值对 Map getMap() &#123; return &#123; \"coorType\": coorType, \"isNeedAddres\": isNeedAddres, \"isNeedAltitude\": isNeedAltitude, \"isNeedLocationPoiList\": isNeedLocationPoiList, \"isNeedNewVersionRgc\": isNeedNewVersionRgc, \"openGps\": openGps, \"isNeedLocationDescribe\": isNeedLocationDescribe, \"scanspan\": scanspan, \"locationMode\": locationMode, &#125;; &#125;&#125;/// 定位模式枚举类enum LocationMode &#123; /// 高精度模式 Hight_Accuracy, /// 低功耗模式 Battery_Saving, /// 仅设备(Gps)模式 Device_Sensors&#125;/// 场景定位枚举类enum BDLocationPurpose &#123; /// 签到场景 /// 只进行一次定位返回最接近真实位置的定位结果（定位速度可能会延迟1-3s） SignIn, /// 出行场景 /// 高精度连续定位，适用于有户内外切换的场景，卫星定位和网络定位相互切换，卫星定位成功之后网络定位不再返回，卫星信号断开之后一段时间才会返回网络结果 Sport, /// 运动场景 /// 高精度连续定位，适用于有户内外切换的场景，卫星定位和网络定位相互切换，卫星定位成功之后网络定位不再返回，卫星信号断开之后一段时间才会返回网络结果 Transport&#125; ios 配置项 lib/entity/flutter_baidu_location_ios_option.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/// 设置ios端定位参数类class BaiduLocationIOSOption &#123; /// 设置位置获取超时时间 int locationTimeout; /// 设置获取地址信息超时时间 int reGeocodeTimeout; /// 设置应用位置类型 String activityType; /// 设置返回位置的坐标系类型 String BMKLocationCoordinateType; /// 设置预期精度参数 String desiredAccuracy; /// 是否需要最新版本rgc数据 bool isNeedNewVersionRgc; /// 指定定位是否会被系统自动暂停 bool pausesLocationUpdatesAutomatically; /// 指定是否允许后台定位 bool allowsBackgroundLocationUpdates; /// 设定定位的最小更新距离 double distanceFilter; /// 指定是否允许后台定位 /// allowsBackgroundLocationUpdates为true则允许后台定位 /// allowsBackgroundLocationUpdates为false则不允许后台定位 void setAllowsBackgroundLocationUpdates( bool allowsBackgroundLocationUpdates) &#123; this.allowsBackgroundLocationUpdates = allowsBackgroundLocationUpdates; &#125; /// 指定定位是否会被系统自动暂停 /// pausesLocationUpdatesAutomatically为true则定位会被系统自动暂停 /// pausesLocationUpdatesAutomatically为false则定位不会被系统自动暂停 void setPauseLocUpdateAutomatically(bool pausesLocationUpdatesAutomatically) &#123; this.pausesLocationUpdatesAutomatically = pausesLocationUpdatesAutomatically; &#125; /// 设置位置获取超时时间 void setLocationTimeout(int locationTimeout) &#123; this.locationTimeout = locationTimeout; &#125; /// 设置获取地址信息超时时间 void setReGeocodeTimeout(int reGeocodeTimeout) &#123; this.reGeocodeTimeout = reGeocodeTimeout; &#125; /// 设置应用位置类型 /// activityType可选值包括: /// \"CLActivityTypeOther\" /// \"CLActivityTypeAutomotiveNavigation\" /// \"CLActivityTypeFitness\" /// \"CLActivityTypeOtherNavigation\" void setActivityType(String activityType) &#123; this.activityType = activityType; &#125; /// 设置返回位置的坐标系类型 /// BMKLocationCoordinateType可选值包括: /// \"BMKLocationCoordinateTypeBMK09LL\" /// \"BMKLocationCoordinateTypeBMK09MC\" /// \"BMKLocationCoordinateTypeWGS84\" /// \"BMKLocationCoordinateTypeGCJ02\" void setBMKLocationCoordinateType(String BMKLocationCoordinateType) &#123; this.BMKLocationCoordinateType = BMKLocationCoordinateType; &#125; /// 设置预期精度参数 /// desiredAccuracy可选值包括: /// \"kCLLocationAccuracyBest\" /// \"kCLLocationAccuracyNearestTenMeters\" /// \"kCLLocationAccuracyHundredMeters\" /// \"kCLLocationAccuracyKilometer\" void setDesiredAccuracy(String desiredAccuracy) &#123; this.desiredAccuracy = desiredAccuracy; &#125; /// 设定定位的最小更新距离 void setDistanceFilter(double distanceFilter) &#123; this.distanceFilter = distanceFilter; &#125; /// 是否需要最新版本rgc数据 /// isNeedNewVersionRgc为true则需要返回最新版本rgc数据 /// isNeedNewVersionRgc为false则不需要返回最新版本rgc数据 void setIsNeedNewVersionRgc(bool isNeedNewVersionRgc) &#123; this.isNeedNewVersionRgc = isNeedNewVersionRgc; &#125; BaiduLocationIOSOption( &#123;this.locationTimeout, this.reGeocodeTimeout, this.activityType, this.BMKLocationCoordinateType, this.desiredAccuracy, this.isNeedNewVersionRgc, this.pausesLocationUpdatesAutomatically, this.allowsBackgroundLocationUpdates, this.distanceFilter&#125;); /// 根据传入的map生成BaiduLocationIOSOption对象 factory BaiduLocationIOSOption.fromMap(dynamic value) &#123; return new BaiduLocationIOSOption( locationTimeout: value['locationTimeout'], reGeocodeTimeout: value['reGeocodeTimeout'], activityType: value['activityType'], BMKLocationCoordinateType: value['BMKLocationCoordinateType'], desiredAccuracy: value['desiredAccuracy'], isNeedNewVersionRgc: value['isNeedNewVersionRgc'], pausesLocationUpdatesAutomatically: value['pausesLocationUpdatesAutomatically'], allowsBackgroundLocationUpdates: value['allowsBackgroundLocationUpdates'], distanceFilter: value['distanceFilter'], ); &#125; /// 获取对本类所有变量赋值后的map键值对 Map getMap() &#123; return &#123; \"locationTimeout\": locationTimeout, \"reGeocodeTimeout\": reGeocodeTimeout, \"activityType\": activityType, \"BMKLocationCoordinateType\": BMKLocationCoordinateType, \"desiredAccuracy\": desiredAccuracy, \"isNeedNewVersionRgc\": isNeedNewVersionRgc, \"pausesLocationUpdatesAutomatically\": pausesLocationUpdatesAutomatically, \"allowsBackgroundLocationUpdates\": allowsBackgroundLocationUpdates, \"distanceFilter\": distanceFilter, &#125;; &#125;&#125; 接口 lib/flutter_baidu_plugin_ducafecat.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import 'dart:async';import 'dart:io';import 'package:flutter/services.dart';class FlutterBaiduPluginDucafecat &#123; /// flutter端主动调用原生端方法 static const MethodChannel _channel = const MethodChannel('flutter_baidu_plugin_ducafecat'); /// 原生端主动回传结果数据到flutter端 static const EventChannel _stream = const EventChannel(\"flutter_baidu_plugin_ducafecat_stream\"); /// ios 下设置 key /// android 在 AndroidManifest.xml 中设置 static Future&lt;bool&gt; setApiKey(String key) async &#123; return await _channel.invokeMethod(\"setApiKey\", key); &#125; /// 设置定位参数 void prepareLoc(Map androidMap, Map iosMap) &#123; Map map; if (Platform.isAndroid) &#123; map = androidMap; &#125; else &#123; map = iosMap; &#125; _channel.invokeMethod(\"updateOption\", map); return; &#125; /// 启动定位 void startLocation() &#123; _channel.invokeMethod('startLocation'); return; &#125; /// 停止定位 void stopLocation() &#123; _channel.invokeMethod('stopLocation'); return; &#125; /// 原生端回传键值对map到flutter端 /// map中key为isInChina对应的value，如果为1则判断是在国内，为0则判断是在国外 /// map中存在key为nearby则判断为已到达设置监听位置附近 Stream&lt;Map&lt;String, Object&gt;&gt; onResultCallback() &#123; Stream&lt;Map&lt;String, Object&gt;&gt; _resultMap; if (_resultMap == null) &#123; _resultMap = _stream.receiveBroadcastStream().map&lt;Map&lt;String, Object&gt;&gt;( (element) =&gt; element.cast&lt;String, Object&gt;()); &#125; return _resultMap; &#125;&#125; 触发 registerWith 的方式，老项目 // This static function is optional and equivalent to onAttachedToEngine. It supports the old// pre-Flutter-1.12 Android projects. You are encouraged to continue supporting// plugin registration via this function while apps migrate to use the new Android APIs// post-flutter-1.12 via https://flutter.dev/go/android-project-migration. android 组件代码 android/src/main/java/tech/ducafecat/flutter_baidu_plugin_ducafecat/FlutterBaiduPluginDucafecatPlugin.java 123public static void registerWith(Registrar registrar) &#123; ......&#125; example android 注册组件 example/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java 123456789101112131415161718public final class GeneratedPluginRegistrant &#123; public static void registerWith(PluginRegistry registry) &#123; if (alreadyRegisteredWith(registry)) &#123; return; &#125; LocationFlutterPlugin.registerWith(registry.registrarFor(\"com.baidu.bdmap_location_flutter_plugin.LocationFlutterPlugin\")); PermissionHandlerPlugin.registerWith(registry.registrarFor(\"com.baseflow.permissionhandler.PermissionHandlerPlugin\")); &#125; private static boolean alreadyRegisteredWith(PluginRegistry registry) &#123; final String key = GeneratedPluginRegistrant.class.getCanonicalName(); if (registry.hasPlugin(key)) &#123; return true; &#125; registry.registrarFor(key); return false; &#125;&#125; 成员变量、同步、异步处理MethodChannel 请求方法后，同步返回结果 EventChannel 组件主动推消息到 Flutter android/src/main/java/tech/ducafecat/flutter_baidu_plugin_ducafecat/FlutterBaiduPluginDucafecatPlugin.java 用到的成员变量先定义下 123456789101112131415161718public class FlutterBaiduPluginDucafecatPlugin implements FlutterPlugin, MethodCallHandler, EventChannel.StreamHandler &#123; // 通道名称 private static final String CHANNEL_METHOD_LOCATION = \"flutter_baidu_plugin_ducafecat\"; private static final String CHANNEL_STREAM_LOCATION = \"flutter_baidu_plugin_ducafecat_stream\"; private Context mContext = null; // flutter view context private LocationClient mLocationClient = null; // 定位对象 private EventChannel.EventSink mEventSink = null; // 事件对象 private BDNotifyListener mNotifyListener; // 位置提醒对象 private boolean isPurporseLoc = false; // 签到场景 private boolean isInChina = false; // 是否启用国内外位置判断功能 private boolean isNotify = false; // 位置提醒 // 通道对象 private MethodChannel channel = null; private EventChannel eventChannel = null; 组件生命周期 文件 android/src/main/java/tech/ducafecat/flutter_baidu_plugin_ducafecat/FlutterBaiduPluginDucafecatPlugin.java 组件注册 onAttachedToEngine 1234567891011121314151617@Overridepublic void onAttachedToEngine(@NonNull FlutterPluginBinding flutterPluginBinding) &#123; this.mContext = flutterPluginBinding.getApplicationContext(); /** * 开始、停止定位 */ channel = new MethodChannel(flutterPluginBinding.getBinaryMessenger(), CHANNEL_METHOD_LOCATION); channel.setMethodCallHandler(this); /** * 监听位置变化 */ eventChannel = new EventChannel(flutterPluginBinding.getBinaryMessenger(), CHANNEL_STREAM_LOCATION); eventChannel.setStreamHandler(this);&#125; 老项目 组件注册 registerWith 1234567891011121314151617181920 public static void registerWith(Registrar registrar) &#123; FlutterBaiduPluginDucafecatPlugin plugin = new FlutterBaiduPluginDucafecatPlugin(); plugin.mContext = registrar.context(); /** * 开始、停止定位 */ final MethodChannel channel = new MethodChannel(registrar.messenger(), CHANNEL_METHOD_LOCATION); channel.setMethodCallHandler(plugin); /** * 监听位置变化 */ final EventChannel eventChannel = new EventChannel(registrar.messenger(), CHANNEL_STREAM_LOCATION); eventChannel.setStreamHandler(plugin);// final MethodChannel channel = new MethodChannel(registrar.messenger(), \"flutter_baidu_plugin_ducafecat\");// channel.setMethodCallHandler(new FlutterBaiduPluginDucafecatPlugin()); &#125; 注销组件 onCancel 12345678910@Overridepublic void onCancel(Object arguments) &#123; stopLocation(); if (isNotify) &#123; if (null != mLocationClient) &#123; mLocationClient.removeNotifyEvent(mNotifyListener); &#125; mNotifyListener = null; &#125;&#125; 销毁组件 onDetachedFromEngine 12345@Overridepublic void onDetachedFromEngine(@NonNull FlutterPluginBinding binding) &#123; channel.setMethodCallHandler(null); eventChannel.setStreamHandler(null);&#125; 方法调用 onMethodCall 123456789101112131415161718@Overridepublic void onMethodCall(@NonNull MethodCall call, @NonNull Result result) &#123; if (\"startLocation\".equals(call.method)) &#123; startLocation(); // 启动定位 &#125; else if (\"stopLocation\".equals(call.method)) &#123; stopLocation(); // 停止定位 &#125; else if(\"updateOption\".equals(call.method)) &#123; // 设置定位参数 try &#123; updateOption((Map) call.arguments); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else if ((\"getPlatformVersion\").equals(call.method)) &#123; result.success(\"Android \" + android.os.Build.VERSION.RELEASE); &#125; else &#123; result.notImplemented(); &#125;&#125; flutter onListen 回调对象 1234@Overridepublic void onListen(Object arguments, EventChannel.EventSink events) &#123; mEventSink = events;&#125; 地图业务参数 更新参数 updateOption 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 准备定位 * @param arguments */private void updateOption(Map arguments) &#123; if (null == mLocationClient) &#123; mLocationClient = new LocationClient(mContext); &#125; // 判断是否启用位置提醒功能 if (arguments.containsKey(\"isNotify\")) &#123; isNotify = true; if (null == mNotifyListener) &#123; mNotifyListener = new MyNotifyLister(); &#125; mLocationClient.registerNotify(mNotifyListener); double lat = 0; double lon = 0; float radius = 0; if (arguments.containsKey(\"latitude\")) &#123; lat = (double)arguments.get(\"latitude\"); &#125; if (arguments.containsKey(\"longitude\")) &#123; lon = (double)arguments.get(\"longitude\"); &#125; if (arguments.containsKey(\"radius\")) &#123; double radius1 = (double)arguments.get(\"radius\"); radius = Float.parseFloat(String.valueOf(radius1)); &#125; String coorType = mLocationClient.getLocOption().getCoorType(); mNotifyListener.SetNotifyLocation(lat, lon, radius, coorType); return; &#125; else &#123; isNotify = false; &#125; mLocationClient.registerLocationListener(new CurrentLocationListener()); // 判断是否启用国内外位置判断功能 if (arguments.containsKey(\"isInChina\")) &#123; isInChina = true; return; &#125; else &#123; isInChina =false; &#125; LocationClientOption option = new LocationClientOption(); parseOptions(option, arguments); option.setProdName(\"flutter\"); mLocationClient.setLocOption(option);&#125; 解析定位参数 parseOptions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 解析定位参数 * @param option * @param arguments */private void parseOptions(LocationClientOption option,Map arguments) &#123; if (arguments != null) &#123; // 可选，设置是否返回逆地理地址信息。默认是true if (arguments.containsKey(\"isNeedAddres\")) &#123; if (((boolean)arguments.get(\"isNeedAddres\"))) &#123; option.setIsNeedAddress(true); &#125; else &#123; option.setIsNeedAddress(false); &#125; &#125; // 可选，设置定位模式，可选的模式有高精度、仅设备、仅网络。默认为高精度模式 if (arguments.containsKey(\"locationMode\")) &#123; if (((int)arguments.get(\"locationMode\")) == 1) &#123; option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy); // 高精度模式 &#125; else if (((int)arguments.get(\"locationMode\")) == 2) &#123; option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); // 仅设备模式 &#125; else if (((int)arguments.get(\"locationMode\")) == 3) &#123; option.setLocationMode(LocationClientOption.LocationMode.Battery_Saving); // 仅网络模式 &#125; &#125; // 可选，设置场景定位参数，包括签到场景、运动场景、出行场景 if ((arguments.containsKey(\"LocationPurpose\"))) &#123; isPurporseLoc = true; if (((int)arguments.get(\"LocationPurpose\")) == 1) &#123; option.setLocationPurpose(LocationClientOption.BDLocationPurpose.SignIn); // 签到场景 &#125; else if (((int)arguments.get(\"LocationPurpose\")) == 2) &#123; option.setLocationPurpose(LocationClientOption.BDLocationPurpose.Transport); // 运动场景 &#125; else if (((int)arguments.get(\"LocationPurpose\")) == 3) &#123; option.setLocationPurpose(LocationClientOption.BDLocationPurpose.Sport); // 出行场景 &#125; &#125; else &#123; isPurporseLoc = false; &#125; // 可选，设置需要返回海拔高度信息 if (arguments.containsKey(\"isNeedAltitude\")) &#123; if (((boolean)arguments.get(\"isNeedAltitude\"))) &#123; option.setIsNeedAddress(true); &#125; else &#123; option.setIsNeedAltitude(false); &#125; &#125; // 可选，设置是否使用gps，默认false if (arguments.containsKey(\"openGps\")) &#123; if(((boolean)arguments.get(\"openGps\"))) &#123; option.setOpenGps(true); &#125; else &#123; option.setOpenGps(false); &#125; &#125; // 可选，设置是否允许返回逆地理地址信息，默认是true if (arguments.containsKey(\"isNeedLocationDescribe\")) &#123; if(((boolean)arguments.get(\"isNeedLocationDescribe\"))) &#123; option.setIsNeedLocationDescribe(true); &#125; else &#123; option.setIsNeedLocationDescribe(false); &#125; &#125; // 可选，设置发起定位请求的间隔，int类型，单位ms // 如果设置为0，则代表单次定位，即仅定位一次，默认为0 // 如果设置非0，需设置1000ms以上才有效 if (arguments.containsKey(\"scanspan\")) &#123; option.setScanSpan((int)arguments.get(\"scanspan\")); &#125; // 可选，设置返回经纬度坐标类型，默认GCJ02 // GCJ02：国测局坐标； // BD09ll：百度经纬度坐标； // BD09：百度墨卡托坐标； // 海外地区定位，无需设置坐标类型，统一返回WGS84类型坐标 if (arguments.containsKey(\"coorType\")) &#123; option.setCoorType((String)arguments.get(\"coorType\")); &#125; // 设置是否需要返回附近的poi列表 if (arguments.containsKey(\"isNeedLocationPoiList\")) &#123; if (((boolean)arguments.get(\"isNeedLocationPoiList\"))) &#123; option.setIsNeedLocationPoiList(true); &#125; else &#123; option.setIsNeedLocationPoiList(false); &#125; &#125; // 设置是否需要最新版本rgc数据 if (arguments.containsKey(\"isNeedNewVersionRgc\")) &#123; if (((boolean)arguments.get(\"isNeedNewVersionRgc\"))) &#123; option.setIsNeedLocationPoiList(true); &#125; else &#123; option.setIsNeedLocationPoiList(false); &#125; &#125; &#125;&#125; 编写启动、停止功能 开始定位 123456private void startLocation() &#123; if(null != mLocationClient) &#123; mLocationClient.start(); &#125;&#125; 停止定位 1234567private void stopLocation() &#123; if (null != mLocationClient) &#123; mLocationClient.stop(); mLocationClient = null; &#125;&#125; 百度定位回调 CurrentLocationListener 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 /** * 格式化时间 * * @param time * @param strPattern * @return */ private String formatUTC(long time, String strPattern) &#123; if (TextUtils.isEmpty(strPattern)) &#123; strPattern = \"yyyy-MM-dd HH:mm:ss\"; &#125; SimpleDateFormat sdf = null; try &#123; sdf = new SimpleDateFormat(strPattern, Locale.CHINA); sdf.applyPattern(strPattern); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return sdf == null ? \"NULL\" : sdf.format(time); &#125; class CurrentLocationListener extends BDAbstractLocationListener &#123; @Override public void onReceiveLocation(BDLocation bdLocation) &#123; if (null == mEventSink) &#123; return; &#125; Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;(); // 判断国内外获取结果 if (isInChina) &#123; if (bdLocation.getLocationWhere() == BDLocation.LOCATION_WHERE_IN_CN) &#123; result.put(\"isInChina\", 1); // 在国内 &#125; else &#123; result.put(\"isInChina\", 0); // 在国外 &#125; mEventSink.success(result); return; &#125; // 场景定位获取结果 if (isPurporseLoc) &#123; result.put(\"latitude\", bdLocation.getLatitude()); // 纬度 result.put(\"longitude\", bdLocation.getLongitude()); // 经度 mEventSink.success(result); return; &#125; result.put(\"callbackTime\", formatUTC(System.currentTimeMillis(), \"yyyy-MM-dd HH:mm:ss\")); if (null != bdLocation) &#123; if (bdLocation.getLocType() == BDLocation.TypeGpsLocation || bdLocation.getLocType() == BDLocation.TypeNetWorkLocation || bdLocation.getLocType() == BDLocation.TypeOffLineLocation) &#123; result.put(\"locType\", bdLocation.getLocType()); // 定位结果类型 result.put(\"locTime\", bdLocation.getTime()); // 定位成功时间 result.put(\"latitude\", bdLocation.getLatitude()); // 纬度 result.put(\"longitude\", bdLocation.getLongitude()); // 经度 if (bdLocation.hasAltitude()) &#123; result.put(\"altitude\", bdLocation.getAltitude()); // 高度 &#125; result.put(\"radius\", Double.parseDouble(String.valueOf(bdLocation.getRadius()))); // 定位精度 result.put(\"country\", bdLocation.getCountry()); // 国家 result.put(\"province\", bdLocation.getProvince()); // 省份 result.put(\"city\", bdLocation.getCity()); // 城市 result.put(\"district\", bdLocation.getDistrict()); // 区域 result.put(\"town\", bdLocation.getTown()); // 城镇 result.put(\"street\", bdLocation.getStreet()); // 街道 result.put(\"address\", bdLocation.getAddrStr()); // 地址 result.put(\"locationDetail\", bdLocation.getLocationDescribe()); // 位置语义化描述 if (null != bdLocation.getPoiList() &amp;&amp; !bdLocation.getPoiList().isEmpty()) &#123; List&lt;Poi&gt; pois = bdLocation.getPoiList(); StringBuilder stringBuilder = new StringBuilder(); if (pois.size() == 1) &#123; stringBuilder.append(pois.get(0).getName()).append(\",\").append(pois.get(0).getTags()) .append(pois.get(0).getAddr()); &#125; else &#123; for (int i = 0; i &lt; pois.size() - 1; i++) &#123; stringBuilder.append(pois.get(i).getName()).append(\",\").append(pois.get(i).getTags()) .append(pois.get(i).getAddr()).append(\"|\"); &#125; stringBuilder.append(pois.get(pois.size()-1).getName()).append(\",\").append(pois.get(pois.size()-1).getTags()) .append(pois.get(pois.size()-1).getAddr()); &#125; result.put(\"poiList\",stringBuilder.toString()); // 周边poi信息// &#125; if (bdLocation.getFloor() != null) &#123; // 当前支持高精度室内定位 String buildingID = bdLocation.getBuildingID();// 百度内部建筑物ID String buildingName = bdLocation.getBuildingName();// 百度内部建筑物缩写 String floor = bdLocation.getFloor();// 室内定位的楼层信息，如 f1,f2,b1,b2 StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(buildingID).append(\"-\").append(buildingName).append(\"-\").append(floor); result.put(\"indoor\", stringBuilder.toString()); // 室内定位结果信息 mLocationClient.startIndoorMode();// 开启室内定位模式（重复调用也没问题），开启后，定位SDK会融合各种定位信息（GPS,WI-FI，蓝牙，传感器等）连续平滑的输出定位结果； &#125; else &#123; mLocationClient.stopIndoorMode(); // 处于室外则关闭室内定位模式 &#125; &#125; else &#123; result.put(\"errorCode\", bdLocation.getLocType()); // 定位结果错误码 result.put(\"errorInfo\", bdLocation.getLocTypeDescription()); // 定位失败描述信息 &#125; &#125; else &#123; result.put(\"errorCode\", -1); result.put(\"errorInfo\", \"location is null\"); &#125; mEventSink.success(result); // android端实时检测位置变化，将位置结果发送到flutter端 &#125; &#125; 位置提醒服务123456789101112public class MyNotifyLister extends BDNotifyListener &#123; // 已到达设置监听位置附近 public void onNotify(BDLocation mlocation, float distance)&#123; if (null == mEventSink) &#123; return; &#125; Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;(); result.put(\"nearby\", \"已到达设置监听位置附近\"); // 1为已经到达 0为未到达 mEventSink.success(result); &#125;&#125; Example 代码动态授权 example/pubspec.yaml 1234567dependencies: flutter: sdk: flutter ... permission_handler: ^5.0.1+1 example/lib/main.dart 12345678910111213141516171819class _MyAppState extends State&lt;MyApp&gt; &#123; @override void initState() &#123; super.initState(); _requestPermission(); // 执行权限请求 &#125; // 动态申请定位权限 Future&lt;bool&gt; _requestPermission() async &#123; Map&lt;Permission, PermissionStatus&gt; statuses = await [ Permission.location, Permission.storage, ].request(); return statuses[Permission.location].isGranted &amp;&amp; statuses[Permission.storage].isGranted; &#125;&#125; 主界面代码 example/lib/main.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import 'dart:io';import 'package:flutter/material.dart';import 'dart:async';import 'package:flutter_baidu_plugin_ducafecat/flutter_baidu_plugin_ducafecat.dart';import 'package:flutter_baidu_plugin_ducafecat_example/views/location-view.dart';import 'package:permission_handler/permission_handler.dart';void main() &#123; runApp(MyApp());&#125;class MyApp extends StatefulWidget &#123; @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; @override void initState() &#123; super.initState(); _requestPermission(); // 执行权限请求 if (Platform.isIOS == true) &#123; FlutterBaiduPluginDucafecat.setApiKeyForIOS( \"dkYT07blcAj3drBbcN1eGFYqt16HP1pR\"); &#125; &#125; @override void dispose() &#123; super.dispose(); &#125; // 动态申请定位权限 Future&lt;bool&gt; _requestPermission() async &#123; Map&lt;Permission, PermissionStatus&gt; statuses = await [ Permission.location, Permission.storage, ].request(); return statuses[Permission.location].isGranted &amp;&amp; statuses[Permission.storage].isGranted; &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( routes: &#123; \"location_view\": (context) =&gt; LocationView(), &#125;, home: MyHome(), ); &#125;&#125;class MyHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text('地图插件')), body: SingleChildScrollView( child: Column( children: [ ListTile( title: Text('定位信息'), subtitle: Text('点击开始后，百度地图实时推送经纬度信息'), leading: Icon(Icons.location_searching), trailing: Icon(Icons.keyboard_arrow_right), onTap: () &#123; Navigator.pushNamed(context, \"location_view\"); &#125;, ) ], ), ), ); &#125;&#125; 定位服务代码 example/lib/views/location-view.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232import 'dart:async';import 'package:flutter/material.dart';import 'package:flutter_baidu_plugin_ducafecat/entity/flutter_baidu_location.dart';import 'package:flutter_baidu_plugin_ducafecat/entity/flutter_baidu_location_android_option.dart';import 'package:flutter_baidu_plugin_ducafecat/entity/flutter_baidu_location_ios_option.dart';import 'package:flutter_baidu_plugin_ducafecat/flutter_baidu_plugin_ducafecat.dart';class LocationView extends StatefulWidget &#123; LocationView(&#123;Key key&#125;) : super(key: key); @override _LocationViewState createState() =&gt; _LocationViewState();&#125;class _LocationViewState extends State&lt;LocationView&gt; &#123; FlutterBaiduPluginDucafecat _locationPlugin = FlutterBaiduPluginDucafecat(); StreamSubscription&lt;Map&lt;String, Object&gt;&gt; _locationListener; // 事件监听 BaiduLocation _baiduLocation; // 经纬度信息 // Map&lt;String, Object&gt; _loationResult; // 返回格式数据 @override void dispose() &#123; super.dispose(); // 取消监听 if (null != _locationListener) &#123; _locationListener.cancel(); &#125; &#125; // 返回定位信息 void _setupListener() &#123; if (_locationListener != null) &#123; return; &#125; _locationListener = _locationPlugin.onResultCallback().listen((Map&lt;String, Object&gt; result) &#123; setState(() &#123; // _loationResult = result; try &#123; _baiduLocation = BaiduLocation.fromMap(result); print(_baiduLocation); &#125; catch (e) &#123; print(e); &#125; &#125;); &#125;); &#125; // 设置android端和ios端定位参数 void _setLocOption() &#123; // android 端设置定位参数 BaiduLocationAndroidOption androidOption = new BaiduLocationAndroidOption(); androidOption.setCoorType(\"bd09ll\"); // 设置返回的位置坐标系类型 androidOption.setIsNeedAltitude(true); // 设置是否需要返回海拔高度信息 androidOption.setIsNeedAddres(true); // 设置是否需要返回地址信息 androidOption.setIsNeedLocationPoiList(true); // 设置是否需要返回周边poi信息 androidOption.setIsNeedNewVersionRgc(true); // 设置是否需要返回最新版本rgc信息 androidOption.setIsNeedLocationDescribe(true); // 设置是否需要返回位置描述 androidOption.setOpenGps(true); // 设置是否需要使用gps androidOption.setLocationMode(LocationMode.Hight_Accuracy); // 设置定位模式 androidOption.setScanspan(1000); // 设置发起定位请求时间间隔 Map androidMap = androidOption.getMap(); // ios 端设置定位参数 BaiduLocationIOSOption iosOption = new BaiduLocationIOSOption(); iosOption.setIsNeedNewVersionRgc(true); // 设置是否需要返回最新版本rgc信息 iosOption.setBMKLocationCoordinateType( \"BMKLocationCoordinateTypeBMK09LL\"); // 设置返回的位置坐标系类型 iosOption.setActivityType(\"CLActivityTypeAutomotiveNavigation\"); // 设置应用位置类型 iosOption.setLocationTimeout(10); // 设置位置获取超时时间 iosOption.setDesiredAccuracy(\"kCLLocationAccuracyBest\"); // 设置预期精度参数 iosOption.setReGeocodeTimeout(10); // 设置获取地址信息超时时间 iosOption.setDistanceFilter(100); // 设置定位最小更新距离 iosOption.setAllowsBackgroundLocationUpdates(true); // 是否允许后台定位 iosOption.setPauseLocUpdateAutomatically(true); // 定位是否会被系统自动暂停 Map iosMap = iosOption.getMap(); _locationPlugin.prepareLoc(androidMap, iosMap); &#125; // 启动定位 void _handleStartLocation() &#123; if (null != _locationPlugin) &#123; _setupListener(); _setLocOption(); _locationPlugin.startLocation(); &#125; &#125; // 停止定位 void _handleStopLocation() &#123; if (null != _locationPlugin) &#123; _locationPlugin.stopLocation(); setState(() &#123; _baiduLocation = null; &#125;); &#125; &#125; //////////////////////////////////////////////////////////// // 显示地理信息 Widget _buildLocationView() &#123; return _baiduLocation != null ? Table( children: [ TableRow(children: [ TableCell(child: Text('经度')), TableCell(child: Text(_baiduLocation.longitude.toString())), ]), TableRow(children: [ TableCell(child: Text('纬度')), TableCell(child: Text(_baiduLocation.latitude.toString())), ]), TableRow(children: [ TableCell(child: Text('国家')), TableCell( child: Text(_baiduLocation.country != null ? _baiduLocation.country : \"\")), ]), TableRow(children: [ TableCell(child: Text('省份')), TableCell( child: Text(_baiduLocation.province != null ? _baiduLocation.province : \"\")), ]), TableRow(children: [ TableCell(child: Text('城市')), TableCell( child: Text(_baiduLocation.city != null ? _baiduLocation.city : \"\")), ]), TableRow(children: [ TableCell(child: Text('区县')), TableCell( child: Text(_baiduLocation.district != null ? _baiduLocation.district : \"\")), ]), TableRow(children: [ TableCell(child: Text('街道')), TableCell( child: Text(_baiduLocation.street != null ? _baiduLocation.street : \"\")), ]), TableRow(children: [ TableCell(child: Text('地址')), TableCell( child: Text(_baiduLocation.address != null ? _baiduLocation.address : \"\")), ]), TableRow(children: [ TableCell(child: Text('位置语义化描述')), TableCell( child: Text(_baiduLocation.locationDetail != null ? _baiduLocation.locationDetail : \"\")), ]), TableRow(children: [ TableCell(child: Text('周边poi信息')), TableCell( child: Text(_baiduLocation.poiList != null ? _baiduLocation.poiList : \"\")), ]), TableRow(children: [ TableCell(child: Text('错误码')), TableCell( child: Text(_baiduLocation.errorCode != null ? _baiduLocation.errorCode.toString() : \"\")), ]), TableRow(children: [ TableCell(child: Text('定位失败描述信息')), TableCell( child: Text(_baiduLocation.errorInfo != null ? _baiduLocation.errorInfo : \"\")), ]), ], ) : Container(); &#125; // 控制面板 Widget _buildControlPlan() &#123; return Row( mainAxisAlignment: MainAxisAlignment.center, children: [ MaterialButton( color: Colors.blue, textColor: Colors.white, onPressed: _baiduLocation == null ? _handleStartLocation : null, child: Text('开始定位'), ), MaterialButton( color: Colors.blue, textColor: Colors.white, onPressed: _baiduLocation != null ? _handleStopLocation : null, child: Text('暂停定位'), ) ], ); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('定位信息'), ), body: SingleChildScrollView( child: Column( children: [ _buildControlPlan(), Divider(), _buildLocationView(), ], ), ), ); &#125;&#125; 参考 https://lbsyun.baidu.com/apiconsole/key#/home http://lbsyun.baidu.com/index.php?title=android-locsdk © 猫哥 https://ducafecat.techhttps://ducafecat.gitee.io","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 混合开发 - 01 编写设备端组件的正确姿势!","date":"2020-07-29T16:00:00.000Z","path":"2020/07/30/flutter-daily/flutter-plugins-01-developing-packages-plugins/","text":"本节目标 闲鱼手册中提到的混合开发 编写到使用一个 flutter 组件的完整过程 视频https://www.bilibili.com/video/bv1iT4y1j72t 代码https://github.com/ducafecat/flutter_baidu_plugin_ducafecat/releases/tag/1.0.1 正文从古至今、移动开发不可回避的问题 flutter、weex、React Native、Cordova 开发模式 聊聊 Flutter in Action 闲鱼最佳实践电子书下载 https://c.tb.cn/I3.ZZpRl 第二代混合技术方案 FlutterBoost 项目开源地址 https://github.com/alibaba/flutter_boost 架构图 Native 层概念 ● Container：Native 容器，平台 Controller，Activity，ViewController● Container Manager：容器的管理者● Adaptor：Flutter 是适配层● Messaging：基于 Channel 的消息通信 Dart 层概念 ● Container：Flutter 用来容纳 Widget 的容器，具体实现为 Navigator 的派生类● Container Manager：Flutter 容器的管理，提供 show，remove 等 Api● Coordinator: 协调器，接受 Messaging 消息，负责调用 Container Manager 的状态管理。● Messaging：基于 Channel 的消息通信 Flutter &amp; FaaS 云端一体化 Flutter 会为以下团队带来较大的收益 Flutter Redux 混合工程下的 Flutter 研发结构 动手写第一个 Flutter 组件创建 flutter 组件工程1$ flutter create --org tech.ducafecat --template=plugin -a java -i objc flutter-baidu-plugin-ducafecat 加入 加法 函数 dart 代码 lib/flutter_baidu_plugin_ducafecat.dart 123456789101112131415161718import 'dart:async';import 'package:flutter/services.dart';class FlutterBaiduPluginDucafecat &#123; static const MethodChannel _channel = const MethodChannel('flutter_baidu_plugin_ducafecat'); static Future&lt;String&gt; get platformVersion async &#123; final String version = await _channel.invokeMethod('getPlatformVersion'); return version; &#125; static Future&lt;int&gt; duAddOne(int num) async &#123; final int val = await _channel.invokeMethod('duAddOne', &#123;\"num\": num&#125;); return val; &#125;&#125; android 代码 android/src/main/java/tech/ducafecat/flutter_baidu_plugin_ducafecat/FlutterBaiduPluginDucafecatPlugin.java 1234567891011121314@Overridepublic void onMethodCall(@NonNull MethodCall call, @NonNull Result result) &#123; if (call.method.equals(\"getPlatformVersion\")) &#123; result.success(\"Android \" + android.os.Build.VERSION.RELEASE); &#125; else if (call.method.equals(\"duAddOne\")) &#123; int val = 100; val += Integer.valueOf(call.argument(\"num\").toString()); result.success(val); &#125; else &#123; result.notImplemented(); &#125;&#125; ios 代码 ios/Classes/FlutterBaiduPluginDucafecatPlugin.m 1234567891011121314151617181920212223242526#import \"FlutterBaiduPluginDucafecatPlugin.h\"@implementation FlutterBaiduPluginDucafecatPlugin+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@\"flutter_baidu_plugin_ducafecat\" binaryMessenger:[registrar messenger]]; FlutterBaiduPluginDucafecatPlugin* instance = [[FlutterBaiduPluginDucafecatPlugin alloc] init]; [registrar addMethodCallDelegate:instance channel:channel];&#125;- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123; if ([@\"getPlatformVersion\" isEqualToString:call.method]) &#123; result([@\"iOS \" stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); &#125; else if ([@\"duAddOne\" isEqualToString:call.method]) &#123; NSInteger val = 100; val += [[call.arguments objectForKey:@\"num\"] intValue]; result([NSNumber numberWithLong:val]); &#125; else &#123; result(FlutterMethodNotImplemented); &#125;&#125;@end 新建工程调用 pubspec.yaml 1234flutter_baidu_plugin_ducafecat: git: url: https://github.com/ducafecat/flutter_baidu_plugin_ducafecat version: ^0.0.1 调用 加法 1234void _incrementCounter() async &#123; _counter = await FlutterBaiduPluginDucafecat.duAddOne(20); setState(() &#123;&#125;);&#125; 参考 https://cordova.apache.org/ https://reactnative.dev/ https://flutter.dev/ https://weex.apache.org/ © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 17 headless strapi centos 发布部署 + jmeter 压测","date":"2020-07-20T16:00:00.000Z","path":"2020/07/21/flutter-project/flutter-project-news-17-strapi-docker-compose-deploy-jmeter/","text":"本节目标 上传代码到生产环境 配置发布环境代码 docker-compose 方式启动项目 jmeter 做基线测试 调优服务器配置 视频https://www.bilibili.com/video/BV15v411q7CK/ strapi 运行环境网盘下载 网盘 链接:https://pan.baidu.com/s/13Ujy2hzXp8tSqxCx_4IhVQ密码:yu82 运行 本节下载 strapi-docker-compose-16.zip 这个文件 需要用 docker-compose 启动账号 admin密码 123456 12345# 启动docker-compose up -d --remove-orphans# 关闭docker-compose down 正文打包上传服务器 服务器配置 考虑到基线压测优化，所以一开始低些 服务器 cpu1 核心 2G 内存 如何配置 centos 服务器 参考我之前的文章 https://ducafecat.tech/2020/05/29/docker/docker-02-windows-vmware-centos-setup/ https://youtu.be/NJIwbs8qmDY 把所有文件 tar、zip 打包后上传 123&gt; yum install -y zip unzip&gt; unzip filename.zip 修改 graphql 配置 文件 ./config/plugins.js 1234567891011module.exports = &#123; // graphql: &#123; endpoint: \"/graphql\", tracing: false, shadowCRUD: true, playgroundAlways: false, depthLimit: 7, amountLimit: 100, &#125;,&#125;; 名称 说明 endpoint 对外路径 tracing 反馈性能报告 shadowCRUD 支持 CRUD 操作 playgroundAlways 显示调试界面 depthLimit 查询深度限制 amountLimit 查询项目个数 参数说明 修改 admin 面板地址 文件 ./config/server.js 1234567module.exports = (&#123; env &#125;) =&gt; (&#123; host: env(\"HOST\", \"0.0.0.0\"), port: env.int(\"PORT\", 1337), admin: &#123; url: \"/dashboard\", &#125;,&#125;); 默认 admin 不安全，可以改成奇怪的路径 dfasdx97s7 这种 strapi build 编译 安装 portainer 12345docker run -d -p 9000:9000 \\ --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ --name portainer-local \\ portainer/portainer 用工具 portainer 进入容器 1&gt; strapi build 修改 docker-compose 命令12345678910...strapi-app: image: strapi/strapi container_name: strapi-app restart: always ports: - 1337:1337 command: strapi start environment: ... jmeter 压第一轮 - 服务器 cpu1 核心 2G 内存 测试工具 https://jmeter.apache.org/download_jmeter.cgi 需要安装 java 运行环境 jre 1.8 测试内容 新闻首页 123post /graphql&#123;&quot;operationName&quot;:&quot;pageIndex&quot;,&quot;variables&quot;:&#123;&#125;,&quot;query&quot;:&quot;query pageIndex &#123;\\n dictCategories(sort: \\&quot;sortNum:desc\\&quot;) &#123;\\n code\\n title\\n &#125;\\n dictChannels(sort: \\&quot;sortNum:desc\\&quot;) &#123;\\n code\\n title\\n icon &#123;\\n url\\n &#125;\\n &#125;\\n busNews(where: &#123;dict_categories: &#123;code: \\&quot;news_hot\\&quot;&#125;&#125;) &#123;\\n title\\n dict_channel &#123;\\n code\\n title\\n icon &#123;\\n url\\n &#125;\\n &#125;\\n dict_categories &#123;\\n code\\n title\\n &#125;\\n author\\n url\\n addtime\\n thumbnail &#123;\\n url\\n &#125;\\n &#125;\\n&#125;\\n&quot;&#125; 测试环境 压测机: 8 核心 32G 本机 macos，发起线程数 1000~2000 官方建议单机数量服务器: 1 核心 2G 虚拟机 centos 服务器信息监控 12345678910111213141516171819202122&gt; toptop - 23:41:47 up 45 min, 2 users, load average: 0.12, 2.10, 2.09Tasks: 160 total, 1 running, 159 sleeping, 0 stopped, 0 zombie%Cpu(s): 2.2 us, 1.2 sy, 0.0 ni, 96.3 id, 0.0 wa, 0.0 hi, 0.2 si, 0.0 stKiB Mem : 1877360 total, 424344 free, 746224 used, 706792 buff/cacheKiB Swap: 6713340 total, 6713340 free, 0 used. 963492 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND31814 root 20 0 2099204 91620 23620 S 3.7 4.9 3:03.04 node 977 root 20 0 820140 47944 14876 S 2.0 2.6 0:40.63 containerd 9 root 20 0 0 0 0 S 0.3 0.0 0:01.84 rcu_sched 445 root 20 0 0 0 0 S 0.3 0.0 0:01.07 xfsaild/dm-0 995 root 20 0 783740 91376 29532 S 0.3 4.9 0:08.46 dockerd 1675 polkitd 20 0 1659672 119912 18932 S 0.3 6.4 2:15.62 mongod31570 root 20 0 633704 38776 15156 S 0.3 2.1 0:13.24 node 1 root 20 0 191036 3940 2572 S 0.0 0.2 0:00.60 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 4 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 6 root 20 0 0 0 0 S 0.0 0.0 0:01.15 ksoftirqd/0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.09 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh ctrl + c 停止 GUI 压测 1000 个请求 10 秒内 命令行 压测 1jmeter -n -t strapi.jmx -l report/result.csv -j report/log.log -e -o report_html jmeter 压第二轮 - 服务器 cpu4 核心 2G 内存 测试环境 压测机: 8 核心 32G 本机 macos，发起线程数 1000~2000服务器: 4 核心 2G 虚拟机 centos 1000 个请求 5 秒内 压测报告 1jmeter -n -t strapi.jmx -l report/result.csv -j report/log.log -e -o report_html strapi 优化线程数 安装 pm2 工具 https://pm2.keymetrics.io/docs/usage/quick-start/ 编写 启动代码 server.js 12const strapi = require(\"strapi\");strapi().start(); 编写 配置文件 strapi.config.js 12345678910module.exports = &#123; apps: [ &#123; name: \"strapi-app\", script: \"./server.js\", instances: 4, exec_mode: \"cluster\", &#125;, ],&#125;; instances 等于你的核心数 修改 docker-compose.yml 123456789101112131415161718 ...strapi-app: image: strapi/strapi container_name: strapi-app restart: always ports: - 1337:1337 # command: strapi build # command: strapi start command: - /bin/bash - -c - | npm install pm2@latest -g cd /srv/app pm2-runtime start strapi.config.js environment: ... jmeter 压第三轮 - 服务器 cpu4 核心 2G 内存 2000 个请求 1 秒内 主要服务器指标 名称 说明 CPU &lt;= 40% 内存 &lt;= 70% 其它主要指标 连接数、本机进出流量、内网带宽、外网带宽 总结 strapi 服务器部署配置 jmetre 基线测试方法、主要指标查看 参考 strapi 插件配置 https://strapi.io/documentation/v3.x/plugins/graphql.html strapi 命令行 https://strapi.io/documentation/v3.x/cli/CLI.html#strapi-new strapi 部署说明 https://strapi.io/documentation/v3.x/admin-panel/deploy.html pm2 安装 https://pm2.keymetrics.io/docs/usage/quick-start/ pm2 配置文件 https://pm2.keymetrics.io/docs/usage/application-declaration/ jmeter https://jmeter.apache.org/download_jmeter.cgi jmeter 分布式 https://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html 资源设计稿蓝湖预览https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 16 headless strapi + graphql 用户注册、登录、异常处理","date":"2020-07-13T16:00:00.000Z","path":"2020/07/14/flutter-project/flutter-project-news-16-strapi-graphql-login-register/","text":"本节目标 编写 mutation 操作，登录、注册 graphql 操作类加入异常处理 视频https://www.bilibili.com/video/BV1vt4y1Q7i3/ 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.16 strapi 运行环境网盘下载 网盘 链接:https://pan.baidu.com/s/13Ujy2hzXp8tSqxCx_4IhVQ密码:yu82 运行 需要用 docker-compose 启动账号 admin密码 123456 12345# 启动docker-compose up -d --remove-orphans# 关闭docker-compose down 正文 调试地址 http://localhost:1337/graphql 注册 graphql mutation 123456789101112131415161718mutation UserRegister($username: String!, $email: String!, $password: String!) &#123; register(input: &#123; username: $username, email: $email, password: $password &#125;) &#123; jwt user &#123; id username email role &#123; id name description type &#125; blocked confirmed &#125; &#125;&#125; variables 12345&#123; \"username\": \"dbuser\", \"email\": \"dbuser@ducafecat.tech\", \"password\": \"12345678\"&#125; 登录 graphql123456789101112131415161718mutation UserLogin($identifier: String!, $password: String!) &#123; login(input: &#123; identifier: $identifier, password: $password &#125;) &#123; jwt user &#123; id username email role &#123; id name description type &#125; blocked confirmed &#125; &#125;&#125; variables 1234&#123; \"identifier\": \"dbuser\", \"password\": \"12345678\"&#125; identifier 可以是 username、email ，都是唯一的 Graphql 请求类加入异常处理 lib/common/utils/graphql_client.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';import 'package:flutter_ducafecat_news/common/widgets/widgets.dart';import 'package:flutter_ducafecat_news/global.dart';import 'package:graphql/client.dart';class GraphqlClientUtil &#123; static OptimisticCache cache = OptimisticCache( dataIdFromObject: typenameDataIdFromObject, ); static client() &#123; HttpLink _httpLink = HttpLink( uri: '$SERVER_STRAPI_GRAPHQL_URL/graphql', ); if (Global.profile?.jwt != null) &#123; final AuthLink _authLink = AuthLink( getToken: () =&gt; 'Bearer $&#123;Global.profile.jwt&#125;', ); final Link _link = _authLink.concat(_httpLink); return GraphQLClient( cache: cache, link: _link, ); &#125; else &#123; return GraphQLClient( cache: cache, link: _httpLink, ); &#125; &#125; /// 错误处理 static _formatException(BuildContext context, OperationException exception) &#123; var statusCode = ''; try &#123; statusCode = exception .graphqlErrors[0]?.extensions[\"exception\"][\"output\"][\"statusCode\"] .toString(); if (statusCode == '') &#123; statusCode = exception.graphqlErrors[0]?.extensions[\"exception\"][\"code\"] .toString(); &#125; &#125; catch (e) &#123;&#125; switch (statusCode) &#123; case '400': // 重新登录 toastInfo(msg: \"错误请求，提交数据错误！\"); break; case '401': // 没有认证 case '403': // 没有授权 toastInfo(msg: \"账号无效、服务没有授权，请重新登录！\"); return goLoginPage(context); // break; default: toastInfo(msg: exception.toString()); &#125; throw exception; &#125; // 查询 static Future query(&#123; @required BuildContext context, @required String schema, Map&lt;String, dynamic&gt; variables, &#125;) async &#123; QueryOptions options = QueryOptions( documentNode: gql(schema), variables: variables, ); QueryResult result = await client().query(options); if (result.hasException) &#123; _formatException(context, result.exception); &#125; return result; &#125; // 操作 static Future mutate(&#123; @required BuildContext context, @required String schema, Map&lt;String, dynamic&gt; variables, &#125;) async &#123; MutationOptions options = MutationOptions( documentNode: gql(schema), variables: variables, ); QueryResult result = await client().mutate(options); if (result.hasException) &#123; _formatException(context, result.exception); &#125; return result; &#125;&#125; 常见错误码: 400 数据提交时间401 需要登录认证403 功能需要授权 Entity 用户 lib/common/entitys/gql_user.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// 用户登录 - requestclass GqlUserLoginRequestEntity &#123; GqlUserLoginRequestEntity(&#123; this.identifier, this.password, &#125;); String identifier; String password; factory GqlUserLoginRequestEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlUserLoginRequestEntity( identifier: json[\"identifier\"], password: json[\"password\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"identifier\": identifier, \"password\": password, &#125;;&#125;// 用户登录 - requestclass GqlUserRegisterRequestEntity &#123; GqlUserRegisterRequestEntity(&#123; this.username, this.email, this.password, &#125;); String username; String email; String password; factory GqlUserRegisterRequestEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlUserRegisterRequestEntity( username: json[\"username\"], email: json[\"email\"], password: json[\"password\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"username\": username, \"email\": email, \"password\": password, &#125;;&#125;//////////////////////////////////////////////////////////////////// 用户登录 - responseclass GqlUserLoginResponseEntity &#123; GqlUserLoginResponseEntity(&#123; this.jwt, this.user, &#125;); String jwt; UserEntity user; factory GqlUserLoginResponseEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlUserLoginResponseEntity( jwt: json[\"jwt\"], user: UserEntity.fromJson(json[\"user\"]), ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"jwt\": jwt, \"user\": user.toJson(), &#125;;&#125;// 注册新用户 - responseclass GqlUserRegisterResponseEntity &#123; GqlUserRegisterResponseEntity(&#123; this.jwt, this.user, &#125;); String jwt; UserEntity user; factory GqlUserRegisterResponseEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlUserRegisterResponseEntity( jwt: json[\"jwt\"], user: UserEntity.fromJson(json[\"user\"]), ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"jwt\": jwt, \"user\": user.toJson(), &#125;;&#125;// 用户class UserEntity &#123; UserEntity(&#123; this.id, this.username, this.email, this.role, this.blocked, this.confirmed, &#125;); String id; String username; String email; RoleEntity role; bool blocked; bool confirmed; factory UserEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; UserEntity( id: json[\"id\"], username: json[\"username\"], email: json[\"email\"], role: RoleEntity.fromJson(json[\"role\"]), blocked: json[\"blocked\"], confirmed: json[\"confirmed\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"id\": id, \"username\": username, \"email\": email, \"role\": role.toJson(), \"blocked\": blocked, \"confirmed\": confirmed, &#125;;&#125;// 角色class RoleEntity &#123; RoleEntity(&#123; this.id, this.name, this.description, this.type, &#125;); String id; String name; String description; String type; factory RoleEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; RoleEntity( id: json[\"id\"], name: json[\"name\"], description: json[\"description\"], type: json[\"type\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"id\": id, \"name\": name, \"description\": description, \"type\": type, &#125;;&#125; API 用户注册、登录 lib/common/apis/gql_user.dart 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/entitys/entitys.dart';import 'package:flutter_ducafecat_news/common/graphql/graphql.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:graphql/client.dart';/// 新闻class GqlUserAPI &#123; /// 登录 static Future&lt;GqlUserLoginResponseEntity&gt; login(&#123; @required BuildContext context, @required GqlUserLoginRequestEntity variables, &#125;) async &#123; QueryResult response = await GraphqlClientUtil.mutate( context: context, schema: GQL_USER_LOGIN, variables: variables.toJson()); return GqlUserLoginResponseEntity.fromJson(response.data[\"login\"]); &#125; /// 注册 static Future&lt;GqlUserRegisterResponseEntity&gt; register(&#123; @required BuildContext context, @required GqlUserRegisterRequestEntity variables, &#125;) async &#123; QueryResult response = await GraphqlClientUtil.mutate( context: context, schema: GQL_USER_REGISTER, variables: variables.toJson()); return GqlUserRegisterResponseEntity.fromJson(response.data[\"register\"]); &#125;&#125; 资源设计稿蓝湖预览https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 15 headless strapi 数据建模 graphql 条件查询排序","date":"2020-07-08T16:00:00.000Z","path":"2020/07/09/flutter-project/flutter-project-news-15-strapi-graphql-data-model/","text":"本节目标 portainer 容器管理工具 数据库设计过程 数据库设计目标、规范、习惯 graphql 条件查询、排序 flutter 代码实现 视频https://www.bilibili.com/video/BV1jD4y1S7Mu/ 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.15 strapi 运行环境网盘下载 网盘 链接:https://pan.baidu.com/s/13Ujy2hzXp8tSqxCx_4IhVQ密码:yu82 文件 名称 说明 strapi-docker-compose-00.zip 干净环境，已安装 graphql 插件 strapi-docker-compose-15.zip 15 课内容 运行 需要用 docker-compose 启动账号 admin密码 123456 12345# 启动docker-compose up -d --remove-orphans# 关闭docker-compose down 工具 https://www.portainer.io https://www.draw.io https://app.quicktype.io 正文安装 portainer https://www.portainer.io 12345docker run -d -p 9000:9000 \\ --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ --name portainer-local \\ portainer/portainer 设计数据模型 https://www.draw.io 标准数据库设计 ER 图 -&gt; 设计范式 -&gt; 数据库物理表 ER 范式 https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96 设计规范 表前缀 sys 系统、用户、权限dict 字典表bus_ 业务 设计数据 对象、属性、关系 创建 strapi 数据类型 创建外键表 新闻分类 创建外键表 新闻频道 创建业务表 新闻内容 创建链接外键 新闻内容、分类、频道 编写 graphql 查询 新闻 12345678910111213141516171819202122query News($category_code: String) &#123; busNews(where: &#123; dict_categories: &#123; code: $category_code &#125; &#125;) &#123; title dict_channel &#123; code title icon &#123; url &#125; &#125; dict_categories &#123; code title &#125; author url addtime thumbnail &#123; url &#125; &#125;&#125; 首页 123456789101112131415161718192021222324252627282930313233343536query pageIndex &#123; # 分类 dictCategories(sort: &quot;sortNum:desc&quot;) &#123; code title &#125; # 频道 dictChannels(sort: &quot;sortNum:desc&quot;) &#123; code title icon &#123; url &#125; &#125; # 热点 busNews(where: &#123; dict_categories: &#123; code: &quot;news_hot&quot; &#125; &#125;) &#123; title dict_channel &#123; code title icon &#123; url &#125; &#125; dict_categories &#123; code title &#125; author url addtime thumbnail &#123; url &#125; &#125;&#125; 编写 flutter 代码 实例 entity lib/common/entitys/gql_news.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// 首页class GqlIndexResponseEntity &#123; GqlIndexResponseEntity(&#123; this.dictCategories, this.dictChannels, this.busNews, &#125;); List&lt;DictCategoryEntity&gt; dictCategories; List&lt;DictChannelEntity&gt; dictChannels; List&lt;GqlNewsResponseEntity&gt; busNews; factory GqlIndexResponseEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlIndexResponseEntity( dictCategories: List&lt;DictCategoryEntity&gt;.from( json[\"dictCategories\"].map((x) =&gt; DictCategoryEntity.fromJson(x))), dictChannels: List&lt;DictChannelEntity&gt;.from( json[\"dictChannels\"].map((x) =&gt; DictChannelEntity.fromJson(x))), busNews: List&lt;GqlNewsResponseEntity&gt;.from( json[\"busNews\"].map((x) =&gt; GqlNewsResponseEntity.fromJson(x))), ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"dictCategories\": List&lt;dynamic&gt;.from(dictCategories.map((x) =&gt; x.toJson())), \"dictChannels\": List&lt;dynamic&gt;.from(dictChannels.map((x) =&gt; x.toJson())), \"busNews\": List&lt;dynamic&gt;.from(busNews.map((x) =&gt; x.toJson())), &#125;;&#125;// 新闻class GqlNewsResponseEntity &#123; GqlNewsResponseEntity(&#123; this.title, this.dictChannel, this.dictCategories, this.author, this.url, this.addtime, this.thumbnail, &#125;); String title; DictChannelEntity dictChannel; List&lt;DictCategoryEntity&gt; dictCategories; String author; String url; DateTime addtime; ThumbnailEntity thumbnail; factory GqlNewsResponseEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlNewsResponseEntity( title: json[\"title\"], dictChannel: DictChannelEntity.fromJson(json[\"dict_channel\"]), dictCategories: List&lt;DictCategoryEntity&gt;.from( json[\"dict_categories\"].map((x) =&gt; DictCategoryEntity.fromJson(x))), author: json[\"author\"], url: json[\"url\"], addtime: DateTime.parse(json[\"addtime\"]), thumbnail: ThumbnailEntity.fromJson(json[\"thumbnail\"]), ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"title\": title, \"dict_channel\": dictChannel.toJson(), \"dict_categories\": List&lt;dynamic&gt;.from(dictCategories.map((x) =&gt; x.toJson())), \"author\": author, \"url\": url, \"addtime\": \"$&#123;addtime.year.toString().padLeft(4, '0')&#125;-$&#123;addtime.month.toString().padLeft(2, '0')&#125;-$&#123;addtime.day.toString().padLeft(2, '0')&#125;\", \"ThumbnailEntity\": thumbnail.toJson(), &#125;;&#125;// 分类class DictCategoryEntity &#123; DictCategoryEntity(&#123; this.code, this.title, &#125;); String code; String title; factory DictCategoryEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; DictCategoryEntity( code: json[\"code\"], title: json[\"title\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"code\": code, \"title\": title, &#125;;&#125;// 频道class DictChannelEntity &#123; DictChannelEntity(&#123; this.code, this.title, this.icon, &#125;); String code; String title; ThumbnailEntity icon; factory DictChannelEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; DictChannelEntity( code: json[\"code\"], title: json[\"title\"], icon: ThumbnailEntity.fromJson(json[\"icon\"]), ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"code\": code, \"title\": title, \"icon\": icon.toJson(), &#125;;&#125;// 图class ThumbnailEntity &#123; ThumbnailEntity(&#123; this.url, &#125;); String url; factory ThumbnailEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; ThumbnailEntity( url: json[\"url\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"url\": url, &#125;;&#125; api lib/common/apis/gql_news.dart 123456789101112131415161718192021222324252627/// 新闻class GqlNewsAPI &#123; /// 首页 static Future&lt;GqlIndexResponseEntity&gt; indexPageInfo(&#123; @required BuildContext context, Map&lt;String, dynamic&gt; params, &#125;) async &#123; QueryResult response = await GraphqlClientUtil.query(context: context, schema: GQL_INDEX_PAGE); return GqlIndexResponseEntity.fromJson(response.data); &#125; /// 翻页 static Future&lt;List&lt;GqlNewsResponseEntity&gt;&gt; newsPageList(&#123; @required BuildContext context, Map&lt;String, dynamic&gt; params, &#125;) async &#123; QueryResult response = await GraphqlClientUtil.query( context: context, schema: GQL_NEWS_LIST, variables: params); return response.data['busNews'] .map&lt;GqlNewsResponseEntity&gt;( (item) =&gt; GqlNewsResponseEntity.fromJson(item)) .toList(); &#125;&#125; 界面业务代码 lib/pages/main/main.dart 123456789101112131415161718192021222324252627GqlIndexResponseEntity _indexPageData; // 首页数据// 读取所有数据_loadAllData() async &#123; _indexPageData = await GqlNewsAPI.indexPageInfo(context: context); ... if (mounted) &#123; setState(() &#123;&#125;); &#125;&#125;// 拉取推荐、新闻_loadNewsData( categoryCode, &#123; bool refresh = false,&#125;) async &#123; _selCategoryCode = categoryCode; _newsPageList = await GqlNewsAPI.newsPageList( context: context, params: &#123;\"category_code\": categoryCode&#125;); if (mounted) &#123; setState(() &#123;&#125;); &#125;&#125;... 详见 git 资源设计稿蓝湖预览https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 14 headless strapi + graphql 快速构建新闻后台","date":"2020-07-02T16:00:00.000Z","path":"2020/07/03/flutter-project/flutter-project-news-14-headless-strapi-graphql/","text":"本节目标 strapi + graphql 插件 + docker 安装 strapi 管理数据结构、内容 flutter + graphql 插件 实现查询 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.14 正文后台开发步骤 采用 strapi + nodejs + 网关 的方案 1. strapi 安装1.1 docker-compose 方式安装 .env 1PASSWORD=123456 docker-compose.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152version: \"3\"services: mongo: image: mongo container_name: mongo restart: always ports: - 27017:27017 environment: - TZ=Asia/Shanghai - MONGO_INITDB_ROOT_USERNAME=root - MONGO_INITDB_ROOT_PASSWORD=$&#123;PASSWORD&#125; volumes: - ./docker-data/mongo:/data/db networks: docker_net: ipv4_address: 172.22.0.11 # starpi # admin / 123456 / admin@ducafecat.tech strapi-app: image: strapi/strapi container_name: strapi-app restart: always ports: - 1337:1337 # command: strapi build # command: strapi start environment: - TZ=Asia/Shanghai - DATABASE_CLIENT=mongo - DATABASE_HOST=mongo - DATABASE_PORT=27017 - DATABASE_NAME=strapi - DATABASE_USERNAME=root - DATABASE_PASSWORD=$&#123;PASSWORD&#125; - DATABASE_AUTHENTICATION_DATABASE=strapi # - NODE_ENV=production depends_on: - mongo volumes: - ./docker-data/strapi-app:/srv/app networks: docker_net: ipv4_address: 172.22.0.12networks: docker_net: driver: bridge ipam: config: - subnet: 172.22.0.0/16 http://localhost:1337/admin 1.2 安装 graphql 插件 2. 构建新闻数据结构2.1 创建数据类型 添加类型 添加字段 字段列表 2.2 调整数据编辑界面 2.3 调整数据列表界面 2.4 维护数据 列表 添加 3. 调试 graphql 请求3.3 graphql 语法 类型 query 查询 mutate 操作 3.4 调试新闻列表http://localhost:1337/graphql 4. 编写 flutter 代码4.1 加入 graphql 插件https://pub.flutter-io.cn/packages/graphql pubspec.yaml 123dependencies: # graphql graphql: ^3.0.2 4.2 封装 graphql client 工具类 lib/common/utils/graphql_client.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';import 'package:flutter_ducafecat_news/common/widgets/widgets.dart';import 'package:graphql/client.dart';class GraphqlClientUtil &#123; static OptimisticCache cache = OptimisticCache( dataIdFromObject: typenameDataIdFromObject, ); static client() &#123; HttpLink _httpLink = HttpLink( uri: '$SERVER_STRAPI_GRAPHQL_URL/graphql', ); // final AuthLink _authLink = AuthLink( // getToken: () =&gt; // 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjVlZmMzNDdhYzgzOTVjMDAwY2ViYzE5NyIsImlhdCI6MTU5MzY1NDcwNiwiZXhwIjoxNTk2MjQ2NzA2fQ.RYDmNSDJxcZLLPHAf4u59IER7Bs5VoWfBo1_t-TR5yY', // ); // final Link _link = _authLink.concat(_httpLink); return GraphQLClient( cache: cache, link: _httpLink, ); &#125; // 查询 static Future query(&#123; @required BuildContext context, @required String schema, Map&lt;String, dynamic&gt; variables, &#125;) async &#123; QueryOptions options = QueryOptions( documentNode: gql(schema), variables: variables, ); QueryResult result = await client().query(options); if (result.hasException) &#123; toastInfo(msg: result.exception.toString()); throw result.exception; &#125; return result; &#125; // 操作 static Future mutate(&#123; @required BuildContext context, @required String schema, Map&lt;String, dynamic&gt; variables, &#125;) async &#123; QueryOptions options = QueryOptions( documentNode: gql(schema), variables: variables, ); QueryResult result = await client().mutate(options); if (result.hasException) &#123; toastInfo(msg: result.exception.toString()); throw result.exception; &#125; return result; &#125;&#125; 4.3 编写 graphql 查询请求 lib/common/graphql/news_content.dart 1234567891011121314const String GQL_NEWS_LIST = r''' query News &#123; newsContents &#123; title category author url addtime thumbnail &#123; url &#125; &#125; &#125;'''; 4.4 编写数据实体lib/common/entitys/gql_news.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class GqlNewsResponseEntity &#123; GqlNewsResponseEntity(&#123; this.id, this.title, this.category, this.author, this.url, this.addtime, this.thumbnail, &#125;); String id; String title; String category; String author; String url; DateTime addtime; Thumbnail thumbnail; factory GqlNewsResponseEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; GqlNewsResponseEntity( id: json[\"id\"], title: json[\"title\"], category: json[\"category\"], author: json[\"author\"], url: json[\"url\"], addtime: DateTime.parse(json[\"addtime\"]), thumbnail: Thumbnail.fromJson(json[\"thumbnail\"]), ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"id\": id, \"title\": title, \"category\": category, \"author\": author, \"url\": url, \"addtime\": \"$&#123;addtime.year.toString().padLeft(4, '0')&#125;-$&#123;addtime.month.toString().padLeft(2, '0')&#125;-$&#123;addtime.day.toString().padLeft(2, '0')&#125;\", \"thumbnail\": thumbnail.toJson(), &#125;;&#125;class Thumbnail &#123; Thumbnail(&#123; this.url, &#125;); String url; factory Thumbnail.fromJson(Map&lt;String, dynamic&gt; json) =&gt; Thumbnail( url: json[\"url\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"url\": url, &#125;;&#125; 4.5 编写 API 访问 lib/common/apis/gql_news.dart 12345678910111213141516171819202122import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/entitys/entitys.dart';import 'package:flutter_ducafecat_news/common/graphql/graphql.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:graphql/client.dart';/// 新闻class GqlNewsAPI &#123; /// 翻页 static Future&lt;List&lt;GqlNewsResponseEntity&gt;&gt; newsPageList(&#123; @required BuildContext context, Map&lt;String, dynamic&gt; params, &#125;) async &#123; QueryResult response = await GraphqlClientUtil.query(context: context, schema: GQL_NEWS_LIST); return response.data['newsContents'] .map&lt;GqlNewsResponseEntity&gt;( (item) =&gt; GqlNewsResponseEntity.fromJson(item)) .toList(); &#125;&#125; 4.6 修改新闻列表页 lib/pages/main/main.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212import 'dart:async';import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/apis/apis.dart';import 'package:flutter_ducafecat_news/common/entitys/entitys.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';import 'package:flutter_ducafecat_news/common/widgets/widgets.dart';import 'package:flutter_ducafecat_news/pages/main/ad_widget.dart';import 'package:flutter_ducafecat_news/pages/main/categories_widget.dart';import 'package:flutter_ducafecat_news/pages/main/channels_widget.dart';import 'package:flutter_ducafecat_news/pages/main/news_item_widget.dart';import 'package:flutter_ducafecat_news/pages/main/newsletter_widget.dart';import 'package:flutter_ducafecat_news/pages/main/recommend_widget.dart';import 'package:flutter_easyrefresh/easy_refresh.dart';class MainPage extends StatefulWidget &#123; MainPage(&#123;Key key&#125;) : super(key: key); @override _MainPageState createState() =&gt; _MainPageState();&#125;class _MainPageState extends State&lt;MainPage&gt; &#123; EasyRefreshController _controller; // EasyRefresh控制器 // NewsPageListResponseEntity _newsPageList; // 新闻翻页 List&lt;GqlNewsResponseEntity&gt; _newsPageList; // 新闻翻页 NewsItem _newsRecommend; // 新闻推荐 List&lt;CategoryResponseEntity&gt; _categories; // 分类 List&lt;ChannelResponseEntity&gt; _channels; // 频道 String _selCategoryCode; // 选中的分类Code @override void initState() &#123; super.initState(); _controller = EasyRefreshController(); _loadAllData(); _loadLatestWithDiskCache(); &#125; // 如果有磁盘缓存，延迟3秒拉取更新档案 _loadLatestWithDiskCache() &#123; if (CACHE_ENABLE == true) &#123; var cacheData = StorageUtil().getJSON(STORAGE_INDEX_NEWS_CACHE_KEY); if (cacheData != null) &#123; Timer(Duration(seconds: 3), () &#123; _controller.callRefresh(); &#125;); &#125; &#125; &#125; // 读取所有数据 _loadAllData() async &#123; _categories = await NewsAPI.categories( context: context, cacheDisk: true, ); _channels = await NewsAPI.channels( context: context, cacheDisk: true, ); // _newsRecommend = await NewsAPI.newsRecommend( // context: context, // cacheDisk: true, // ); // _newsPageList = await NewsAPI.newsPageList( // context: context, // cacheDisk: true, // ); _newsPageList = await GqlNewsAPI.newsPageList( context: context, ); _selCategoryCode = _categories.first.code; if (mounted) &#123; setState(() &#123;&#125;); &#125; &#125; // 拉取推荐、新闻 _loadNewsData( categoryCode, &#123; bool refresh = false, &#125;) async &#123; _selCategoryCode = categoryCode; _newsRecommend = await NewsAPI.newsRecommend( context: context, params: NewsRecommendRequestEntity(categoryCode: categoryCode), refresh: refresh, cacheDisk: true, ); // _newsPageList = await NewsAPI.newsPageList( // context: context, // params: NewsPageListRequestEntity(categoryCode: categoryCode), // refresh: refresh, // cacheDisk: true, // ); _newsPageList = await GqlNewsAPI.newsPageList( context: context, ); if (mounted) &#123; setState(() &#123;&#125;); &#125; &#125; // 分类菜单 Widget _buildCategories() &#123; return _categories == null ? Container() : newsCategoriesWidget( categories: _categories, selCategoryCode: _selCategoryCode, onTap: (CategoryResponseEntity item) &#123; _loadNewsData(item.code); &#125;, ); &#125; // 推荐阅读 Widget _buildRecommend() &#123; return _newsRecommend == null // 数据没到位，可以用骨架图展示 ? Container() : recommendWidget(_newsRecommend); &#125; // 频道 Widget _buildChannels() &#123; return _channels == null ? Container() : newsChannelsWidget( channels: _channels, onTap: (ChannelResponseEntity item) &#123;&#125;, ); &#125; // 新闻列表 Widget _buildNewsList() &#123; return _newsPageList == null ? Container( height: duSetHeight(161 * 5 + 100.0), ) : Column( children: _newsPageList.map((item) &#123; // 新闻行 List&lt;Widget&gt; widgets = &lt;Widget&gt;[ newsItem(item), Divider(height: 1), ]; // 每 5 条 显示广告 int index = _newsPageList.indexOf(item); if (((index + 1) % 5) == 0) &#123; widgets.addAll(&lt;Widget&gt;[ adWidget(), Divider(height: 1), ]); &#125; // 返回 return Column( children: widgets, ); &#125;).toList(), ); &#125; // ad 广告条 // 邮件订阅 Widget _buildEmailSubscribe() &#123; return newsletterWidget(); &#125; @override Widget build(BuildContext context) &#123; return _newsPageList == null ? cardListSkeleton() : EasyRefresh( enableControlFinishRefresh: true, controller: _controller, header: ClassicalHeader(), onRefresh: () async &#123; await _loadNewsData( _selCategoryCode, refresh: true, ); _controller.finishRefresh(); &#125;, child: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildCategories(), Divider(height: 1), _buildRecommend(), Divider(height: 1), _buildChannels(), Divider(height: 1), _buildNewsList(), Divider(height: 1), _buildEmailSubscribe(), ], ), ), ); &#125;&#125; 4.7 修改新闻详情页 lib/pages/main/news_item_widget.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import 'package:auto_route/auto_route.dart';import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/entitys/entitys.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';import 'package:flutter_ducafecat_news/common/widgets/widgets.dart';import 'package:flutter_ducafecat_news/common/router/router.gr.dart';/// 新闻行 ItemWidget newsItem(GqlNewsResponseEntity item) &#123; return Container( height: duSetHeight(161), padding: EdgeInsets.all(duSetWidth(20)), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 图 InkWell( onTap: () &#123; ExtendedNavigator.rootNavigator.pushNamed( Routes.detailsPageRoute, arguments: DetailsPageArguments(item: item), ); &#125;, child: imageCached( '$SERVER_STRAPI_GRAPHQL_URL$&#123;item.thumbnail.url&#125;', width: duSetWidth(121), height: duSetWidth(121), ), ), // 右侧 SizedBox( width: duSetWidth(194), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 作者 Container( margin: EdgeInsets.all(0), child: Text( item.author, style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.thirdElementText, fontSize: duSetFontSize(14), height: 1, ), ), ), // 标题 InkWell( onTap: () &#123; ExtendedNavigator.rootNavigator.pushNamed( Routes.detailsPageRoute, arguments: DetailsPageArguments(item: item), ); &#125;, child: Container( margin: EdgeInsets.only(top: duSetHeight(10)), child: Text( item.title, style: TextStyle( fontFamily: 'Montserrat', fontWeight: FontWeight.w500, color: AppColors.primaryText, fontSize: duSetFontSize(16), height: 1, ), overflow: TextOverflow.clip, maxLines: 3, ), ), ), // Spacer Spacer(), // 一行 3 列 Container( child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ // 分类 ConstrainedBox( constraints: BoxConstraints( maxWidth: duSetWidth(60), ), child: Text( item.category, style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.secondaryElementText, fontSize: duSetFontSize(14), height: 1, ), overflow: TextOverflow.clip, maxLines: 1, ), ), // 添加时间 Container( width: duSetWidth(15), ), ConstrainedBox( constraints: BoxConstraints( maxWidth: duSetWidth(100), ), child: Text( '• $&#123;duTimeLineFormat(item.addtime)&#125;', style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.thirdElementText, fontSize: duSetFontSize(14), height: 1, ), overflow: TextOverflow.clip, maxLines: 1, ), ), // 更多 Spacer(), InkWell( child: Icon( Icons.more_horiz, color: AppColors.primaryText, size: 24, ), onTap: () &#123;&#125;, ), ], ), ), ], ), ), ], ), );&#125; 资源设计稿蓝湖预览https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat 参考 https://pub.flutter-io.cn/packages/graphql https://strapi.io/documentation/v3.x/getting-started/quick-start.html © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 13 使用 supernova、imgcook 导入 sketch psd xd 自动生成用户中心代码","date":"2020-06-17T16:00:00.000Z","path":"2020/06/18/flutter-project/flutter-project-news-13-code-generate-supernova/","text":"本节目标 了解 supernova 代码生成器作用 导入 xd 设计稿 如何高效使用生成代码 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.13 正文代码生成器 supernova imgcook 有潜力加入代码生成功能 lanhuapp mockplus supernova 代码生成器https://supernova.io/ 导入 xd 设计稿，生成代码 商业设计稿不好直接分享, 可以加微信联系 ducafecat 编写用户中心界面代码组织代码结构123456789101112131415161718192021class _AccountPageState extends State&lt;AccountPage&gt; &#123; // 个人页面 头部 Widget _buildUserHeader() &#123;&#125; // 列表项 Widget _buildCell() &#123;&#125; @override Widget build(BuildContext context) &#123; final appState = Provider.of&lt;AppState&gt;(context); return SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildUserHeader(), _buildCell(), ], ), ); &#125;&#125; 直接使用生成的代码 个人页面 头部 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133Widget _buildUserHeader() &#123; return Container( height: 333, child: Stack( alignment: Alignment.center, children: [ Positioned( left: 0, right: 0, child: Container( height: 333, decoration: BoxDecoration( color: AppColors.primaryBackground, ), child: Column( mainAxisAlignment: MainAxisAlignment.end, crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Container( height: 2, decoration: BoxDecoration( color: AppColors.primaryElement, ), child: Container(), ), ], ), ), ), Positioned( left: 20, top: 40, right: 20, bottom: 21, child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Container( height: 198, child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Align( alignment: Alignment.topCenter, child: Container( width: 108, height: 108, child: Stack( alignment: Alignment.center, children: [ Positioned( top: 0, child: Container( width: 108, height: 108, decoration: BoxDecoration( color: AppColors.primaryBackground, boxShadow: [ Shadows.primaryShadow, ], borderRadius: Radii.k54pxRadius, ), child: Container(), ), ), Positioned( top: 10, child: Image.asset( \"assets/images/image.png\", fit: BoxFit.none, ), ), ], ), ), ), Spacer(), Container( margin: EdgeInsets.only(bottom: 9), child: Text( \"Cameron Rogers\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: 24, ), ), ), Text( \"@boltrogers\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: 16, ), ), ], ), ), Spacer(), Container( height: 44, child: FlatButton( onPressed: () =&gt; this.onButtonPressed(context), color: Color.fromARGB(255, 41, 103, 255), shape: RoundedRectangleBorder( borderRadius: BorderRadius.all(Radius.circular(6)), ), textColor: Color.fromARGB(255, 255, 255, 255), padding: EdgeInsets.all(0), child: Text( \"Get Premium - \\$9.99\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.secondaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: 18, ), ), ), ), ], ), ), ], ), );&#125; 列表项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Widget _buildCell() &#123; return Container( height: 60, child: Stack( alignment: Alignment.centerLeft, children: [ Positioned( left: 0, right: 0, child: Container( height: 60, decoration: BoxDecoration( color: AppColors.secondaryElement, ), child: Column( mainAxisAlignment: MainAxisAlignment.end, crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Container( height: 1, decoration: BoxDecoration( color: AppColors.primaryElement, ), child: Container(), ), ], ), ), ), Positioned( right: 0, child: Row( mainAxisAlignment: MainAxisAlignment.end, children: [ Container( margin: EdgeInsets.only(right: 11), child: Text( \"12\", textAlign: TextAlign.right, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: 18, ), ), ), Container( width: 24, height: 24, margin: EdgeInsets.only(right: 20), child: Image.asset( \"assets/images/icon.png\", fit: BoxFit.none, ), ), ], ), ), Positioned( left: 0, child: Stack( alignment: Alignment.center, children: [ Positioned( left: 0, right: 19, child: Container(), ), Positioned( left: 20, right: 0, child: Text( \"Favorite channels\", textAlign: TextAlign.left, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: 18, ), ), ), ], ), ), ], ), );&#125; 抽取代码 lib/common/widgets/app.dart123456789/// 10像素 DividerWidget divider10Px(&#123;Color bgColor = AppColors.secondaryElement&#125;) &#123; return Container( height: duSetWidth(10), decoration: BoxDecoration( color: bgColor, ), );&#125; 修改代码 _buildUserHeader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// 个人页面 头部Widget _buildUserHeader() &#123; return Container( height: duSetWidth(333), child: Stack( alignment: Alignment.center, children: [ // 背景 Positioned( left: 0, right: 0, child: Container( height: duSetWidth(333), decoration: BoxDecoration( color: AppColors.primaryBackground, ), child: Column( mainAxisAlignment: MainAxisAlignment.end, crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Container( height: duSetWidth(2), decoration: BoxDecoration( color: AppColors.tabCellSeparator, ), child: Container(), ), ], ), ), ), Positioned( left: 20, top: 40, right: 20, bottom: 21, child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: [ // 头像 Container( height: duSetWidth(198), child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Align( alignment: Alignment.topCenter, child: Container( width: duSetWidth(108), height: duSetWidth(108), child: Stack( alignment: Alignment.center, children: [ Positioned( top: 0, child: Container( width: duSetWidth(108), height: duSetWidth(108), decoration: BoxDecoration( color: AppColors.primaryBackground, boxShadow: [ Shadows.primaryShadow, ], borderRadius: BorderRadius.all( Radius.circular(duSetWidth(108) / 2)), ), child: Container(), ), ), Positioned( top: 10, child: Image.asset( \"assets/images/account_header.png\", height: duSetWidth(88), width: duSetWidth(88), fit: BoxFit.fill, ), ), ], ), ), ), // 文字 Spacer(), Container( margin: EdgeInsets.only(bottom: 9), child: Text( Global.profile.displayName, textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: 24, ), ), ), Text( \"@boltrogers\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: 16, ), ), ], ), ), // 按钮 Spacer(), Container( height: 44, child: FlatButton( onPressed: () =&gt; &#123;&#125;, color: Color.fromARGB(255, 41, 103, 255), shape: RoundedRectangleBorder( borderRadius: BorderRadius.all(Radius.circular(6)), ), textColor: Color.fromARGB(255, 255, 255, 255), padding: EdgeInsets.all(0), child: Text( \"Get Premium - \\$9.99\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryElementText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: 18, ), ), ), ), ], ), ), ], ), );&#125; 修改代码 _buildCell123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 列表项Widget _buildCell(&#123; String title, String subTitle, int number, bool hasArrow = false, VoidCallback onTap,&#125;) &#123; return GestureDetector( onTap: onTap, child: Container( height: duSetWidth(60), color: Colors.white, child: Stack( alignment: Alignment.centerLeft, children: [ // 背景 Positioned( left: 0, right: 0, child: Container( height: duSetWidth(60), decoration: BoxDecoration( color: AppColors.primaryBackground, ), child: Column( mainAxisAlignment: MainAxisAlignment.end, crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Container( height: duSetWidth(1), decoration: BoxDecoration( color: AppColors.tabCellSeparator, ), child: Container(), ), ], ), ), ), // 右侧 Positioned( right: 0, child: Row( mainAxisAlignment: MainAxisAlignment.end, children: [ // 数字 number == null ? Container() : Container( margin: EdgeInsets.only(right: 11), child: Text( number.toString(), textAlign: TextAlign.right, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(18), ), ), ), // 箭头 hasArrow == false ? Container() : Container( width: duSetWidth(24), height: duSetWidth(24), margin: EdgeInsets.only(right: 20), child: Icon( Icons.arrow_forward_ios, color: AppColors.primaryText, ), ), ], ), ), // 标题 title == null ? Container() : Positioned( left: 20, child: Text( title, textAlign: TextAlign.left, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(18), ), ), ), // 子标题 subTitle == null ? Container() : Positioned( right: 20, child: Text( subTitle, textAlign: TextAlign.left, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(18), ), ), ), ], ), ), );&#125; 修改代码 build12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@overrideWidget build(BuildContext context) &#123; final appState = Provider.of&lt;AppState&gt;(context); return SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildUserHeader(), divider10Px(), _buildCell( title: \"Email\", subTitle: \"boltrogers@gmail.com\", ), divider10Px(), _buildCell( title: \"Favorite channels\", number: 12, hasArrow: true, ), _buildCell( title: \"Bookmarks\", number: 294, hasArrow: true, ), _buildCell( title: \"Popular categories\", number: 7, hasArrow: true, ), divider10Px(), _buildCell( title: \"Newsletter\", hasArrow: true, ), _buildCell( title: \"Settings\", hasArrow: true, ), divider10Px(), _buildCell( title: \"Switch Gray Filter\", hasArrow: true, onTap: () =&gt; appState.switchGrayFilter(), ), _buildCell( title: \"Log out\", hasArrow: true, onTap: () =&gt; goLoginPage(context), ), divider10Px(), ], ), );&#125; 技巧 vscode 固定代码 总结 资源设计稿蓝湖预览https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 12 采用 sentry 平台收集错误","date":"2020-06-04T16:00:00.000Z","path":"2020/06/05/flutter-project/flutter-project-news-12-error-sentry/","text":"本节目标 使用 sentry 平台 flutter 集成 android 集成 ios 集成 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.12 正文错误收集策略 sentry 平台https://sentry.io 收集 flutter 参考 https://docs.sentry.io/platforms/flutter/ pubspec.yaml 12dependencies: sentry: ^3.0.1 lib/main.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 创建 SentryClient 用于将异常日志上报给 sentry 平台final SentryClient _sentry = new SentryClient( dsn: 'https://xxxxxxxxxx',);// 是否开发环境bool get isInDebugMode &#123; return false; // false 开始上传 sentry&#125;// 上报异常的函数Future&lt;void&gt; _reportError(dynamic error, dynamic stackTrace) async &#123; print('Caught error: $error'); if (isInDebugMode) &#123; print(stackTrace); &#125; else &#123; final SentryResponse response = await _sentry.captureException( exception: error, stackTrace: stackTrace, ); if (response.isSuccessful) &#123; print('Success! Event ID: $&#123;response.eventId&#125;'); &#125; else &#123; print('Failed to report to Sentry.io: $&#123;response.error&#125;'); &#125; &#125;&#125;Future&lt;Null&gt; main() async &#123; // 捕获并上报 Flutter 异常 FlutterError.onError = (FlutterErrorDetails details) async &#123; if (isInDebugMode == true) &#123; FlutterError.dumpErrorToConsole(details); &#125; else &#123; Zone.current.handleUncaughtError(details.exception, details.stack); &#125; &#125;; // 捕获并上报 Dart 异常 runZonedGuarded(() async &#123; await Global.init(); runApp( MultiProvider( providers: [ ChangeNotifierProvider&lt;AppState&gt;.value( value: Global.appState, ), ], child: Consumer&lt;AppState&gt;(builder: (context, appState, _) &#123; if (appState.isGrayFilter) &#123; return ColorFiltered( colorFilter: ColorFilter.mode(Colors.white, BlendMode.color), child: NewsApp(), ); &#125; else &#123; return NewsApp(); &#125; &#125;), ), ); &#125;, (Object error, StackTrace stack) &#123; _reportError(error, stack); &#125;);&#125; 收集 android 参考 https://docs.sentry.io/platforms/android/ 集成 sdk 123456789101112131415161718// ADD JCENTER REPOSITORYrepositories &#123; jcenter()&#125;// ADD COMPATIBILITY OPTIONS TO BE COMPATIBLE WITH JAVA 1.8android &#123; compileOptions &#123; sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 &#125;&#125;// ADD SENTRY ANDROID AS A DEPENDENCYdependencies &#123; // https://github.com/getsentry/sentry-android/releases implementation &apos;io.sentry:sentry-android:&#123;version&#125;&apos;&#125; android/app/src/main/AndroidManifest.xml 12345678910&lt;application android:name=\"io.flutter.app.FlutterApplication\" android:label=\"猫哥新闻\" android:icon=\"@mipmap/launcher_icon\"&gt; ... &lt;!-- sentry --&gt; &lt;meta-data android:name=\"io.sentry.dsn\" android:value=\"xxxxxxxxxxxxxxxxx\" /&gt;&lt;/application&gt; android/app/src/main/kotlin/com/example/flutterducafecatnews/CrashHandler.java 1234567public class CrashHandler implements UncaughtExceptionHandler &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; Sentry.captureException(e); &#125;&#125; android/app/src/main/kotlin/com/example/flutterducafecatnews/MainActivity.kt 123456789import io.sentry.core.Sentryclass MainActivity: FlutterActivity() &#123; override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) &#123; val crashHandler = CrashHandler() Thread.setDefaultUncaughtExceptionHandler(crashHandler) GeneratedPluginRegistrant.registerWith(flutterEngine) &#125;&#125; 收集 ios 资料 https://docs.sentry.io/platforms/cocoa/?_ga=2.17974013.534595501.1591172359-228174411.1591172359&amp;_gac=1.12380800.1591172359.EAIaIQobChMIrICd9Jrl6QIVCj5gCh2zFw8lEAAYASAAEgJwyfD_BwE&amp;platform=javascript 集成 CocoaPods 123456platform :ios, &apos;8.0&apos;use_frameworks! # This is importanttarget &apos;YourApp&apos; do pod &apos;Sentry&apos;, :git =&gt; &apos;https://github.com/getsentry/sentry-cocoa.git&apos;, :tag =&gt; &apos;5.1.2&apos;end ios/Runner/AppDelegate.swift 123456789101112131415161718&#123; SentrySDK.start(options: [ \"dsn\": \"https://xxxxxxxxxxxxxxxxxxx\", \"debug\": true, // Enabled debug when first installing is always helpful \"enableAutoSessionTracking\": true ]) NSSetUncaughtExceptionHandler &#123; exception in print(exception) SentrySDK.capture(message: exception.description) SentrySDK.capture(exception: exception) &#125; GeneratedPluginRegistrant.register(with: self) return super.application(application, didFinishLaunchingWithOptions: launchOptions) &#125; 资源参考 https://docs.sentry.io/platforms/flutter/ https://docs.sentry.io/platforms/android/ https://docs.sentry.io/platforms/cocoa/?_ga=2.17974013.534595501.1591172359-228174411.1591172359&amp;_gac=1.12380800.1591172359.EAIaIQobChMIrICd9Jrl6QIVCj5gCh2zFw8lEAAYASAAEgJwyfD_BwE&amp;platform=javascript 设计稿蓝湖预览https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Docker - 02 前端全栈 windows 从零安装 vmware + centos + docker + yapi","date":"2020-05-28T16:00:00.000Z","path":"2020/05/29/docker/docker-02-windows-vmware-centos-setup/","text":"本节目标 前端全栈主力操作系统选哪个 ? windows 下使用 docker 为什么不行 ? VMWare 安装 centos 远程 centos 系统 centos 配置 docker 环境 视频https://youtu.be/NJIwbs8qmDY 正文1. 主力操作系统分析从前端全栈角度考虑 windows macos ubuntu nodejs、java、go、python ok ok ok vue、react、electron、rn ok ok ok 小程序 ok ok ok ios ok android ok ok ok 办公 office wps ps 微信 QQ XD VSCode ok ok ok macos 专属 safri sketch ok 程序编译、文件名大小写严格 ok ok 2. windows 直接用 docker 存在的问题问题： https://docs.docker.com/get-started/overview/https://docs.docker.com/get-started/https://docs.microsoft.com/en-us/windows/wsl/about 容器架构不同 切到 linux 容器架构，频繁遇到存储驱动兼容问题 WSL 2 的路还很长 总结 开发环境与线上环境不一致，引发不必要的联调成本。 3. windows 下 vmware 安装 centos3.1 下载 centos 7http://isoredirect.centos.org/centos/7/isos/x86_64/ 3.2 安装 centos 7操作见视频 3.3 配置 centos 网卡操作见视频 指令记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 修改配置$ cd /etc/sysconfig/network-scripts$ ll$ vi ifcfg-eth0ONBOOT=yes# vi 文件编辑# cd 进入目录# ll 目录列表------------------------------# 重启网卡$ service network restart# service 管理系统服务------------------------------# 安装工具$ yum install -y net-tools# yum 软件包管理------------------------------# 查看ip$ ifconfig------------------------------# 固定ip、dns$ vi ifcfg-eth0BOOTPROTO=staticIPADDR=10.211.55.5NETMASK=255.255.255.0GATEWAY=10.211.55.1DNS1=223.5.5.5DNS2=223.6.6.6------------------------------# 重启服务、查看dns$ service network restart$ cat /etc/resolv.conf 3.4 远程 ssh 工具 finalshellhttp://www.hostbuf.com xshell、sftphttps://www.netsarang.com/zh/xshell/ puttyhttps://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html cmderhttp://cmder.net/ 3.6 安装 docker卸载旧版12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine sudo root 用户可以不用 原生安装1234567891011121314151617181920212223242526272829# 系统工具$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 加仓库$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo# 安装 docker ce cli$ sudo yum install -y docker-ce docker-ce-cli containerd.io# 启动服务$ sudo systemctl start docker# 开机启动$ sudo systemctl enable docker# 安装 docker-compose$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose# 阿里云加速$ sudo mkdir -p /etc/docker$ sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://8stycbeq.mirror.aliyuncs.com\"]&#125;EOF$ sudo systemctl daemon-reload$ sudo systemctl restart docker 4. 运行 yapi4.1 docker-compose 配置这次修改了数据持久化在指定目录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253version: \"3\"services: mongo-yapi: image: mongo container_name: mongo-ypai restart: always # ports: # - 27017:27017 environment: - TZ=Asia/Shanghai - MONGO_INITDB_DATABASE=yapi # - MONGO_INITDB_ROOT_USERNAME=root # - MONGO_INITDB_ROOT_PASSWORD=$&#123;PASSWORD&#125; volumes: - ./docker-data/mongo-yapi:/data/db networks: docker_net: ipv4_address: 172.22.0.11 # https://github.com/fjc0k/docker-YApi web-yapi: image: jayfong/yapi:latest container_name: web-ypai restart: always ports: - 3000:3000 depends_on: - mongo-yapi links: - mongo-yapi environment: - TZ=Asia/Shanghai - YAPI_ADMIN_ACCOUNT=admin@ducafecat.tech - YAPI_ADMIN_PASSWORD=$&#123;PASSWORD&#125; - YAPI_CLOSE_REGISTER=true - YAPI_DB_SERVERNAME=mongo-yapi - YAPI_DB_PORT=27017 - YAPI_DB_DATABASE=yapi # - YAPI_DB_USER=root # - YAPI_DB_PASS=$&#123;PASSWORD&#125; - YAPI_MAIL_ENABLE=false - YAPI_LDAP_LOGIN_ENABLE=false - YAPI_PLUGINS=[] networks: docker_net: ipv4_address: 172.22.0.12networks: docker_net: driver: bridge ipam: config: - subnet: 172.22.0.0/16 4.2 运行 yapi12345# 启动$ docker-compose up -d# 卸载$ docker-compose down 4.3 修改本地解析C:\\Windows\\System32\\drivers\\etc\\hosts 1127.0.0.1 api.news.ducafecat.tech 问题整理VMware Workstation 与 Device/Credential Guard 不兼容。网上说卸载 Hyper-V， 没必要卸载 管理员方式运行 cmd 执行 1bcdedit /set hypervisorlaunchtype off 然后重启电脑 参考 install docker https://docs.docker.com/engine/install/centos/ install docker-compose https://github.com/docker/compose/releases 阿里镜像 https://cr.console.aliyun.com/cn-beijing/instances/mirrors © 猫哥 https://ducafecat.tech","tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.ducafecat.tech/tags/Docker/"}]},{"title":"Docker - 01 windows 下安装 docker 并运行 yapi 服务","date":"2020-05-20T16:00:00.000Z","path":"2020/05/21/docker/docker-01-install-yapi/","text":"本节目标 安装 docker 启动 yapi 备份、恢复 yapi 正文安装 Windows 10 专业工作站版 i tell you https://msdn.itellyou.cn/ 选用 business 镜像 安装 docker 官网 https://www.docker.com/ 启用 Hyper-V 切换 linunx container 阿里镜像加速 阿里镜像加速 https://cr.console.aliyun.com/cn-zhangjiakou/instances/mirrors 123456&#123; \"registry-mirrors\": [\"https://你的代码.mirror.aliyuncs.com\"], \"insecure-registries\": [], \"debug\": true, \"experimental\": true&#125; docker-compose 配置 yapi .env 1PASSWORD=$V7iTNk5N8#AkOeiwO@BywzBFte2^WsAuI$eJ4k9CKV0riqe docker-compose.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657version: \"3\"services: mongo-yapi: image: mongo container_name: mongo-ypai restart: always # ports: # - 27017:27017 environment: - TZ=Asia/Shanghai - MONGO_INITDB_DATABASE=yapi # - MONGO_INITDB_ROOT_USERNAME=root # - MONGO_INITDB_ROOT_PASSWORD=$&#123;PASSWORD&#125; volumes: # - ./docker-data/mongo-yapi:/data/db - mongo-data:/data/db networks: docker_net: ipv4_address: 172.22.0.11 # https://github.com/fjc0k/docker-YApi web-yapi: image: jayfong/yapi:latest container_name: web-ypai restart: always ports: - 3000:3000 depends_on: - mongo-yapi links: - mongo-yapi environment: - TZ=Asia/Shanghai - YAPI_ADMIN_ACCOUNT=admin@ducafecat.tech - YAPI_ADMIN_PASSWORD=$&#123;PASSWORD&#125; - YAPI_CLOSE_REGISTER=true - YAPI_DB_SERVERNAME=mongo-yapi - YAPI_DB_PORT=27017 - YAPI_DB_DATABASE=yapi # - YAPI_DB_USER=root # - YAPI_DB_PASS=$&#123;PASSWORD&#125; - YAPI_MAIL_ENABLE=false - YAPI_LDAP_LOGIN_ENABLE=false - YAPI_PLUGINS=[] networks: docker_net: ipv4_address: 172.22.0.12volumes: mongo-data:networks: docker_net: driver: bridge ipam: config: - subnet: 172.22.0.0/16 启动、卸载 ypai 服务 启动 1$ docker-compose up -d 卸载 1$ docker-compose down 本地域名解析 C:\\Windows\\System32\\drivers\\etc\\hosts 1127.0.0.1 api.news.ducafecat.tech 查询 volume12345$ docker volume lsDRIVER VOLUME NAMElocal 2fc91e2fd47a7110c2ecc5c8b88b997c4e6ddcf471a1df04f3fb618238ffd8aalocal 26e58cd678a97108f6dcd2cab33b9de341f992ceedacb7fd772c196bec908306local yapi-volumes_mongo-data 备份数据1$ docker run --rm --volumes-from mongo-ypai -v c:\\backup:/backup ubuntu tar cvf /backup/backup.tar -C /data/db . 还原数据1$ docker run --rm --volumes-from mongo-ypai -v c:\\backup:/backup ubuntu bash -c \"cd /data/db &amp;&amp; tar xvf /backup/backup.tar -C /data/db \" 资源参考 https://github.com/fjc0k/docker-YApi https://cr.console.aliyun.com/cn-zhangjiakou/instances/mirrors https://docs.docker.com/storage/volumes/#backup-restore-or-migrate-data-volumes 视频代码https://github.com/ducafecat/docker-yapi.git © 猫哥 https://ducafecat.tech","tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.ducafecat.tech/tags/Docker/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 11 APP升级、android动态授权","date":"2020-05-15T16:00:00.000Z","path":"2020/05/16/flutter-project/flutter-project-news-11-update-permission/","text":"本节目标 app 升级策略 android 动态授权 android 设备目录 ios 支持 swift 语言 快速提示框 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.11 正文ios 支持 swift 语言 出发点 社区第三方包都在用 swift 开发，打包的时候需要加入 swift 语言包。 操作 创建一个支持 swift 的新项目，然后把 lib assets pubspec.yaml 覆盖即可。 app 升级策略 代码实现定义接口 post /app/update 加入依赖包 pubspec.yaml 123456789101112131415161718dependencies: # 设备信息 device_info: ^0.4.2+3 # 包信息 package_info: ^0.4.0+18 # 路径查询 path_provider: ^1.6.8 # permission 权限 permission_handler: ^5.0.0+hotfix.6 # 安装 install_plugin: ^2.0.1 # 对话框 easy_dialog: ^1.0.5 升级工具类 lib/common/utils/update.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import 'dart:io';import 'package:dio/dio.dart';import 'package:easy_dialog/easy_dialog.dart';import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/apis/app.dart';import 'package:flutter_ducafecat_news/common/entitys/entitys.dart';import 'package:flutter_ducafecat_news/common/widgets/toast.dart';import 'package:flutter_ducafecat_news/global.dart';import 'package:install_plugin/install_plugin.dart';import 'package:path_provider/path_provider.dart';/// app 升级class AppUpdateUtil &#123; static AppUpdateUtil _instance = AppUpdateUtil._internal(); factory AppUpdateUtil() =&gt; _instance; BuildContext _context; AppUpdateResponseEntity _appUpdateInfo; AppUpdateUtil._internal(); /// 获取更新信息 Future run(BuildContext context) async &#123; _context = context; // 提交 设备类型、发行渠道、架构、机型 AppUpdateRequestEntity requestDeviceInfo = AppUpdateRequestEntity( device: Global.isIOS == true ? \"ios\" : \"android\", channel: Global.channel, architecture: Global.isIOS == true ? Global.iosDeviceInfo.utsname.machine : Global.androidDeviceInfo.device, model: Global.isIOS == true ? Global.iosDeviceInfo.name : Global.androidDeviceInfo.brand, ); _appUpdateInfo = await AppApi.update(context: context, params: requestDeviceInfo); _runAppUpdate(); &#125; /// 检查是否有新版 Future _runAppUpdate() async &#123; // 比较版本 final isNewVersion = (_appUpdateInfo.latestVersion.compareTo(Global.packageInfo.version) == 1); // 安装 if (isNewVersion == true) &#123; _appUpdateConformDialog(() &#123; Navigator.of(_context).pop(); if (Global.isIOS == true) &#123; // 去苹果店 InstallPlugin.gotoAppStore(_appUpdateInfo.shopUrl); &#125; else &#123; // apk 下载安装 toastInfo(msg: \"开始下载升级包\"); _downloadAPKAndSetup(_appUpdateInfo.fileUrl); &#125; &#125;); &#125; &#125; /// 下载文件 &amp; 安装 Future _downloadAPKAndSetup(String fileUrl) async &#123; // 下载 Directory externalDir = await getExternalStorageDirectory(); String fullPath = externalDir.path + \"/release.apk\"; Dio dio = Dio(BaseOptions( responseType: ResponseType.bytes, followRedirects: false, validateStatus: (status) &#123; return status &lt; 500; &#125;)); Response response = await dio.get( fileUrl, ); File file = File(fullPath); var raf = file.openSync(mode: FileMode.write); raf.writeFromSync(response.data); await raf.close(); // 安装 await InstallPlugin.installApk(fullPath, Global.packageInfo.packageName); &#125; /// 升级确认对话框 void _appUpdateConformDialog(VoidCallback onPressed) &#123; EasyDialog( title: Text( \"发现新版本 $&#123;_appUpdateInfo.latestVersion&#125;\", style: TextStyle(fontWeight: FontWeight.bold), textScaleFactor: 1.2, ), description: Text( _appUpdateInfo.latestDescription, textScaleFactor: 1.1, textAlign: TextAlign.center, ), height: 220, contentList: [ Row( mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ new FlatButton( padding: const EdgeInsets.only(top: 8.0), textColor: Colors.lightBlue, onPressed: onPressed, child: new Text( \"同意\", textScaleFactor: 1.2, ), ), new FlatButton( padding: const EdgeInsets.only(top: 8.0), textColor: Colors.lightBlue, onPressed: () &#123; Navigator.of(_context).pop(); &#125;, child: new Text( \"取消\", textScaleFactor: 1.2, ), ), ], ) ]).show(_context); &#125;&#125; 读取设备信息 插件 https://pub.flutter-io.cn/packages/device_info 全局信息 lib/global.dart 12345678910111213141516171819202122232425262728/// 是否 iosstatic bool isIOS = Platform.isIOS;/// android 设备信息static AndroidDeviceInfo androidDeviceInfo;/// ios 设备信息static IosDeviceInfo iosDeviceInfo;/// 包信息static PackageInfo packageInfo;/// initstatic Future init() async &#123; ... // 读取设备信息 DeviceInfoPlugin deviceInfoPlugin = DeviceInfoPlugin(); if (Global.isIOS) &#123; Global.iosDeviceInfo = await deviceInfoPlugin.iosInfo; &#125; else &#123; Global.androidDeviceInfo = await deviceInfoPlugin.androidInfo; &#125; // 包信息 Global.packageInfo = await PackageInfo.fromPlatform(); ... 定义升级信息 entity lib/common/entitys/app.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class AppUpdateRequestEntity &#123; String device; String channel; String architecture; String model; AppUpdateRequestEntity(&#123; this.device, this.channel, this.architecture, this.model, &#125;); factory AppUpdateRequestEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; AppUpdateRequestEntity( device: json[\"device\"], channel: json[\"channel\"], architecture: json[\"architecture\"], model: json[\"model\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"device\": device, \"channel\": channel, \"architecture\": architecture, \"model\": model, &#125;;&#125;class AppUpdateResponseEntity &#123; String shopUrl; String fileUrl; String latestVersion; String latestDescription; AppUpdateResponseEntity(&#123; this.shopUrl, this.fileUrl, this.latestVersion, this.latestDescription, &#125;); factory AppUpdateResponseEntity.fromJson(Map&lt;String, dynamic&gt; json) =&gt; AppUpdateResponseEntity( shopUrl: json[\"shopUrl\"], fileUrl: json[\"fileUrl\"], latestVersion: json[\"latestVersion\"], latestDescription: json[\"latestDescription\"], ); Map&lt;String, dynamic&gt; toJson() =&gt; &#123; \"shopUrl\": shopUrl, \"fileUrl\": fileUrl, \"latestVersion\": latestVersion, \"latestDescription\": latestDescription, &#125;;&#125; api 请求 lib/common/apis/app.dart 123456789101112131415/// 系统相关class AppApi &#123; /// 获取最新版本信息 static Future&lt;AppUpdateResponseEntity&gt; update(&#123; @required BuildContext context, AppUpdateRequestEntity params, &#125;) async &#123; var response = await HttpUtil().post( '/app/update', context: context, params: params, ); return AppUpdateResponseEntity.fromJson(response); &#125;&#125; 提交信息 获取版本 lib/common/utils/update.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243/// 获取更新信息Future run(BuildContext context) async &#123; _context = context; // 提交 设备类型、发行渠道、架构、机型 AppUpdateRequestEntity requestDeviceInfo = AppUpdateRequestEntity( device: Global.isIOS == true ? \"ios\" : \"android\", channel: Global.channel, architecture: Global.isIOS == true ? Global.iosDeviceInfo.utsname.machine : Global.androidDeviceInfo.device, model: Global.isIOS == true ? Global.iosDeviceInfo.name : Global.androidDeviceInfo.brand, ); _appUpdateInfo = await AppApi.update(context: context, params: requestDeviceInfo); _runAppUpdate();&#125;/// 检查是否有新版Future _runAppUpdate() async &#123; // 比较版本 final isNewVersion = (_appUpdateInfo.latestVersion.compareTo(Global.packageInfo.version) == 1); // 安装 if (isNewVersion == true) &#123; _appUpdateConformDialog(() &#123; Navigator.of(_context).pop(); if (Global.isIOS == true) &#123; // 去苹果店 InstallPlugin.gotoAppStore(_appUpdateInfo.shopUrl); &#125; else &#123; // apk 下载安装 toastInfo(msg: \"开始下载升级包\"); _downloadAPKAndSetup(_appUpdateInfo.fileUrl); &#125; &#125;); &#125;&#125; android 动态授权 插件 https://pub.flutter-io.cn/packages/permission_handler 官方文章 https://developer.android.com/training/permissions/requesting https://developer.android.com/training/permissions/usage-notes AndroidManifest.xml 中加入权限 android/app/src/main/AndroidManifest.xml 123&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; flutter 启动页中执行授权 lib/pages/index/index.dart 在 initState 是执行 延迟 3 秒，用户体验好些 123456789101112131415161718192021class _IndexPageState extends State&lt;IndexPage&gt; &#123; @override void initState() &#123; super.initState(); if (Global.isRelease == true) &#123; doAppUpdate(); &#125; &#125; Future doAppUpdate() async &#123; await Future.delayed(Duration(seconds: 3), () async &#123; if (Global.isIOS == false &amp;&amp; await Permission.storage.isGranted == false) &#123; await [Permission.storage].request(); &#125; if (await Permission.storage.isGranted) &#123; AppUpdateUtil().run(context); &#125; &#125;); &#125; android 目录权限 插件 https://pub.flutter-io.cn/packages/path_providerhttps://pub.flutter-io.cn/packages/install_plugin 文章 https://developer.android.com/reference/androidx/core/content/FileProvider.html lib/common/utils/update.dart 123456789101112131415161718192021222324/// 下载文件 &amp; 安装Future _downloadAPKAndSetup(String fileUrl) async &#123; // 下载 Directory externalDir = await getExternalStorageDirectory(); String fullPath = externalDir.path + \"/release.apk\"; Dio dio = Dio(BaseOptions( responseType: ResponseType.bytes, followRedirects: false, validateStatus: (status) &#123; return status &lt; 500; &#125;)); Response response = await dio.get( fileUrl, ); File file = File(fullPath); var raf = file.openSync(mode: FileMode.write); raf.writeFromSync(response.data); await raf.close(); // 安装 await InstallPlugin.installApk(fullPath, Global.packageInfo.packageName);&#125; EasyDialog 快速提示框 插件 https://pub.flutter-io.cn/packages/easy_dialog lib/common/utils/update.dart 123456789101112131415161718192021222324252627282930313233343536373839404142/// 升级确认对话框void _appUpdateConformDialog(VoidCallback onPressed) &#123; EasyDialog( title: Text( \"发现新版本 $&#123;_appUpdateInfo.latestVersion&#125;\", style: TextStyle(fontWeight: FontWeight.bold), textScaleFactor: 1.2, ), description: Text( _appUpdateInfo.latestDescription, textScaleFactor: 1.1, textAlign: TextAlign.center, ), height: 220, contentList: [ Row( mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ new FlatButton( padding: const EdgeInsets.only(top: 8.0), textColor: Colors.lightBlue, onPressed: onPressed, child: new Text( \"同意\", textScaleFactor: 1.2, ), ), new FlatButton( padding: const EdgeInsets.only(top: 8.0), textColor: Colors.lightBlue, onPressed: () &#123; Navigator.of(_context).pop(); &#125;, child: new Text( \"取消\", textScaleFactor: 1.2, ), ), ], ) ]).show(_context);&#125; 资源视频 b 站 油管镜像 蓝湖设计稿（加微信给授权 ducafecat）https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat YAPI 接口管理http://yapi.demo.qunar.com/ 参考 文章 https://developer.android.com/training/permissions/requestinghttps://developer.android.com/training/permissions/usage-noteshttps://developer.android.com/reference/androidx/core/content/FileProvider.html flutter 插件 https://pub.flutter-io.cn/packages/device_infohttps://pub.flutter-io.cn/packages/path_providerhttps://pub.flutter-io.cn/packages/permission_handlerhttps://pub.flutter-io.cn/packages/install_pluginhttps://pub.flutter-io.cn/packages/easy_dialog VSCode 插件 Flutter、Dart Flutter Widget Snippets Awesome Flutter Snippets Paste JSON as Code bloc Code Spell Checker © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 10 编译发布正式版","date":"2020-05-04T16:00:00.000Z","path":"2020/05/05/flutter-project/flutter-project-news-10-release/","text":"本节目标 编译 build releae 程序瘦身 混淆程序 修改程序名称 制作图标 制作启动画面 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.10 正文1. APP 图标规格说明https://developer.android.com/google-play/resources/icon-design-specifications https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/app-icon/ 图标尺寸android 512x512 ios 1024x1024 在线工具https://www.designevo.com/cn/logo-maker/ flutter_launcher_icons 插件https://pub.dev/packages/flutter_launcher_icons pubspec.yaml12345678dev_dependencies: # icons flutter_launcher_icons: ^0.7.5flutter_icons: android: \"launcher_icon\" ios: true image_path: \"assets/icons/logo-1024.png\" 生成图标1flutter pub run flutter_launcher_icons:main 图标目录android/app/src/main/res ios/Runner/Assets.xcassets/AppIcon.appiconset 2. 启动图片规格说明https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/#device-screen-sizes-and-orientations https://developer.android.com/about/dashboards/index.html#Screens https://uiiiuiii.com/screen/ 图片尺寸iPhone XS Max 1242px × 2688px android xxhdpi xhdpi 在线工具https://hotpot.ai/icon_resizer 3. Android 发布证书签名说明https://developer.android.com/studio/publish/app-signing?hl=zh-cn 生成证书12345# 进入目录 android/app/keytool -genkey -v -keystore ./key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key# 输出文件android/app/key.jks Gradle 配置 android/gradle.properties 1android.enableAapt2=false # 不检测依赖资源 android/key.properties 1234storePassword=123456keyPassword=123456keyAlias=keystoreFile=./key.jks android/app/build.gradle 123456789101112131415161718192021222324252627282930// 定义属性读取对象，读取 android/key.propertiesdef keystoreProperties = new Properties()def keystorePropertiesFile = rootProject.file('key.properties')if (keystorePropertiesFile.exists()) &#123; keystoreProperties.load(new FileInputStream(keystorePropertiesFile))&#125;android &#123; compileSdkVersion 28 ... // 签名配置 signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125; &#125; buildTypes &#123; // 发布配置 release &#123; signingConfig signingConfigs.release &#125; &#125;&#125; 修改版本号 pubspec.yaml 1version: 1.0.0+1 修改程序名称 android/app/src/main/AndroidManifest.xml 1234&lt;application android:name=\"io.flutter.app.FlutterApplication\" android:label=\"猫哥新闻\" android:icon=\"@mipmap/launcher_icon\"&gt; 设置网络权限 android/app/src/main/AndroidManifest.xml 1234 &lt;/application&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;/manifest&gt; 编译打包1flutter build apk --split-per-abi 输出目录123✓ Built build/app/outputs/apk/release/app-armeabi-v7a-release.apk (7.2MB).✓ Built build/app/outputs/apk/release/app-arm64-v8a-release.apk (7.4MB).✓ Built build/app/outputs/apk/release/app-x86_64-release.apk (7.6MB). 混淆编译https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code android/gradle.properties 1extra-gen-snapshot-options=--obfuscate android/proguard-rules.pro 12345678#Flutter Wrapper-dontwarn io.flutter.**-keep class io.flutter.app.** &#123; *; &#125;-keep class io.flutter.plugin.** &#123; *; &#125;-keep class io.flutter.util.** &#123; *; &#125;-keep class io.flutter.view.** &#123; *; &#125;-keep class io.flutter.** &#123; *; &#125;-keep class io.flutter.plugins.** &#123; *; &#125; android/app/build.gradle 123456789101112buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled true //资源压缩设置 useProguard true //代码压缩设置 //读取代码压缩配置文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; 编译 1flutter build apk --split-per-abi 启动页 图片 android/app/src/main/res/values/colors.xml 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;color name=\"cyan\"&gt;#deecec&lt;/color&gt;&lt;/resources&gt; android/app/src/main/res/drawable/launch_background.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- Modify this file to customize your launch splash screen --&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/cyan\" /&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/launch_image\" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 4. IOS 发布启动页 修改程序名称 资源视频 b 站 油管镜像 蓝湖设计稿（加微信给授权 ducafecat）https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat YAPI 接口管理http://yapi.demo.qunar.com/ 参考https://flutter.dev/docs/deployment/android https://flutter.dev/docs/deployment/ios https://flutter.dev/docs/deployment/obfuscate https://github.com/flutter/flutter/wiki/Obfuscating-Dart-Code https://pub.dev/packages/flutter_launcher_icons https://developer.android.com/google-play/resources/icon-design-specifications https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/app-icon/ https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/#device-screen-sizes-and-orientations https://developer.android.com/about/dashboards/index.html#Screens https://uiiiuiii.com/screen/ VSCode 插件 Flutter、Dart Flutter Widget Snippets Awesome Flutter Snippets Paste JSON as Code bloc Code Spell Checker © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 09 详情页展示、分享、远程真机调试","date":"2020-04-23T16:00:00.000Z","path":"2020/04/24/flutter-project/flutter-project-news-09-webview/","text":"本节目标 详情页技术方案比较 载入 web 内容 自动计算高度 清除广告、推荐 拦截请求 loading 状态显示 分享插件 远程 android 设备调试 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.9 详情展示技术方案选择分析工具 UI automator view 文件位置 /Users/ducafecat/Library/Android/sdk/tools/bin/uiautomatorviewer 淘宝方案 混合方式 头条 混合方式 什么值得买 单一 webView 技术点分析 webView 原生 混合方式 计算 web 页面高度 拦截请求，自定义指令 内存占用（尽量少的 dom 元素） 安装插件 webview_flutter https://pub.flutter-io.cn/packages/webview_flutter pubspec.yaml 12dependencies: webview_flutter: ^0.3.20+2 ios/Runner/Info.plist 12&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;&lt;true/&gt; 构建界面代码123456789101112131415161718192021222324252627282930313233343536// 顶部导航Widget _buildAppBar() &#123; return Container();&#125;// 页标题Widget _buildPageTitle() &#123; return Container();&#125;// 页头部Widget _buildPageHeader() &#123; return Container();&#125;// web内容Widget _buildWebView() &#123; return Container();&#125;@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: _buildAppBar(), body: SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildPageTitle(), Divider(height: 1), _buildPageHeader(), _buildWebView(), ], ), ), );&#125; url 载入1234567891011121314Widget _buildWebView() &#123; return Container( height: _webViewHeight, child: WebView( initialUrl: '$SERVER_API_URL/news/content/$&#123;widget.item.id&#125;', //widget.url, javascriptMode: JavascriptMode.unrestricted, onWebViewCreated: (WebViewController webViewController) async &#123; _controller.complete(webViewController); &#125;, gestureNavigationEnabled: true, ), );&#125; 计算高度 PX DP https://blog.akanelee.me/2018/07/31/dpi-px-pt-dp-sp/ 设备像素密度 一个逻辑像素占用多少个实际像素 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio https://api.flutter.dev/flutter/dart-ui/Window/devicePixelRatio.html 注册 js 12345double _webViewHeight = 200; javascriptChannels: &lt;JavascriptChannel&gt;[ _invokeJavascriptChannel(context), ].toSet(), 123456789101112131415// 注册js回调JavascriptChannel _invokeJavascriptChannel(BuildContext context) &#123; return JavascriptChannel( name: 'Invoke', onMessageReceived: (JavascriptMessage message) &#123; print(message.message); var webHeight = double.parse(message.message); if (webHeight != null) &#123; setState(() &#123; _webViewHeight = webHeight; &#125;); &#125; &#125;);&#125; 回调 123456onPageFinished: (String url) &#123; _getWebViewHeight(); setState(() &#123; _isPageFinished = true; &#125;);&#125;, 123456789101112// 获取页面高度_getWebViewHeight() async &#123; await (await _controller.future)?.evaluateJavascript(''' try &#123; // Invoke.postMessage([document.body.clientHeight,document.documentElement.clientHeight,document.documentElement.scrollHeight]); let scrollHeight = document.documentElement.scrollHeight; if (scrollHeight) &#123; Invoke.postMessage(scrollHeight); &#125; &#125; catch &#123;&#125; ''');&#125; 清除广告、推荐 https://cn.engadget.com/cn-2020-01-21-google-pixelbook-go-not-pink-available.html 删除广告 123456789onPageStarted: (String url) &#123; Timer(Duration(seconds: 1), () &#123; setState(() &#123; _isPageFinished = true; &#125;); _removeAd(); _getViewHeight(); &#125;);&#125;, 1234567891011121314151617181920212223_removeWebViewAd() async &#123; await (await _controller.future)?.evaluateJavascript(''' try &#123; function removeElement(elementName)&#123; let _element = document.getElementById(elementName); if(!_element) &#123; _element = document.querySelector(elementName); &#125; if(!_element) &#123; return; &#125; let _parentElement = _element.parentNode; if(_parentElement)&#123; _parentElement.removeChild(_element); &#125; &#125; removeElement('module-engadget-deeplink-top-ad'); removeElement('module-engadget-deeplink-streams'); removeElement('footer'); &#125; catch&#123;&#125; ''');&#125; 拦截请求 页面中 href 1234567891011&lt;div class=\"tags\"&gt; &lt;a href=\"/tag/chrome-os\" class=\"tag\"&gt;chrome os&lt;/a&gt; &lt;a href=\"/tag/chromebook\" class=\"tag\"&gt;chromebook&lt;/a&gt; &lt;a href=\"/tag/computer\" class=\"tag\"&gt;computer&lt;/a&gt; &lt;a href=\"/tag/gear\" class=\"tag\"&gt;gear&lt;/a&gt; &lt;a href=\"/tag/google\" class=\"tag\"&gt;google&lt;/a&gt; &lt;a href=\"/tag/laptop\" class=\"tag\"&gt;laptop&lt;/a&gt; &lt;a href=\"/tag/personal computing\" class=\"tag\"&gt;personal computing&lt;/a&gt; &lt;a href=\"/tag/personalcomputing\" class=\"tag\"&gt;personalcomputing&lt;/a&gt; &lt;a href=\"/tag/pixelbook-go\" class=\"tag\"&gt;pixelbook go&lt;/a&gt;&lt;/div&gt; navigation 拦截 1234567navigationDelegate: (NavigationRequest request) &#123; if (request.url != '$SERVER_API_URL/news/content/$&#123;widget.item.id&#125;') &#123; toastInfo(msg: request.url); return NavigationDecision.prevent; &#125; return NavigationDecision.navigate;&#125;, loading 状态显示12345678910111213141516171819202122232425262728bool _isPageFinished = false;@overrideWidget build(BuildContext context) &#123; return Scaffold( appBar: _buildAppBar(), body: Stack( children: &lt;Widget&gt;[ SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildPageTitle(), Divider(height: 1), _buildPageHeader(), _buildWebView(), ], ), ), _isPageFinished == true ? Container() : Align( alignment: Alignment.center, child: LoadingBouncingGrid.square(), ), ], ));&#125; 分享安装插件12dependencies: share: ^0.6.4 代码123onPressed: () &#123; Share.share('$&#123;widget.item.title&#125; $&#123;widget.item.url&#125;');&#125;, 真机调试 scrcpy https://github.com/Genymobile/scrcpy 资源视频 b 站 油管镜像 蓝湖设计稿（加微信给授权 ducafecat）https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat YAPI 接口管理http://yapi.demo.qunar.com/ 参考https://pub.flutter-io.cn/packages/webview_flutterhttps://pub.flutter-io.cn/packages/loading_animationshttps://pub.flutter-io.cn/packages/sharehttps://github.com/Genymobile/scrcpy VSCode 插件 Flutter、Dart Flutter Widget Snippets Awesome Flutter Snippets Paste JSON as Code bloc Code Spell Checker © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 08 路由管理 auto_route","date":"2020-04-16T16:00:00.000Z","path":"2020/04/17/flutter-project/flutter-project-news-08-auto-route/","text":"本节目标 安装插件 路由定义 自动生成路由控制类 转场动画 登录检查中间件 带参数传递 获取返回值 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.8 正文一些优秀的路由插件 fluro 前端的使用体验 router.navigateTo(context, “/users/1234”, transition: TransitionType.fadeIn); flutter_modular 功能强大的路由管理：中间件、懒加载、状态管理、动态路由、分组路由、动画、返回值、命名路由 auto_route 设计精简、低耦合其它功能 功能：中间件、自动生成路由代码、动态路由、动画、返回值、命名路由 安装插件 官网 https://pub.flutter-io.cn/packages/auto_route pubspec.yaml 1234567891011121314dependencies: flutter: sdk: flutter # 路由管理 auto_route: ^0.4.4dev_dependencies: flutter_test: sdk: flutter # 路由生成 auto_route_generator: ^0.4.4 build_runner: 路由定义 lib/common/router/router.dart 123456789101112131415@MaterialAutoRouter()class $AppRouter &#123; @initial IndexPage indexPageRoute; WelcomePage welcomePageRoute; SignInPage signInPageRoute; SignUpPage signUpPageRoute; ApplicationPage applicationPageRoute; DetailsPage detailsPageRoute;&#125; 注意 $ 符号 自动生成路由控制类 执行命令 1flutter packages pub run build_runner build 自动生成 lib/common/router/router.gr.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// GENERATED CODE - DO NOT MODIFY BY HAND// **************************************************************************// AutoRouteGenerator// **************************************************************************import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';import 'package:auto_route/auto_route.dart';import 'package:flutter_ducafecat_news/pages/index/index.dart';import 'package:flutter_ducafecat_news/pages/welcome/welcome.dart';import 'package:flutter_ducafecat_news/pages/sign_in/sign_in.dart';import 'package:flutter_ducafecat_news/pages/sign_up/sign_up.dart';import 'package:flutter_ducafecat_news/pages/application/application.dart';import 'package:flutter_ducafecat_news/common/router/auth_grard.dart';import 'package:flutter_ducafecat_news/pages/details/details.dart';abstract class Routes &#123; static const indexPageRoute = '/'; static const welcomePageRoute = '/welcome-page-route'; static const signInPageRoute = '/sign-in-page-route'; static const signUpPageRoute = '/sign-up-page-route'; static const applicationPageRoute = '/application-page-route'; static const detailsPageRoute = '/details-page-route';&#125;class AppRouter extends RouterBase &#123; @override Map&lt;String, List&lt;Type&gt;&gt; get guardedRoutes =&gt; &#123; Routes.applicationPageRoute: [AuthGuard], Routes.detailsPageRoute: [AuthGuard], &#125;; //This will probably be removed in future versions //you should call ExtendedNavigator.ofRouter&lt;Router&gt;() directly static ExtendedNavigatorState get navigator =&gt; ExtendedNavigator.ofRouter&lt;AppRouter&gt;(); @override Route&lt;dynamic&gt; onGenerateRoute(RouteSettings settings) &#123; final args = settings.arguments; switch (settings.name) &#123; case Routes.indexPageRoute: if (hasInvalidArgs&lt;IndexPageArguments&gt;(args)) &#123; return misTypedArgsRoute&lt;IndexPageArguments&gt;(args); &#125; final typedArgs = args as IndexPageArguments ?? IndexPageArguments(); return MaterialPageRoute&lt;dynamic&gt;( builder: (_) =&gt; IndexPage(key: typedArgs.key), settings: settings, ); case Routes.welcomePageRoute: if (hasInvalidArgs&lt;WelcomePageArguments&gt;(args)) &#123; return misTypedArgsRoute&lt;WelcomePageArguments&gt;(args); &#125; final typedArgs = args as WelcomePageArguments ?? WelcomePageArguments(); return MaterialPageRoute&lt;dynamic&gt;( builder: (_) =&gt; WelcomePage(key: typedArgs.key), settings: settings, ); case Routes.signInPageRoute: if (hasInvalidArgs&lt;SignInPageArguments&gt;(args)) &#123; return misTypedArgsRoute&lt;SignInPageArguments&gt;(args); &#125; final typedArgs = args as SignInPageArguments ?? SignInPageArguments(); return MaterialPageRoute&lt;dynamic&gt;( builder: (_) =&gt; SignInPage(key: typedArgs.key), settings: settings, ); case Routes.signUpPageRoute: if (hasInvalidArgs&lt;SignUpPageArguments&gt;(args)) &#123; return misTypedArgsRoute&lt;SignUpPageArguments&gt;(args); &#125; final typedArgs = args as SignUpPageArguments ?? SignUpPageArguments(); return MaterialPageRoute&lt;dynamic&gt;( builder: (_) =&gt; SignUpPage(key: typedArgs.key), settings: settings, ); case Routes.applicationPageRoute: if (hasInvalidArgs&lt;ApplicationPageArguments&gt;(args)) &#123; return misTypedArgsRoute&lt;ApplicationPageArguments&gt;(args); &#125; final typedArgs = args as ApplicationPageArguments ?? ApplicationPageArguments(); return MaterialPageRoute&lt;dynamic&gt;( builder: (_) =&gt; ApplicationPage(key: typedArgs.key), settings: settings, ); case Routes.detailsPageRoute: if (hasInvalidArgs&lt;DetailsPageArguments&gt;(args)) &#123; return misTypedArgsRoute&lt;DetailsPageArguments&gt;(args); &#125; final typedArgs = args as DetailsPageArguments ?? DetailsPageArguments(); return MaterialPageRoute&lt;dynamic&gt;( builder: (_) =&gt; DetailsPage(key: typedArgs.key), settings: settings, ); default: return unknownRoutePage(settings.name); &#125; &#125;&#125;//**************************************************************************// Arguments holder classes//***************************************************************************//IndexPage arguments holder classclass IndexPageArguments &#123; final Key key; IndexPageArguments(&#123;this.key&#125;);&#125;//WelcomePage arguments holder classclass WelcomePageArguments &#123; final Key key; WelcomePageArguments(&#123;this.key&#125;);&#125;//SignInPage arguments holder classclass SignInPageArguments &#123; final Key key; SignInPageArguments(&#123;this.key&#125;);&#125;//SignUpPage arguments holder classclass SignUpPageArguments &#123; final Key key; SignUpPageArguments(&#123;this.key&#125;);&#125;//ApplicationPage arguments holder classclass ApplicationPageArguments &#123; final Key key; ApplicationPageArguments(&#123;this.key&#125;);&#125;//DetailsPage arguments holder classclass DetailsPageArguments &#123; final Key key; DetailsPageArguments(&#123;this.key&#125;);&#125; 路由跳转 方式 1：带 context 方式 1ExtendedNavigator.of(context).pushNamed(Routes.signUpPageRoute); 方式 2：不带 context 方式 1ExtendedNavigator.ofRouter&lt;AppRouter&gt;().pushNamed(Routes.signUpPageRoute); 方式 3：如果你只有一个导航 1ExtenedNavigator.rootNavigator.pushNamed(Routes.signUpPageRoute); 转场动画 lib/common/router/router.dart 1234567891011121314Widget zoomInTransition(BuildContext context, Animation&lt;double&gt; animation, Animation&lt;double&gt; secondaryAnimation, Widget child) &#123; // you get an animation object and a widget // make your own transition return ScaleTransition(scale: animation, child: child);&#125;@MaterialAutoRouter()class $AppRouter &#123; ... @CustomRoute(transitionsBuilder: zoomInTransition) ApplicationPage applicationPageRoute;&#125; 重新生成 1flutter packages pub run build_runner build 登录检查中间件 创建 lib/common/router/auth_grard.dart 12345678910111213141516import 'package:auto_route/auto_route.dart';import 'package:flutter_ducafecat_news/common/router/router.gr.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';class AuthGuard extends RouteGuard &#123; @override Future&lt;bool&gt; canNavigate(ExtendedNavigatorState navigator, String routeName, Object arguments) async &#123; var isAuth = await isAuthenticated(); if (isAuth == false) &#123; ExtendedNavigator.rootNavigator.pushNamed(Routes.signInPageRoute); &#125; return isAuth; &#125;&#125; 注册 lib/main.dart 1234567891011121314class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'ducafecat.tech', debugShowCheckedModeBanner: false, builder: ExtendedNavigator&lt;AppRouter&gt;( initialRoute: Routes.indexPageRoute, router: AppRouter(), guards: [AuthGuard()], ), ); &#125;&#125; 定义 lib/common/router/router.dart 12345678@MaterialAutoRouter()class $AppRouter &#123; ... @GuardedBy([AuthGuard]) @CustomRoute(transitionsBuilder: zoomInTransition) ApplicationPage applicationPageRoute;&#125; 重新生成 1flutter packages pub run build_runner build 参数传递 设定初始参数 lib/pages/details/details.dart 123class DetailsPage extends StatefulWidget &#123; final String cid; DetailsPage(&#123;Key key, this.cid&#125;) : super(key: key); 定义 lib/common/router/router.dart 123@MaterialAutoRouter(generateNavigationHelperExtension: true)class $AppRouter &#123; ... 重新生成 1flutter packages pub run build_runner build lib/common/router/router.gr.dart 123456//DetailsPage arguments holder classclass DetailsPageArguments &#123; final Key key; final String cid; DetailsPageArguments(&#123;this.key, this.cid&#125;);&#125; 导航参数 1ExtendedNavigator.rootNavigator.pushDetailsPageRoute(cid: '123'); 获取返回值 12345ExtendedNavigator.rootNavigator .pushNamed(Routes.signUpPageRoute) .then((onValue) &#123; print(onValue);&#125;); 资源视频 b 站 油管镜像 蓝湖设计稿（加微信给授权 ducafecat）https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat YAPI 接口管理http://yapi.demo.qunar.com/ 参考https://pub.flutter-io.cn/packages/auto_route VSCode 插件 Flutter、Dart Flutter Widget Snippets Awesome Flutter Snippets Paste JSON as Code bloc Code Spell Checker © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 07 Provider、认证授权、骨架屏、磁盘缓存","date":"2020-04-07T16:00:00.000Z","path":"2020/04/08/flutter-project/flutter-project-news-07-provider/","text":"本节目标 第一次登录显示欢迎界面 离线登录 Provider 响应数据管理 实现 APP 色彩灰度处理 注销登录 Http Status 401 认证授权 首页磁盘缓存 首页缓存策略，延迟 1~3 秒 首页骨架屏 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.7 视频 b 站 油管镜像 资源 蓝湖设计稿（加微信给授权 ducafecat）https://lanhuapp.com/url/wbhGq YAPI 接口管理http://yapi.demo.qunar.com/ 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.7 参考 provider pk_skeleton 第一次显示欢迎界面、离线登录 lib/global.dart 12345678910111213141516171819202122/// 是否第一次打开static bool isFirstOpen = false;/// 是否离线登录static bool isOfflineLogin = false;/// initstatic Future init() async &#123; ... // 读取设备第一次打开 isFirstOpen = !StorageUtil().getBool(STORAGE_DEVICE_ALREADY_OPEN_KEY); if (isFirstOpen) &#123; StorageUtil().setBool(STORAGE_DEVICE_ALREADY_OPEN_KEY, true); &#125; // 读取离线用户信息 var _profileJSON = StorageUtil().getJSON(STORAGE_USER_PROFILE_KEY); if (_profileJSON != null) &#123; profile = UserLoginResponseEntity.fromJson(_profileJSON); isOfflineLogin = true; &#125; lib/pages/index/index.dart 123456789101112131415161718192021222324class IndexPage extends StatefulWidget &#123; IndexPage(&#123;Key key&#125;) : super(key: key); @override _IndexPageState createState() =&gt; _IndexPageState();&#125;class _IndexPageState extends State&lt;IndexPage&gt; &#123; @override Widget build(BuildContext context) &#123; ScreenUtil.init( context, width: 375, height: 812 - 44 - 34, allowFontScaling: true, ); return Scaffold( body: Global.isFirstOpen == true ? WelcomePage() : Global.isOfflineLogin == true ? ApplicationPage() : SignInPage(), ); &#125;&#125; Provider 实现动态灰度处理https://pub.flutter-io.cn/packages/provider 步骤 1：安装依赖12dependencies: provider: ^4.0.4 步骤 2：创建响应数据类 lib/common/provider/app.dart 123456789101112import 'package:flutter/material.dart';/// 系统相应状态class AppState with ChangeNotifier &#123; bool _isGrayFilter; get isGrayFilter =&gt; _isGrayFilter; AppState(&#123;bool isGrayFilter = false&#125;) &#123; this._isGrayFilter = isGrayFilter; &#125;&#125; 步骤 3：初始响应数据方式一：先创建数据对象，再挂载 lib/global.dart 12/// 应用状态static AppState appState = AppState(); lib/main.dart 12345678910void main() =&gt; Global.init().then((e) =&gt; runApp( MultiProvider( providers: [ ChangeNotifierProvider&lt;AppState&gt;.value( value: Global.appState, ), ], child: MyApp(), ), )); 方式二：挂载时，创建对象 lib/main.dart 12345678910void main() =&gt; Global.init().then((e) =&gt; runApp( MultiProvider( providers: [ ChangeNotifierProvider&lt;AppState&gt;( Create: (_) =&gt; new AppState(), ), ], child: MyApp(), ), )); 步骤 4：通知数据发声变化 lib/common/provider/app.dart 123456789class AppState with ChangeNotifier &#123; ... // 切换灰色滤镜 switchGrayFilter() &#123; _isGrayFilter = !_isGrayFilter; notifyListeners(); &#125;&#125; 步骤 5：收到数据发声变化方式一：Consumer lib/main.dart 12345678910111213141516171819void main() =&gt; Global.init().then((e) =&gt; runApp( MultiProvider( providers: [ ChangeNotifierProvider&lt;AppState&gt;.value( value: Global.appState, ), ], child: Consumer&lt;AppState&gt;(builder: (context, appState, _) &#123; if (appState.isGrayFilter) &#123; return ColorFiltered( colorFilter: ColorFilter.mode(Colors.white, BlendMode.color), child: MyApp(), ); &#125; else &#123; return MyApp(); &#125; &#125;), ), )); 方式二：Provider.of lib/pages/account/account.dart 123456789101112final appState = Provider.of&lt;AppState&gt;(context);return Column( children: &lt;Widget&gt;[ MaterialButton( onPressed: () &#123; appState.switchGrayFilter(); &#125;, child: Text('灰色切换 $&#123;appState.isGrayFilter&#125;'), ), ],); 多个响应数据处理 挂载用 MultiProvider 接收用 Consumer2 ~ Consumer6 注销登录 lib/common/utils/authentication.dart 123456789101112131415161718/// 检查是否有 tokenFuture&lt;bool&gt; isAuthenticated() async &#123; var profileJSON = StorageUtil().getJSON(STORAGE_USER_PROFILE_KEY); return profileJSON != null ? true : false;&#125;/// 删除缓存 tokenFuture deleteAuthentication() async &#123; await StorageUtil().remove(STORAGE_USER_PROFILE_KEY); Global.profile = null;&#125;/// 重新登录Future goLoginPage(BuildContext context) async &#123; await deleteAuthentication(); Navigator.pushNamedAndRemoveUntil( context, \"/sign-in\", (Route&lt;dynamic&gt; route) =&gt; false);&#125; lib/pages/account/account.dart 12345678910111213141516171819class _AccountPageState extends State&lt;AccountPage&gt; &#123; @override Widget build(BuildContext context) &#123; final appState = Provider.of&lt;AppState&gt;(context); return Column( children: &lt;Widget&gt;[ Text('用户: $&#123;Global.profile.displayName&#125;'), Divider(), MaterialButton( onPressed: () &#123; goLoginPage(context); &#125;, child: Text('退出'), ), ], ); &#125;&#125; Http Status 401 认证授权dio 封装界面的上下文对象 BuildContext context lib/common/utils/http.dart 123456789101112Future post( String path, &#123; @required BuildContext context, dynamic params, Options options,&#125;) async &#123; Options requestOptions = options ?? Options(); requestOptions = requestOptions.merge(extra: &#123; \"context\": context, &#125;); ...&#125; 错误处理 401 去登录界面 lib/common/utils/http.dart 12345678910111213141516171819202122// 添加拦截器dio.interceptors .add(InterceptorsWrapper(onRequest: (RequestOptions options) &#123; return options; //continue&#125;, onResponse: (Response response) &#123; return response; // continue&#125;, onError: (DioError e) &#123; ErrorEntity eInfo = createErrorEntity(e); // 错误提示 toastInfo(msg: eInfo.message); // 错误交互处理 var context = e.request.extra[\"context\"]; if (context != null) &#123; switch (eInfo.code) &#123; case 401: // 没有权限 重新登录 goLoginPage(context); break; default: &#125; &#125; return eInfo;&#125;)); 首页磁盘缓存 lib/common/utils/net_cache.dart 12345678910111213141516171819202122232425// 策略 1 内存缓存优先，2 然后才是磁盘缓存// 1 内存缓存var ob = cache[key];if (ob != null) &#123; //若缓存未过期，则返回缓存内容 if ((DateTime.now().millisecondsSinceEpoch - ob.timeStamp) / 1000 &lt; CACHE_MAXAGE) &#123; return cache[key].response; &#125; else &#123; //若已过期则删除缓存，继续向服务器请求 cache.remove(key); &#125;&#125;// 2 磁盘缓存if (cacheDisk) &#123; var cacheData = StorageUtil().getJSON(key); if (cacheData != null) &#123; return Response( statusCode: 200, data: cacheData, ); &#125;&#125; 首页缓存策略，延迟 1~3 秒 lib/pages/main/channels_widget.dart 1234567891011// 如果有磁盘缓存，延迟3秒拉取更新档案_loadLatestWithDiskCache() &#123; if (CACHE_ENABLE == true) &#123; var cacheData = StorageUtil().getJSON(STORAGE_INDEX_NEWS_CACHE_KEY); if (cacheData != null) &#123; Timer(Duration(seconds: 3), () &#123; _controller.callRefresh(); &#125;); &#125; &#125;&#125; 首页骨架屏https://pub.flutter-io.cn/packages/pk_skeleton lib/pages/main/main.dart 12345678@overrideWidget build(BuildContext context) &#123; return _newsPageList == null ? cardListSkeleton() : EasyRefresh( enableControlFinishRefresh: true, controller: _controller, ... © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 06 代码规范、业务代码组织、新闻首页实现","date":"2020-03-30T16:00:00.000Z","path":"2020/03/31/flutter-project/flutter-project-news-06-main-ui/","text":"1 本节目标 代码规范 业务代码组织 首页代码编写 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.6 2 代码规范2.1 官方代码规范https://dart.dev/guides/language/effective-dart 2.3 chrome 插件 &lt;彩云小译 - 网页翻译插件&gt;https://chrome.google.com/webstore/detail/lingocloud-web-translatio/jmpepeebcbihafjjadogphmbgiffiajh 2.4 阿里项目规范https://github.com/alibaba/flutter-go/blob/master/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md 3 业务界面代码组织3.1 redux、fish-redux redux 架构 fish-redux 架构 进一步的细分，进行规范 https://github.com/alibaba/fish-redux/tree/master/dochttps://medium.com/@dave790602/flutter-architecture-fish-redux-9b753912224a fish-redux 代码 3.2 bloc 架构 https://bloclibrary.dev/#/ 代码组织 3.3 简单就是美 3.4 如何平衡 是否团队开发 是否简单业务（20 页面） 是否重交互（视频社交、聊天 A） 4 新闻首页实现4.1 界面组成分析 分类导航、推荐新闻、频道导航 新闻列表、广告 ad、邮件订阅 4.2 代码框架12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758...class _MainPageState extends State&lt;MainPage&gt; &#123; @override void initState() &#123; super.initState(); _loadAllData(); &#125; // 读取所有数据 _loadAllData() async &#123; &#125; // 分类菜单 Widget _buildCategories() &#123; return Container(); &#125; // 推荐阅读 Widget _buildRecommend() &#123; return Container(); &#125; // 频道 Widget _buildChannels() &#123; return Container(); &#125; // 新闻列表 Widget _buildNewsList() &#123; return Container(); &#125; // ad 广告条 // 邮件订阅 Widget _buildEmailSubscribe() &#123; return newsletterWidget(); &#125; @override Widget build(BuildContext context) &#123; return SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildCategories(), Divider(height: 1), _buildRecommend(), Divider(height: 1), _buildChannels(), Divider(height: 1), _buildNewsList(), Divider(height: 1), _buildEmailSubscribe(), ], ), ); &#125;&#125; 4.3 实现业务 创建 widget 单独文件 分类导航 lib/pages/main/categories_widget.dart 1234567891011121314151617181920212223242526272829303132Widget newsCategoriesWidget(&#123; List&lt;CategoryResponseEntity&gt; categories, String selCategoryCode, Function(CategoryResponseEntity) onTap,&#125;) &#123; return SingleChildScrollView( scrollDirection: Axis.horizontal, child: Row( children: categories.map&lt;Widget&gt;((item) &#123; return Container( alignment: Alignment.center, height: duSetHeight(52), padding: EdgeInsets.symmetric(horizontal: 8), child: GestureDetector( child: Text( item.title, style: TextStyle( color: selCategoryCode == item.code ? AppColors.secondaryElementText : AppColors.primaryText, fontSize: duSetFontSize(18), fontFamily: 'Montserrat', fontWeight: FontWeight.w600, ), ), onTap: () =&gt; onTap(item), ), ); &#125;).toList(), ), );&#125; 频道导航 lib/pages/main/channels_widget.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Widget newsChannelsWidget(&#123; List&lt;ChannelResponseEntity&gt; channels, Function(ChannelResponseEntity) onTap,&#125;) &#123; return Container( height: duSetHeight(137), child: SingleChildScrollView( scrollDirection: Axis.horizontal, child: Row( children: channels.map&lt;Widget&gt;((item) &#123; return Container( width: duSetWidth(70), height: duSetHeight(97), margin: EdgeInsets.symmetric(horizontal: duSetWidth(10)), child: InkWell( child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ // 图标 Container( height: duSetWidth(64), margin: EdgeInsets.symmetric(horizontal: duSetWidth(3)), child: Stack( alignment: Alignment.center, children: [ Positioned( left: 0, top: 0, right: 0, child: Container( height: duSetWidth(64), decoration: BoxDecoration( color: AppColors.primaryBackground, boxShadow: [ Shadows.primaryShadow, ], borderRadius: BorderRadius.all(Radius.circular(32)), ), child: Container(), ), ), Positioned( left: duSetWidth(10), top: duSetWidth(10), right: duSetWidth(10), child: Image.asset( \"assets/images/channel-$&#123;item.code&#125;.png\", fit: BoxFit.none, ), ), ], ), ), // 标题 Text( item.title, textAlign: TextAlign.center, overflow: TextOverflow.clip, maxLines: 1, style: TextStyle( color: AppColors.thirdElementText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(14), height: 1, ), ), ], ), onTap: () =&gt; onTap(item), ), ); &#125;).toList(), ), ), );&#125; 新闻行 Item lib/pages/main/news_item_widget.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Widget newsItem(NewsItem item) &#123; return Container( height: duSetHeight(161), padding: EdgeInsets.all(duSetWidth(20)), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 图 imageCached( item.thumbnail, width: duSetWidth(121), height: duSetWidth(121), ), // 右侧 SizedBox( width: duSetWidth(194), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 作者 Container( margin: EdgeInsets.all(0), child: Text( item.author, style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.thirdElementText, fontSize: duSetFontSize(14), height: 1, ), ), ), // 标题 Container( margin: EdgeInsets.only(top: duSetHeight(10)), child: Text( item.title, style: TextStyle( fontFamily: 'Montserrat', fontWeight: FontWeight.w500, color: AppColors.primaryText, fontSize: duSetFontSize(16), height: 1, ), overflow: TextOverflow.clip, maxLines: 3, ), ), // Spacer Spacer(), // 一行 3 列 Container( child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ // 分类 ConstrainedBox( constraints: BoxConstraints( maxWidth: duSetWidth(60), ), child: Text( item.category, style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.secondaryElementText, fontSize: duSetFontSize(14), height: 1, ), overflow: TextOverflow.clip, maxLines: 1, ), ), // 添加时间 Container( width: duSetWidth(15), ), ConstrainedBox( constraints: BoxConstraints( maxWidth: duSetWidth(100), ), child: Text( '• $&#123;duTimeLineFormat(item.addtime)&#125;', style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.thirdElementText, fontSize: duSetFontSize(14), height: 1, ), overflow: TextOverflow.clip, maxLines: 1, ), ), // 更多 Spacer(), InkWell( child: Icon( Icons.more_horiz, color: AppColors.primaryText, size: 24, ), onTap: () &#123;&#125;, ), ], ), ), ], ), ), ], ), );&#125; 邮件订阅 lib/pages/main/newsletter_widget.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Widget newsletterWidget() &#123; return Container( margin: EdgeInsets.all(duSetWidth(20)), child: Column( children: &lt;Widget&gt;[ // newsletter Row( children: &lt;Widget&gt;[ Text( 'Newsletter', style: TextStyle( fontFamily: 'Montserrat', fontSize: duSetFontSize(18), fontWeight: FontWeight.w600, color: AppColors.thirdElement, ), ), Spacer(), IconButton( icon: Icon( Icons.close, color: AppColors.thirdElementText, size: duSetFontSize(17), ), onPressed: () &#123;&#125;, ), ], ), // email inputEmailEdit( marginTop: 19, keyboardType: TextInputType.emailAddress, hintText: \"Email\", isPassword: false, controller: null, ), // btn subcrible Padding( padding: EdgeInsets.only(top: 15), child: btnFlatButtonWidget( onPressed: () &#123;&#125;, width: duSetWidth(335), height: duSetHeight(44), fontWeight: FontWeight.w600, title: \"Subscribe\", ), ), // disc Container( margin: EdgeInsets.only(top: duSetHeight(29)), width: duSetWidth(261), child: Text.rich(TextSpan(children: &lt;TextSpan&gt;[ TextSpan( text: 'By clicking on Subscribe button you agree to accept', style: new TextStyle( color: AppColors.thirdElementText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(14), ), ), TextSpan( text: ' Privacy Policy', style: new TextStyle( color: AppColors.secondaryElementText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(14), ), recognizer: TapGestureRecognizer() ..onTap = () &#123; toastInfo(msg: 'Privacy Policy'); &#125;, ), ])), ), ], ), );&#125; 推荐阅读 lib/pages/main/recommend_widget.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101Widget recommendWidget(NewsRecommendResponseEntity newsRecommend) &#123; return Container( margin: EdgeInsets.all(duSetWidth(20)), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 图 imageCached( newsRecommend.thumbnail, width: duSetWidth(335), height: duSetHeight(290), ), // 作者 Container( margin: EdgeInsets.only(top: duSetHeight(14)), child: Text( newsRecommend.author, style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.thirdElementText, fontSize: duSetFontSize(14), ), ), ), // 标题 Container( margin: EdgeInsets.only(top: duSetHeight(10)), child: Text( newsRecommend.title, style: TextStyle( fontFamily: 'Montserrat', fontWeight: FontWeight.w600, color: AppColors.primaryText, fontSize: duSetFontSize(24), height: 1, ), ), ), // 一行 3 列 Container( margin: EdgeInsets.only(top: duSetHeight(10)), child: Row( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ // 分类 ConstrainedBox( constraints: const BoxConstraints( maxWidth: 120, ), child: Text( newsRecommend.category, style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.secondaryElementText, fontSize: duSetFontSize(14), height: 1, ), overflow: TextOverflow.clip, maxLines: 1, ), ), // 添加时间 Container( width: duSetWidth(15), ), ConstrainedBox( constraints: const BoxConstraints( maxWidth: 120, ), child: Text( '• $&#123;duTimeLineFormat(newsRecommend.addtime)&#125;', style: TextStyle( fontFamily: 'Avenir', fontWeight: FontWeight.normal, color: AppColors.thirdElementText, fontSize: duSetFontSize(14), height: 1, ), overflow: TextOverflow.clip, maxLines: 1, ), ), // 更多 Spacer(), InkWell( child: Icon( Icons.more_horiz, color: AppColors.primaryText, size: 24, ), onTap: () &#123;&#125;, ), ], ), ), ], ), );&#125; 蓝湖设计稿https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat YAPI 接口管理http://yapi.demo.qunar.com/ 参考 Flutter Go 代码开发规范 0.1.0 版 effective-dart bloc VSCode 插件 Flutter、Dart Flutter Widget Snippets Awesome Flutter Snippets Paste JSON as Code bloc 视频 b 站 油管镜像 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 05 AppData、Cache、Fiddle、iconfont、主界面搭建","date":"2020-03-24T16:00:00.000Z","path":"2020/03/25/flutter-project/flutter-project-news-05-cache-iconfont/","text":"本节目标 全局数据、响应数据、持久化 http get 缓存 http proxy 代理 fiddle 抓包工具 iconfont 字体库 主界面搭建 BottomNavigationBar 导航控件 编写 api 接口代码 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.5 客户端数据管理数据类型 全局数据 存储在内存 用户数据、语言包 响应数据 存储在内存 用户登录状态、多语言、皮肤样式 Redux、Bloc、provider 持久化 APP 保持磁盘上 浏览器 cookie localStorage 编写全局管理 lib/global.dart 123456789101112131415161718192021222324252627282930313233343536373839404142/// 全局配置class Global &#123; /// 用户配置 static UserLoginResponseEntity profile = UserLoginResponseEntity( accessToken: null, ); /// 是否 release static bool get isRelease =&gt; bool.fromEnvironment(\"dart.vm.product\"); /// init static Future init() async &#123; // 运行初始 WidgetsFlutterBinding.ensureInitialized(); // 工具初始 await StorageUtil.init(); HttpUtil(); // 读取离线用户信息 var _profileJSON = StorageUtil().getJSON(STORAGE_USER_PROFILE_KEY); if (_profileJSON != null) &#123; profile = UserLoginResponseEntity.fromJson(_profileJSON); &#125; // http 缓存 // android 状态栏为透明的沉浸 if (Platform.isAndroid) &#123; SystemUiOverlayStyle systemUiOverlayStyle = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(systemUiOverlayStyle); &#125; &#125; // 持久化 用户信息 static Future&lt;bool&gt; saveProfile(UserLoginResponseEntity userResponse) &#123; profile = userResponse; return StorageUtil() .setJSON(STORAGE_USER_PROFILE_KEY, userResponse.toJson()); &#125;&#125; 调用运行 lib/main.dart 12345678void main() =&gt; Global.init().then((e) =&gt; runApp(MyApp()));class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container(); &#125;&#125; Http 内存缓存缓存策略 代码 缓存工具类 lib/common/utils/net_cache.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import 'dart:collection';import 'package:dio/dio.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';class CacheObject &#123; CacheObject(this.response) : timeStamp = DateTime.now().millisecondsSinceEpoch; Response response; int timeStamp; @override bool operator ==(other) &#123; return response.hashCode == other.hashCode; &#125; @override int get hashCode =&gt; response.realUri.hashCode;&#125;class NetCache extends Interceptor &#123; // 为确保迭代器顺序和对象插入时间一致顺序一致，我们使用LinkedHashMap var cache = LinkedHashMap&lt;String, CacheObject&gt;(); @override onRequest(RequestOptions options) async &#123; if (!CACHE_ENABLE) return options; // refresh标记是否是\"下拉刷新\" bool refresh = options.extra[\"refresh\"] == true; // 如果是下拉刷新，先删除相关缓存 if (refresh) &#123; if (options.extra[\"list\"] == true) &#123; //若是列表，则只要url中包含当前path的缓存全部删除（简单实现，并不精准） cache.removeWhere((key, v) =&gt; key.contains(options.path)); &#125; else &#123; // 如果不是列表，则只删除uri相同的缓存 delete(options.uri.toString()); &#125; return options; &#125; // get 请求，开启缓存 if (options.extra[\"noCache\"] != true &amp;&amp; options.method.toLowerCase() == 'get') &#123; String key = options.extra[\"cacheKey\"] ?? options.uri.toString(); var ob = cache[key]; if (ob != null) &#123; //若缓存未过期，则返回缓存内容 if ((DateTime.now().millisecondsSinceEpoch - ob.timeStamp) / 1000 &lt; CACHE_MAXAGE) &#123; return cache[key].response; &#125; else &#123; //若已过期则删除缓存，继续向服务器请求 cache.remove(key); &#125; &#125; &#125; &#125; @override onError(DioError err) async &#123; // 错误状态不缓存 &#125; @override onResponse(Response response) async &#123; // 如果启用缓存，将返回结果保存到缓存 if (CACHE_ENABLE) &#123; _saveCache(response); &#125; &#125; _saveCache(Response object) &#123; RequestOptions options = object.request; // 只缓存 get 的请求 if (options.extra[\"noCache\"] != true &amp;&amp; options.method.toLowerCase() == \"get\") &#123; // 如果缓存数量超过最大数量限制，则先移除最早的一条记录 if (cache.length == CACHE_MAXCOUNT) &#123; cache.remove(cache[cache.keys.first]); &#125; String key = options.extra[\"cacheKey\"] ?? options.uri.toString(); cache[key] = CacheObject(object); &#125; &#125; void delete(String key) &#123; cache.remove(key); &#125;&#125; dio 封装 lib/common/utils/http.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 加内存缓存HttpUtil._internal() &#123; ... dio.interceptors.add(NetCache()); ...&#125;// 修改 get 请求/// restful get 操作/// refresh 是否下拉刷新 默认 false/// noCache 是否不缓存 默认 true/// list 是否列表 默认 false/// cacheKey 缓存keyFuture get( String path, &#123; dynamic params, Options options, bool refresh = false, bool noCache = !CACHE_ENABLE, bool list = false, String cacheKey,&#125;) async &#123; try &#123; Options requestOptions = options ?? Options(); requestOptions = requestOptions.merge(extra: &#123; \"refresh\": refresh, \"noCache\": noCache, \"list\": list, \"cacheKey\": cacheKey, &#125;); Map&lt;String, dynamic&gt; _authorization = getAuthorizationHeader(); if (_authorization != null) &#123; requestOptions = requestOptions.merge(headers: _authorization); &#125; var response = await dio.get(path, queryParameters: params, options: requestOptions, cancelToken: cancelToken); return response.data; &#125; on DioError catch (e) &#123; throw createErrorEntity(e); &#125;&#125; Http Proxy 代理 + Fiddle 抓包安装 Fiddlehttps://www.telerik.com/download/fiddler-everywhere dio 加入 proxy lib/common/utils/http.dart 1234567891011if (!Global.isRelease &amp;&amp; PROXY_ENABLE) &#123; (dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) &#123; client.findProxy = (uri) &#123; return \"PROXY $PROXY_IP:$PROXY_PORT\"; &#125;; //代理工具会提供一个抓包的自签名证书，会通不过证书校验，所以我们禁用证书校验 client.badCertificateCallback = (X509Certificate cert, String host, int port) =&gt; true; &#125;;&#125; Iconfont 字体库引入流程 登录 https://www.iconfont.cn 创建字体项目 字体文件放入 assets/fonts/iconfont.ttf pubspec.yaml 12345fonts: ... - family: Iconfont fonts: - asset: assets/fonts/iconfont.ttf lib/common/utils/iconfont.dart 123456789101112import 'package:flutter/material.dart';class Iconfont &#123; // iconName: share static const share = IconData( 0xe60d, fontFamily: 'Iconfont', matchTextDirection: true, ); ...&#125; 自动生成字体库代码https://github.com/ymzuiku/iconfont_builder 拉取项目、编译 1234567891011# 拉取项目&gt; git clone https://github.com/ymzuiku/iconfont_builder# 更新包&gt; pub get# 安装工具&gt; pub global activate iconfont_builder# 检查环境配置export PATH=$&#123;PATH&#125;:~/.pub-cache/bin 参考我的配置 123456789101112131415# flutter sdkexport PATH=$&#123;PATH&#125;:~/Documents/sdk/flutter/bin# dart sdkexport PATH=$&#123;PATH&#125;:~/Documents/sdk/flutter/bin/cache/dart-sdk/binexport PATH=$&#123;PATH&#125;:~/.pub-cache/bin# flutter-io 国内镜像export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn# androidexport ANDROID_HOME=~/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/tools 生成字体类 12cd 你的项目根目录iconfont_builder --from ./assets/fonts --to ./lib/common/utils/iconfont.dart 编写 api 业务代码 yapi 配置 导入 doc/api.json 代码 搭建主界面框架 框架页面 lib/pages/application/application.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152...class _ApplicationPageState extends State&lt;ApplicationPage&gt; with SingleTickerProviderStateMixin &#123; // 当前 tab 页码 int _page = 0; // tab 页标题 final List&lt;String&gt; _tabTitles = [ 'Welcome', 'Cagegory', 'Bookmarks', 'Account' ]; // 页控制器 PageController _pageController; // 底部导航项目 final List&lt;BottomNavigationBarItem&gt; _bottomTabs = &lt;BottomNavigationBarItem&gt;[...]; // tab栏动画 void _handleNavBarTap(int index) &#123; ... &#125; // tab栏页码切换 void _handlePageChanged(int page) &#123; ... &#125; // 顶部导航 Widget _buildAppBar() &#123; return Container(); &#125; // 内容页 Widget _buildPageView() &#123; return Container(); &#125; // 底部导航 Widget _buildBottomNavigationBar() &#123; return Container(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: _buildAppBar(), body: _buildPageView(), bottomNavigationBar: _buildBottomNavigationBar(), ); &#125;&#125; 编写首页代码 首页代码 lib/pages/main/main.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263...class _MainPageState extends State&lt;MainPage&gt; &#123; NewsPageListResponseEntity _newsPageList; // 新闻翻页 NewsRecommendResponseEntity _newsRecommend; // 新闻推荐 List&lt;CategoryResponseEntity&gt; _categories; // 分类 List&lt;ChannelResponseEntity&gt; _channels; // 频道 String _selCategoryCode; // 选中的分类Code @override void initState() &#123; super.initState(); _loadAllData(); &#125; // 读取所有数据 _loadAllData() async &#123; ... &#125; // 分类菜单 Widget _buildCategories() &#123; return Container(); &#125; // 抽取前先实现业务 // 推荐阅读 Widget _buildRecommend() &#123; return Container(); &#125; // 频道 Widget _buildChannels() &#123; return Container(); &#125; // 新闻列表 Widget _buildNewsList() &#123; return Container(); &#125; // ad 广告条 // 邮件订阅 Widget _buildEmailSubscribe() &#123; return Container(); &#125; @override Widget build(BuildContext context) &#123; return SingleChildScrollView( child: Column( children: &lt;Widget&gt;[ _buildCategories(), _buildRecommend(), _buildChannels(), _buildNewsList(), _buildEmailSubscribe(), ], ), ); &#125;&#125; 抽取新闻分类 lib/pages/main/categories_widget.dart 123456789101112131415161718192021222324252627282930313233Widget newsCategoriesWidget( &#123;List&lt;CategoryResponseEntity&gt; categories, String selCategoryCode, Function(CategoryResponseEntity) onTap&#125;) &#123; return categories == null ? Container() : SingleChildScrollView( scrollDirection: Axis.horizontal, child: Row( children: categories.map&lt;Widget&gt;((item) &#123; return Container( alignment: Alignment.center, height: duSetHeight(52), padding: EdgeInsets.symmetric(horizontal: 8), child: GestureDetector( child: Text( item.title, style: TextStyle( color: selCategoryCode == item.code ? AppColors.secondaryElementText : AppColors.primaryText, fontSize: duSetFontSize(18), fontFamily: 'Montserrat', fontWeight: FontWeight.w600, ), ), onTap: () =&gt; onTap(item), ), ); &#125;).toList(), ), );&#125; 蓝湖设计稿https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat YAPI 接口管理http://yapi.demo.qunar.com/ 工具 json to object quicktype Fiddler 抓包 iconfont 阿里图标库 Iconfont 生成工具 VSCode 插件 Flutter、Dart Flutter Widget Snippets Awesome Flutter Snippets Paste JSON as Code bloc 视频 b 站 油管镜像 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 04 YAPI接口管理、RESTful、生成代码、dio封装","date":"2020-03-15T16:00:00.000Z","path":"2020/03/16/flutter-project/flutter-project-news-04-entity-http/","text":"本节目标 前后端分离、契约开发模式 API 接口管理、工具 RESTful 接口规范 TOKEN 安全通讯 自动生成 entity 接口实体类 dio 封装 localstorage 本地存储 密码加密 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.4 1. 接口管理1.1 前后端分离、契约模式 1.2 常见接口管理工具 yapihttps://github.com/YMFE/yapi easymockhttps://github.com/easy-mock/easy-mock RAP2https://github.com/thx/RAP swaggerhttps://swagger.io/ 1.3 yapi 接口管理工具（猫哥推荐）http://yapi.demo.qunar.com/ 输入 输出 1.4 mock 模拟数据 1.5 单元测试 1.6 swagger 导入 2. restful 接口风格 REST wiki 理解 RESTful 架构 阮一峰 RESTful API 设计指南 阮一峰 RESTful API 最佳实践 阮一峰 RESTful 架构详解 2.1 http 操作方式 GET 取数据 POST 新建数据 PUT 更新全部数据 PATCH 更新部分数据 DELETE 删除数据 例子:12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 2.2 state 状态控制 200 OK 400 错误的请求，比如数据结构不对 401 需要登录认证 403 已登录，但是当前资源没有授权 404 找不到，地址错误 500 服务程序错误 502 服务网关错误 503 服务挂了 504 服务网关超时 2.3 优秀实践 Github REST API v3 3. token 安全通讯3.1 基于令牌的安全机制 流程 思路 3.2 Bearer Type Access Token在通讯 HTTP HEADER 头中加入 123GET /resource HTTP/1.1Host: server.example.comAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 3.3 JWT https://jwt.io/ JSON Web Token 入门教程 4. 自动生成 entity4.1 json_serializable （官方） https://pub.dev/packages/json_serializable 4.2 json to code （猫哥推荐） https://app.quicktype.io/ vscode 插件 https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype 5. dio 封装5.1 单例模式 dio https://pub.dev/packages/dio lib/common/utils/http.dart 单例常见封装方式 123456789class HttpUtil &#123; static HttpUtil _instance = HttpUtil._internal(); factory HttpUtil() =&gt; _instance; Dio dio; CancelToken cancelToken = new CancelToken(); HttpUtil._internal() &#123; ... 5.2 维护 token从本地 storage 中读取 localstorage https://pub.flutter-io.cn/packages/localstorage getLocalOptions() 12345678910Options getLocalOptions() &#123; Options options; String token = StorageUtil().getItem(STORAGE_USER_TOKEN_KEY); if (token != null) &#123; options = Options(headers: &#123; 'Authorization': 'Bearer $token', &#125;); &#125; return options;&#125; 5.3 处理异常格式化，错误信息，进行差别对待 createErrorEntity() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192ErrorEntity createErrorEntity(DioError error) &#123; switch (error.type) &#123; case DioErrorType.CANCEL: &#123; return ErrorEntity(code: -1, message: \"请求取消\"); &#125; break; case DioErrorType.CONNECT_TIMEOUT: &#123; return ErrorEntity(code: -1, message: \"连接超时\"); &#125; break; case DioErrorType.SEND_TIMEOUT: &#123; return ErrorEntity(code: -1, message: \"请求超时\"); &#125; break; case DioErrorType.RECEIVE_TIMEOUT: &#123; return ErrorEntity(code: -1, message: \"响应超时\"); &#125; break; case DioErrorType.RESPONSE: &#123; try &#123; int errCode = error.response.statusCode; // String errMsg = error.response.statusMessage; // return ErrorEntity(code: errCode, message: errMsg); switch (errCode) &#123; case 400: &#123; return ErrorEntity(code: errCode, message: \"请求语法错误\"); &#125; break; case 401: &#123; return ErrorEntity(code: errCode, message: \"没有权限\"); &#125; break; case 403: &#123; return ErrorEntity(code: errCode, message: \"服务器拒绝执行\"); &#125; break; case 404: &#123; return ErrorEntity(code: errCode, message: \"无法连接服务器\"); &#125; break; case 405: &#123; return ErrorEntity(code: errCode, message: \"请求方法被禁止\"); &#125; break; case 500: &#123; return ErrorEntity(code: errCode, message: \"服务器内部错误\"); &#125; break; case 502: &#123; return ErrorEntity(code: errCode, message: \"无效的请求\"); &#125; break; case 503: &#123; return ErrorEntity(code: errCode, message: \"服务器挂了\"); &#125; break; case 505: &#123; return ErrorEntity(code: errCode, message: \"不支持HTTP协议请求\"); &#125; break; default: &#123; // return ErrorEntity(code: errCode, message: \"未知错误\"); return ErrorEntity( code: errCode, message: error.response.statusMessage); &#125; &#125; &#125; on Exception catch (_) &#123; return ErrorEntity(code: -1, message: \"未知错误\"); &#125; &#125; break; default: &#123; return ErrorEntity(code: -1, message: error.message); &#125; &#125;&#125; 6. 登录调用6.1 编写 api 接口 lib/common/apis/user.dart 1234567891011import 'package:flutter_ducafecat_news/common/entitys/entitys.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';/// 用户class UserAPI &#123; /// 登录 static Future&lt;UserResponseEntity&gt; login(&#123;UserRequestEntity params&#125;) async &#123; var response = await HttpUtil().post('/user/login', params: params); return UserResponseEntity.fromJson(response); &#125;&#125; 6.2 密码加密 crypto https://pub.dev/packages/crypto lib/common/utils/security.dart 1234567891011import 'dart:convert';import 'package:crypto/crypto.dart';/// SHA256String duSHA256(String input) &#123; String salt = 'EIpWsyfiy@R@X#qn17!StJNdZK1fFF8iV6ffN!goZkqt#JxO'; // 加盐 var bytes = utf8.encode(input + salt); var digest = sha256.convert(bytes); return digest.toString();&#125; 6.3 调用接口 lib/pages/sign_in/sign_in.dart 123456789101112131415161718192021// 执行登录操作_handleSignIn() async &#123; if (!duIsEmail(_emailController.value.text)) &#123; toastInfo(msg: '请正确输入邮件'); return; &#125; if (!duCheckStringLength(_passController.value.text, 6)) &#123; toastInfo(msg: '密码不能小于6位'); return; &#125; UserRequestEntity params = UserRequestEntity( email: _emailController.value.text, password: duSHA256(_passController.value.text), ); UserResponseEntity res = await UserAPI.login(params: params); // 写本地 access_token , 不写全局，业务：离线登录 // 全局数据 gUser&#125; YAPI 接口管理http://yapi.demo.qunar.com/ 蓝湖设计稿https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat 参考 RESTful REST wiki 理解 RESTful 架构 阮一峰 RESTful API 设计指南 阮一峰 RESTful API 最佳实践 阮一峰 RESTful 架构详解 Flutter packages localstorage json_serializable dio crypto VSCode 插件 Awesome Flutter Snippets Paste JSON as Code 视频 b 站 油管镜像 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 03 静态路由、组件抽取、登录注册界面","date":"2020-03-11T16:00:00.000Z","path":"2020/03/12/flutter-project/flutter-project-news-03-sign-in-up/","text":"本节目标 静态路由 带阴影的椭圆图标 输入有效性校验 组件抽取方法 通用组件、业务组件 程序目录组织 抽取透明导航栏 toast 提示组件 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.3 1 静态路由1.1 定义静态路由 登录页 lib/pages/sign_in/sign_in.dart 注册页 lib/pages/sign_up/sign_up.dart 静态路由 lib/routes.dart 12345678import 'package:flutter_ducafecat_news/pages/sign_in/sign_in.dart';import 'package:flutter_ducafecat_news/pages/sign_up/sign_up.dart';/// 静态路由var staticRoutes = &#123; \"/sign-in\": (context) =&gt; SignInPage(), // 登录 \"/sign-up\": (context) =&gt; SignUpPage(), // 注册&#125;; 1.2 注册静态路由 lib/main.dart 1234567891011121314151617import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/pages/welcome/welcome.dart';import 'package:flutter_ducafecat_news/routes.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'ducafecat.tech', home: WelcomePage(), routes: staticRoutes, debugShowCheckedModeBanner: false, ); &#125;&#125; 2 登录界面2.1 维护色彩常量 lib/common/values/colors.dart 12345678910111213141516171819202122232425262728import 'dart:ui';class AppColors &#123; /// 主背景 白色 static const Color primaryBackground = Color.fromARGB(255, 255, 255, 255); /// 主文本 灰色 static const Color primaryText = Color.fromARGB(255, 45, 45, 47); /// 主控件-背景 蓝色 static const Color primaryElement = Color.fromARGB(255, 41, 103, 255); /// 主控件-文本 白色 static const Color primaryElementText = Color.fromARGB(255, 255, 255, 255); // ***************************************** /// 第二种控件-背景色 淡灰色 static const Color secondaryElement = Color.fromARGB(255, 246, 246, 246); /// 第二种控件-文本 浅蓝色 static const Color secondaryElementText = Color.fromARGB(255, 41, 103, 255); // ***************************************** /// 第三种控件-背景色 石墨色 static const Color thirdElement = Color.fromARGB(255, 45, 45, 47);&#125; 2.2 程序结构 lib/pages/sign_in/sign_in.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';import 'package:flutter_ducafecat_news/common/widgets/widgets.dart';class SignInPage extends StatefulWidget &#123; SignInPage(&#123;Key key&#125;) : super(key: key); @override _SignInPageState createState() =&gt; _SignInPageState();&#125;class _SignInPageState extends State&lt;SignInPage&gt; &#123; // logo Widget _buildLogo() &#123; return Container(); &#125; // 登录表单 Widget _buildInputForm() &#123; return Container(); &#125; // 第三方登录 Widget _buildThirdPartyLogin() &#123; return Container(); &#125; // 注册按钮 Widget _buildSignupButton() &#123; return Container(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( resizeToAvoidBottomInset: false, body: Center( child: Column( children: &lt;Widget&gt;[ _buildLogo(), _buildInputForm(), Spacer(), _buildThirdPartyLogin(), _buildSignupButton(), ], ), ), ); &#125;&#125; 2.3 画带阴影的椭圆图标 lib/pages/sign_in/sign_in.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// logoWidget _buildLogo() &#123; return Container( width: duSetWidth(110), margin: EdgeInsets.only(top: duSetHeight(40 + 44.0)), // 顶部系统栏 44px child: Column( crossAxisAlignment: CrossAxisAlignment.stretch, children: [ Container( height: duSetWidth(76), width: duSetWidth(76), margin: EdgeInsets.symmetric(horizontal: duSetWidth(15)), child: Stack( alignment: Alignment.center, children: [ Positioned( left: 0, top: 0, right: 0, child: Container( height: duSetWidth(76), decoration: BoxDecoration( color: AppColors.primaryBackground, boxShadow: [ Shadows.primaryShadow, ], borderRadius: BorderRadius.all( Radius.circular(duSetWidth(76 * 0.5))), // 父容器的50% ), child: Container(), ), ), Positioned( top: duSetWidth(13), child: Image.asset( \"assets/images/logo.png\", fit: BoxFit.none, ), ), ], ), ), Container( margin: EdgeInsets.only(top: duSetHeight(15)), child: Text( \"SECTOR\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Montserrat\", fontWeight: FontWeight.w600, fontSize: duSetFontSize(24), height: 1, ), ), ), Text( \"news\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(16), height: 1, ), ), ], ), );&#125; 2.4 抽取输入框 lib/common/widgets/input.dart 1234567891011121314151617181920212223242526272829303132333435/// 输入框Widget inputTextEdit(&#123; @required TextEditingController controller, TextInputType keyboardType = TextInputType.text, String hintText, bool isPassword = false, double marginTop = 15,&#125;) &#123; return Container( height: duSetHeight(44), margin: EdgeInsets.only(top: duSetHeight(marginTop)), decoration: BoxDecoration( color: AppColors.secondaryElement, borderRadius: Radii.k6pxRadius, ), child: TextField( controller: controller, keyboardType: keyboardType, decoration: InputDecoration( hintText: hintText, contentPadding: EdgeInsets.fromLTRB(20, 10, 0, 9), border: InputBorder.none, ), style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(18), ), maxLines: 1, autocorrect: false, // 自动纠正 obscureText: isPassword, // 隐藏输入内容, 密码框 ), );&#125; 2.5 抽取扁平按钮 lib/common/widgets/button.dart 1234567891011121314151617181920212223242526272829303132333435/// 扁平圆角按钮Widget btnFlatButtonWidget(&#123; @required VoidCallback onPressed, double width = 140, double height = 44, Color gbColor = AppColors.primaryElement, String title = \"button\", Color fontColor = AppColors.primaryElementText, double fontSize = 18, String fontName = \"Montserrat\", FontWeight fontWeight = FontWeight.w400,&#125;) &#123; return Container( width: duSetWidth(width), height: duSetHeight(height), child: FlatButton( onPressed: onPressed, color: gbColor, shape: RoundedRectangleBorder( borderRadius: Radii.k6pxRadius, ), child: Text( title, textAlign: TextAlign.center, style: TextStyle( color: fontColor, fontFamily: fontName, fontWeight: fontWeight, fontSize: duSetFontSize(fontSize), height: 1, ), ), ), );&#125; 2.6 抽取社交登录按钮 lib/common/widgets/button.dart 12345678910111213141516171819202122/// 第三方按钮Widget btnFlatButtonBorderOnlyWidget(&#123; @required VoidCallback onPressed, double width = 88, double height = 44, String iconFileName,&#125;) &#123; return Container( width: duSetWidth(width), height: duSetHeight(height), child: FlatButton( onPressed: onPressed, shape: RoundedRectangleBorder( side: Borders.primaryBorder, borderRadius: Radii.k6pxRadius, ), child: Image.asset( \"assets/images/icons-$iconFileName.png\", ), ), );&#125; 2.7 封装 toast 提示框 lib/common/widgets/toast.dart 123456789101112131415Future&lt;bool&gt; toastInfo(&#123; @required String msg, Color backgroundColor = Colors.black, Color textColor = Colors.white,&#125;) async &#123; return await Fluttertoast.showToast( msg: msg, toastLength: Toast.LENGTH_SHORT, gravity: ToastGravity.TOP, timeInSecForIos: 1, backgroundColor: backgroundColor, textColor: textColor, fontSize: duSetFontSize(16), );&#125; 2.8 数据有效性检验 lib/pages/sign_in/sign_in.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293...class _SignInPageState extends State&lt;SignInPage&gt; &#123; //email的控制器 final TextEditingController _emailController = TextEditingController(); //密码的控制器 final TextEditingController _passController = TextEditingController();... // 执行登录操作 _handleSignIn() &#123; if (!duIsEmail(_emailController.value.text)) &#123; toastInfo(msg: '请正确输入邮件'); return; &#125; if (!duCheckStringLength(_passController.value.text, 6)) &#123; toastInfo(msg: '密码不能小于6位'); return; &#125; &#125;... // 登录表单 Widget _buildInputForm() &#123; return Container( width: duSetWidth(295), // height: 204, margin: EdgeInsets.only(top: duSetHeight(49)), child: Column( children: [ // email input inputTextEdit( controller: _emailController, keyboardType: TextInputType.emailAddress, hintText: \"Email\", marginTop: 0, ), // password input inputTextEdit( controller: _passController, keyboardType: TextInputType.visiblePassword, hintText: \"Password\", isPassword: true, ), // 注册、登录 横向布局 Container( height: duSetHeight(44), margin: EdgeInsets.only(top: duSetHeight(15)), child: Row( children: [ // 注册 btnFlatButtonWidget( onPressed: _handleNavSignUp, gbColor: AppColors.thirdElement, title: \"Sign up\", ), Spacer(), // 登录 btnFlatButtonWidget( onPressed: _handleSignIn, gbColor: AppColors.primaryElement, title: \"Sign in\", ), ], ), ), // Spacer(), // Fogot password Container( height: duSetHeight(22), margin: EdgeInsets.only(top: duSetHeight(20)), child: FlatButton( onPressed: () =&gt; &#123;&#125;, child: Text( \"Fogot password?\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.secondaryElementText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(16), height: 1, // 设置下行高，否则字体下沉 ), ), ), ), ], ), ); &#125; 3 注册界面3.1 程序结构 lib/pages/sign_up/sign_up.dart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';import 'package:flutter_ducafecat_news/common/utils/utils.dart';import 'package:flutter_ducafecat_news/common/values/values.dart';import 'package:flutter_ducafecat_news/common/widgets/widgets.dart';class SignUpPage extends StatefulWidget &#123; SignUpPage(&#123;Key key&#125;) : super(key: key); @override _SignUpPageState createState() =&gt; _SignUpPageState();&#125;class _SignUpPageState extends State&lt;SignUpPage&gt; &#123; // logo Widget _buildLogo() &#123; return Container(); &#125; // 注册表单 Widget _buildInputForm() &#123; return Container(); &#125; // 第三方 Widget _buildThirdPartyLogin() &#123; return Container(); &#125; // 有账号 Widget _buildHaveAccountButton() &#123; return Container(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( resizeToAvoidBottomInset: false, ..., body: Center( child: Column( children: &lt;Widget&gt;[ Divider(height: 1), _buildLogo(), _buildInputForm(), Spacer(), _buildThirdPartyLogin(), _buildHaveAccountButton(), ], ), ), ); &#125;&#125; 3.2 透明导航栏 lib/common/widgets/app.dart 123456789101112131415161718192021/// 透明背景 AppBarWidget transparentAppBar(&#123; @required BuildContext context, List&lt;Widget&gt; actions,&#125;) &#123; return AppBar( backgroundColor: Colors.transparent, elevation: 0, title: Text(''), leading: IconButton( icon: Icon( Icons.arrow_back, color: AppColors.primaryText, ), onPressed: () &#123; Navigator.pop(context); &#125;, ), actions: actions, );&#125; lib/pages/sign_up/sign_up.dart 123456789101112131415161718@overrideWidget build(BuildContext context) &#123; return Scaffold( resizeToAvoidBottomInset: false, appBar: transparentAppBar( context: context, actions: &lt;Widget&gt;[ IconButton( icon: Icon( Icons.info_outline, color: AppColors.primaryText, ), onPressed: () &#123; toastInfo(msg: '这是注册界面'); &#125;, ) ], ), 3.2 注册表单 lib/pages/sign_up/sign_up.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 注册表单Widget _buildInputForm() &#123; return Container( width: duSetWidth(295), // height: 204, margin: EdgeInsets.only(top: duSetHeight(49)), child: Column( children: [ // fullName input inputTextEdit( controller: _fullnameController, keyboardType: TextInputType.text, hintText: \"Full name\", marginTop: 0, ), // email input inputTextEdit( controller: _emailController, keyboardType: TextInputType.emailAddress, hintText: \"Email\", ), // password input inputTextEdit( controller: _passController, keyboardType: TextInputType.visiblePassword, hintText: \"Password\", isPassword: true, ), // 创建 Container( height: duSetHeight(44), margin: EdgeInsets.only(top: duSetHeight(15)), child: btnFlatButtonWidget( onPressed: () &#123; if (!duCheckStringLength(_fullnameController.value.text, 5)) &#123; toastInfo(msg: '用户名不能小于5位'); return; &#125; if (!duIsEmail(_emailController.value.text)) &#123; toastInfo(msg: '请正确输入邮件'); return; &#125; if (!duCheckStringLength(_passController.value.text, 6)) &#123; toastInfo(msg: '密码不能小于6位'); return; &#125; Navigator.pop(context); &#125;, width: 295, fontWeight: FontWeight.w600, title: \"Create an account\", ), ), // Spacer(), // Fogot password Container( height: duSetHeight(22), margin: EdgeInsets.only(top: duSetHeight(20)), child: FlatButton( onPressed: _handleSignUp, child: Text( \"Fogot password?\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.secondaryElementText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(16), height: 1, // 设置下行高，否则字体下沉 ), ), ), ), ], ), );&#125; 3.3 检验有效性 lib/pages/sign_up/sign_in.dart 12345678910111213141516// 执行注册操作_handleSignUp() &#123; if (!duCheckStringLength(_fullnameController.value.text, 5)) &#123; toastInfo(msg: '用户名不能小于5位'); return; &#125; if (!duIsEmail(_emailController.value.text)) &#123; toastInfo(msg: '请正确输入邮件'); return; &#125; if (!duCheckStringLength(_passController.value.text, 6)) &#123; toastInfo(msg: '密码不能小于6位'); return; &#125; Navigator.pop(context);&#125; 3.4 社交按钮 lib/pages/sign_up/sign_up.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 第三方Widget _buildThirdPartyLogin() &#123; return Container( width: duSetWidth(295), margin: EdgeInsets.only(bottom: duSetHeight(40)), child: Column( children: &lt;Widget&gt;[ // title Text( \"Or sign in with social networks\", textAlign: TextAlign.center, style: TextStyle( color: AppColors.primaryText, fontFamily: \"Avenir\", fontWeight: FontWeight.w400, fontSize: duSetFontSize(16), ), ), // 按钮 Padding( padding: EdgeInsets.only(top: duSetHeight(20)), child: Row( children: &lt;Widget&gt;[ btnFlatButtonBorderOnlyWidget( onPressed: () &#123;&#125;, width: 88, iconFileName: \"twitter\", ), Spacer(), btnFlatButtonBorderOnlyWidget( onPressed: () &#123;&#125;, width: 88, iconFileName: \"google\", ), Spacer(), btnFlatButtonBorderOnlyWidget( onPressed: () &#123;&#125;, width: 88, iconFileName: \"facebook\", ), ], ), ), ], ), );&#125; 3.5 返回按钮 lib/pages/sign_up/sign_up.dart 12345678910111213141516171819// 返回上一页_handleNavPop() &#123; Navigator.pop(context);&#125;Widget _buildHaveAccountButton() &#123; return Container( margin: EdgeInsets.only(bottom: duSetHeight(20)), child: btnFlatButtonWidget( onPressed: _handleNavPop, width: 294, gbColor: AppColors.secondaryElement, fontColor: AppColors.primaryText, title: \"I have an account\", fontWeight: FontWeight.w500, fontSize: 16, ), );&#125; 蓝湖设计稿https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat 参考 widgets fluttertoast 视频 b 站 油管镜像 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 02 设计稿适配、加入图片字体资源、欢迎界面","date":"2020-02-26T16:00:00.000Z","path":"2020/02/27/flutter-project/flutter-project-news-02-weclome/","text":"本节目标 加入图片资源 加入字体资源 设计稿适配 编写界面代码的逻辑和组织 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.2 1 加入图片资源1.1 flutter 图片资源规则 官方说明 https://flutter.dev/docs/development/ui/assets-and-images 按这个规则编排，flutter 自动适配分辨率图片 assets 目录 yaml 配置 12assets: - assets/images/ 代码调用 1Image.asset(\"assets/images/logo.png\") 1.2 蓝湖切图 注意选着下 ios 目标，这样会自动切图 1x 2x 3x 三种格式 2 加入字体资源 官方说明 https://flutter.dev/docs/cookbook/design/fonts assets 目录 只上传用到的 ttf 字体，这样能控制打包大小 yaml 配置 123456789fonts: - family: Avenir fonts: - asset: assets/fonts/Avenir-Book.ttf weight: 400 - family: Montserrat fonts: - asset: assets/fonts/Montserrat-SemiBold.ttf weight: 600 代码调用 3 编写欢迎界面3.1 从上到下、从左到右、由大到小 3.2 设计稿适配插件 flutter_screenutil https://pub.flutter-io.cn/packages/flutter_screenutil 按设计稿比例适配 3.3 工具函数 screen.dart 设计稿适配函数 12345678910111213141516import 'package:flutter_screenutil/flutter_screenutil.dart';/// 设置宽度double duSetWidth(double width) &#123; return ScreenUtil().setWidth(width);&#125;/// 设置宽度double duSetHeight(double height) &#123; return ScreenUtil().setHeight(height);&#125;/// 设置字体尺寸double duSetFontSize(double fontSize) &#123; return ScreenUtil().setSp(fontSize);&#125; utils.dart 导出类库 123library utils;export 'screen.dart'; 3.4 常量配置 colors.dart 颜色 123456789101112import 'dart:ui';class AppColors &#123; /// 主文本 static const Color primaryText = Color.fromARGB(255, 45, 45, 47); /// 主控件-背景 static const Color primaryElement = Color.fromARGB(255, 41, 103, 255); /// 主控件-文本 static const Color primaryElementText = Color.fromARGB(255, 255, 255, 255);&#125; values.dart 导出类库 123library values;export 'colors.dart'; 3.5 代码拆分 尽可能的拆分到不同的函数，方便维护 再复杂的业务，可以拆分到不同的组件文件，如 welcome_header_widget.dart welcome_feature_widget.dart welcome_buttons_widget.dart git 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.1 蓝湖设计稿https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat 视频 b 站 油管镜像 参考 flutter_screenutil Adding assets and images Use a custom font © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 实战从零开始 新闻客户端 - 01 需求分析、使用蓝湖标注工具、项目目录构建","date":"2020-02-25T16:00:00.000Z","path":"2020/02/26/flutter-project/flutter-project-news-01-setup/","text":"本节目标 需求分析 使用蓝湖平台作为标注工具 构建 Flutter 项目 视频 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.1 1 需求说明 1.1 样式表 颜色 组件 图标 1.2 整理页面+组件列表 页面名称 组件数量 欢迎页 3 登录页 3 首页 6 搜索页 4 新闻页 4 1.3 排查技术点 数据拉取 图片懒加载 图片缓存 新闻、频道、搜索历史数据缓存 2 使用蓝湖平台作为标注工具2.1 上传蓝湖支持 Sketch、Adobe Photoshop、Adobe XD、设计图片 PNG 2.2 标注 2.3 代码提示 2.4 原型展示 3 构建 Flutter 项目3.1 可复用小型项目结构 蓝湖设计稿https://lanhuapp.com/url/lYuz1密码: gSKl 蓝湖现在收费了，所以查看标记还请自己上传 xd 设计稿商业设计稿文件不好直接分享, 可以加微信联系 ducafecat git 代码https://github.com/ducafecat/flutter_learn_news/releases/tag/v1.0.1 视频 b 站 油管镜像 参考 蓝湖-上传设计图 © 猫哥 微信: ducafecat https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 18 基础组件 Stack IndexedStack Positioned","date":"2019-10-11T16:00:00.000Z","path":"2019/10/12/flutter/flutter-18-stack-indexedstack/","text":"本节目标 Stack IndexedStack Positioned Stack 和 IndexStack 都是层叠布局方式，类似于 Android 里的 FrameLayout 帧布局，内部子元素是有层级堆起来的。 Stack 继承自 MultiChildRenderObjectWidget，Stack 也是多子元素的一个组件之一（内部可以包含多个子元素）。 而 IndexedStack 继承自 Stack，扩展了 Stack 的一些特性。它的作用是显示第 index 个子元素，其他子元素都是不可见的。所以 IndexedStack 的尺寸永远是跟最大的子元素尺寸一致。 Stack 的布局行为，是根据子元素是 positioned 还是 non-positioned 来区分的： 对于 positioned 的子元素，它们的位置会根据所设置的 top、bottom、right 或 left 属性来确定，这几个值都是相对于 Stack 的左上角；对于 non-positioned 的子元素，它们会根据 Stack 的 aligment 来设置位置。Stack 布局的子元素层级堆叠顺序：最先布局绘制的子元素在最底层，越后绘制的越在顶层。类似于 Web 中的 z-index。 Stack12345678910111213Stack(&#123; Key key, // 对齐方式，默认是左上角（topStart） this.alignment = AlignmentDirectional.topStart, // 对齐方向 this.textDirection, // 定义如何设置无定位子元素尺寸，默认为loose this.fit = StackFit.loose, // 超过的部分子元素处理方式 this.overflow = Overflow.clip, // 子元素 List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) alignment 1234567891011121314151617181920212223242526// 左上角static const Alignment topLeft = Alignment(-1.0, -1.0);// 主轴顶部对齐，交叉轴居中static const Alignment topCenter = Alignment(0.0, -1.0);// 主轴顶部对齐，交叉轴偏右static const Alignment topRight = Alignment(1.0, -1.0);// 主轴居中，交叉轴偏左static const Alignment centerLeft = Alignment(-1.0, 0.0);// 居中static const Alignment center = Alignment(0.0, 0.0);// 主轴居中，交叉轴偏右static const Alignment centerRight = Alignment(1.0, 0.0);// 主轴底部对齐，交叉轴偏左static const Alignment bottomLeft = Alignment(-1.0, 1.0);// 主轴底部对齐，交叉轴居中static const Alignment bottomCenter = Alignment(0.0, 1.0);// 主轴底部对齐，交叉轴偏右static const Alignment bottomRight = Alignment(1.0, 1.0); fit 12345678910enum StackFit &#123; // 子元素宽松的取值，可以从min到max的尺寸 loose, // 子元素尽可能的占用剩余空间，取max尺寸 expand, // 不改变子元素的约束条件 passthrough,&#125; overflow 1234567enum Overflow &#123; // 超出部分不会被裁剪，正常显示 visible, // 超出部分会被裁剪 clip,&#125; IndexedStack12345678910IndexedStack(&#123; Key key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection textDirection, StackFit sizing = StackFit.loose, // 多了一个索引，索引的这个元素显示，其他元素隐藏 this.index = 0, // 子元素 List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) Positioned12345678910const Positioned(&#123; Key key, this.left, // 上下左右位置 this.top, this.right, this.bottom, this.width, // 宽高 this.height, @required Widget child,&#125;) 代码https://github.com/ducafecat/flutter-learn/tree/master/state_less_ful_app 参考 widgets © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 17 基础组件 Fex Expanded","date":"2019-10-10T16:00:00.000Z","path":"2019/10/11/flutter/flutter-17-flex-expanded/","text":"本节目标 expanded flex Flex 组件是 Row 和 Column 的父类，主要用于弹性布局，类似于 HTML 中的 Flex 弹性盒子布局，可以按照一定比例进行分类布局空间。 Flex 继承自 MultiChildRenderObjectWidget，Flex 也是多子元素的一个组件之一（内部可以包含多个子元素）。 Flex 一般和 Expanded 搭配使用，Expanded 组件从名字就可以看出它的特点，就是让子元素扩展占用 Flex 的剩余空间。 Expanded Flex 构造函数 单独看 Flex 组件没有意义，因为一般直接用它的子类 Row 和 Column 来使用。而 Flex 主要是和 Expanded 搭配使用。我们再看下 Expanded 组件构造方法： 123456789101112131415161718192021Flex(&#123; Key key, // 子元素排列方向：横向还是纵向 @required this.direction, this.mainAxisAlignment = MainAxisAlignment.start, this.mainAxisSize = MainAxisSize.max, this.crossAxisAlignment = CrossAxisAlignment.center, this.textDirection, this.verticalDirection = VerticalDirection.down, this.textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;)const Expanded(&#123; Key key, // 占用空间比重、权重 int flex = 1, // 子元素 @required Widget child, &#125;) 例子 Expanded12345678910111213Row( children: &lt;Widget&gt;[ Container( width: 50, color: Colors.cyan, ), Expanded( child: Container( color: Colors.brown, ), ), ],) 例子 Flex12345678910111213141516Column( children: &lt;Widget&gt;[ Expanded( flex: 1, child: Container( color: Colors.cyan, ), ), Expanded( flex: 4, child: Container( color: Colors.brown, ), ) ],) 代码https://github.com/ducafecat/flutter-learn/tree/master/flex_expanded_widget 参考 widgets © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 16 基础组件 Row Column","date":"2019-10-09T16:00:00.000Z","path":"2019/10/10/flutter/flutter-16-row-column/","text":"本节目标 Row 行组件 Column 列组件 mainAxisAlignment 主轴 crossAxisAlignment 交叉轴 textDirection 排列方向 verticalDirection 交叉轴起始位置 RowRow 布局组件类似于 Android 中的 LinearLayout 线性布局，它用来做水平横向布局使用，里面的 children 子元素按照水平方向进行排列。 构造 1234567891011121314151617Row(&#123; Key key, // 主轴方向上的对齐方式（Row的主轴是横向轴） MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, // 在主轴方向（Row的主轴是横向轴）占有空间的值，默认是max MainAxisSize mainAxisSize = MainAxisSize.max, // 在交叉轴方向(Row是纵向轴)的对齐方式，Row的高度等于子元素中最高的子元素高度 CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, // 水平方向子元素的排列方向：从左到右排列还是反向 TextDirection textDirection, // 表示纵轴（垂直）的对齐排列方向，默认是VerticalDirection.down，表示从上到下。这个参数一般用于Column组件里 VerticalDirection verticalDirection = VerticalDirection.down, // 字符对齐基线方式 TextBaseline textBaseline, // 子元素集合 List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) MainAxisAlignment 主轴属性：主轴方向上的对齐方式，Row 是横向轴为主轴 12345678910111213141516171819enum MainAxisAlignment &#123; // 按照主轴起点对齐，例如：按照靠近最左侧子元素对齐 start, // 将子元素放置在主轴的末尾，按照末尾对齐 end, // 子元素放置在主轴中心对齐 center, // 将主轴方向上的空白区域均分，使得子元素之间的空白区域相等，首尾子元素都靠近首尾，没有间隙。有点类似于两端对齐 spaceBetween, // 将主轴方向上的空白区域均分，使得子元素之间的空白区域相等，但是首尾子元素的空白区域为1/2 spaceAround, // 将主轴方向上的空白区域均分，使得子元素之间的空白区域相等，包括首尾子元素 spaceEvenly,&#125; CrossAxisAlignment 交叉属性：在交叉轴方向的对齐方式，Row 是纵向轴。Row 的高度等于子元素中最高的子元素高度 12345678910111213141516enum CrossAxisAlignment &#123; // 子元素在交叉轴上起点处展示 start, // 子元素在交叉轴上末尾处展示 end, // 子元素在交叉轴上居中展示 center, // 让子元素填满交叉轴方向 stretch, // 在交叉轴方向，使得子元素按照baseline对齐 baseline,&#125; MainAxisSize 在主轴方向子元素占有空间的方式，Row 的主轴是横向轴。默认是 max 1234567enum MainAxisSize &#123; // 根据传入的布局约束条件，最大化主轴方向占用可用空间，也就是尽可能充满可用宽度 max, // 与max相反，是最小化占用主轴方向的可用空间 min,&#125; ColumnColumn 是纵向排列子元素 参数用法同上 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// Row 行组件Widget _buildRow() &#123; return Row( mainAxisAlignment: MainAxisAlignment.center, verticalDirection: VerticalDirection.up, textBaseline: TextBaseline.ideographic, children: &lt;Widget&gt;[ RaisedButton( color: Colors.blue, child: Text('按钮1'), onPressed: () &#123;&#125;, ), RaisedButton( color: Colors.grey, child: Text('按钮2'), onPressed: () &#123;&#125;, ), RaisedButton( color: Colors.orange, child: Text('按钮3'), onPressed: () &#123;&#125;, ), ], );&#125;// Column 列组件Widget _buildColumn() &#123; return Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( color: Colors.blue, child: Text('按钮1'), onPressed: () &#123;&#125;, ), RaisedButton( color: Colors.grey, child: Text('按钮2'), onPressed: () &#123;&#125;, ), RaisedButton( color: Colors.orange, child: Text('按钮3'), onPressed: () &#123;&#125;, ), ], );&#125;// Row Column 组件嵌套Widget _buildRowColumn() &#123; return Column( mainAxisAlignment: MainAxisAlignment.center, // crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Row( // 元素排列顺序 textDirection: TextDirection.rtl, // 主轴方向 mainAxisAlignment: MainAxisAlignment.center, // 交叉轴的起始位置 verticalDirection: VerticalDirection.up, // 交叉轴对齐方式 crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ RaisedButton( color: Colors.blue, child: Text('按钮1'), onPressed: () &#123;&#125;, ), RaisedButton( color: Colors.blue, child: Text('按钮2222222'), onPressed: () &#123;&#125;, ), Container( width: 100, height: 100, color: Colors.yellow, ) ], ) ], );&#125;return MaterialApp( title: 'Material App', home: Scaffold( appBar: AppBar( title: Text('Material App Bar'), ), body: //_buildRow(), // _buildColumn(), _buildRowColumn(), ),); 代码https://github.com/ducafecat/flutter-learn/blob/master/row_column_widget 参考 Row class Column class © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 15 基础组件 MaterialApp Scaffold","date":"2019-10-08T16:00:00.000Z","path":"2019/10/09/flutter/flutter-15-scaffold/","text":"本节目标 MaterialApp Scafford Scaffold.of MaterialAppMaterial 风格的程序的构建，如 Key 导航 路由 首页 样式 多语言 调试 构造 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const MaterialApp(&#123; Key key, // 导航键 , key的作用提高复用性能 this.navigatorKey, // 主页 this.home, // 路由 this.routes = const &lt;String, WidgetBuilder&gt;&#123;&#125;, // 初始命名路由 this.initialRoute, // 路由构造 this.onGenerateRoute, // 未知路由 this.onUnknownRoute, // 导航观察器 this.navigatorObservers = const &lt;NavigatorObserver&gt;[], // 建造者 this.builder, // APP 标题 this.title = '', // 生成标题 this.onGenerateTitle, // APP 颜色 this.color, // 样式定义 this.theme, // 主机暗色模式 this.darkTheme, // 样式模式 this.themeMode = ThemeMode.system, // 多语言 本地化 this.locale, // 多语言代理 this.localizationsDelegates, // 多语言回调 this.localeListResolutionCallback, this.localeResolutionCallback, // 支持的多国语言 this.supportedLocales = const &lt;Locale&gt;[Locale('en', 'US')], // 调试显示材质网格 this.debugShowMaterialGrid = false, // 显示性能叠加 this.showPerformanceOverlay = false, // 检查缓存图片的情况 this.checkerboardRasterCacheImages = false, // 检查不必要的setlayer this.checkerboardOffscreenLayers = false, // 显示语义调试器 this.showSemanticsDebugger = false, // 显示debug标记 右上角 this.debugShowCheckedModeBanner = true,&#125;) ScaffoldScaffold 是一个页面布局脚手架，实现了基本的 Material 布局，继承自 StatefulWidget，是有状态组件。我们知道大部分的应用页面都是含有标题栏，主体内容，底部导航菜单或者侧滑抽屉菜单等等构成，那么每次都重复写这些内容会大大降低开发效率，所以 Flutter 提供了 Material 风格的 Scaffold 页面布局脚手架，可以很快地搭建出这些元素部分 构造 1234567891011121314151617181920212223242526272829303132const Scaffold(&#123; Key key, // 菜单栏 this.appBar, // 中间主体内容部分 this.body, // 悬浮按钮 this.floatingActionButton, // 悬浮按钮位置 this.floatingActionButtonLocation, // 悬浮按钮动画 this.floatingActionButtonAnimator, // 固定在下方显示的按钮 this.persistentFooterButtons, // 左侧 侧滑抽屉菜单 this.drawer, // 右侧 侧滑抽屉菜单 this.endDrawer, // 底部菜单 this.bottomNavigationBar, // 底部拉出菜单 this.bottomSheet, // 背景色 this.backgroundColor, // 自动适应底部padding this.resizeToAvoidBottomPadding, // 重新计算body布局空间大小，避免被遮挡 this.resizeToAvoidBottomInset, // 是否显示到底部，默认为true将显示到顶部状态栏 this.primary = true, this.drawerDragStartBehavior = DragStartBehavior.down, &#125;) Scaffold.ofScaffold.of 函数来获取 ScaffoldState 对象 contenxt 是动态获取的 所以需要用 Builder 套一个构造器 12345678static ScaffoldState of(BuildContext context, &#123; bool nullOk = false &#125;) &#123; assert(nullOk != null); assert(context != null); final ScaffoldState result = context.ancestorStateOfType(const TypeMatcher&lt;ScaffoldState&gt;()); if (nullOk || result != null) return result; throw FlutterError( ... 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102return MaterialApp( // APP 标题 title: 'Material App', // APP 颜色 color: Colors.yellow, // 样式 theme: ThemeData(primaryColor: Colors.green), // 主机暗色模式 android 下无效 ios 可以 darkTheme: ThemeData(primaryColor: Colors.yellow), // 调试显示材质网格 debugShowMaterialGrid: false, // 显示性能叠加 showPerformanceOverlay: false, // 检查缓存图片的情况 checkerboardRasterCacheImages: false, // 检查不必要的setlayer checkerboardOffscreenLayers: false, // 显示语义调试器 showSemanticsDebugger: false, // 显示debug标记 右上角 debugShowCheckedModeBanner: false, // 主页 home: Scaffold( // 菜单栏 appBar: AppBar( title: Text('Material App Bar'), ), // 悬浮按钮 floatingActionButton: FloatingActionButton( onPressed: () &#123;&#125;, child: Icon(Icons.add_photo_alternate), ), // 悬浮按钮位置 floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat, // 固定在下方显示的按钮 persistentFooterButtons: [ Text('persistentFooterButtons1'), Text('persistentFooterButtons2'), ], // 左侧 侧滑抽屉菜单 drawer: Drawer( child: Text('data'), ), // 右侧 侧滑抽屉菜单 endDrawer: Drawer( child: Text('data'), ), // 底部菜单 bottomNavigationBar: Text('bottomNavigationBar'), // 底部拉出菜单 bottomSheet: Text('bottomSheet'), // 背景色 backgroundColor: Colors.amberAccent, // 自动适应底部padding resizeToAvoidBottomPadding: true, // 压缩顶部菜单空间 primary: false, // drawerDragStartBehavior: DragStartBehavior.start, // 正文 body: Builder( builder: (BuildContext context) &#123; return Center( child: Container( child: RaisedButton( onPressed: () &#123; // Scaffold.of(context).openDrawer(); Scaffold.of(context).showSnackBar(new SnackBar( content: new Text('Hello!'), )); &#125;, child: Text('data'), ), ), ); &#125;, ), ), //); 代码https://github.com/ducafecat/flutter-learn/blob/master/container_widget 参考 MaterialApp class Scaffold class © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 14 基础组件 Container","date":"2019-10-07T16:00:00.000Z","path":"2019/10/08/flutter/flutter-14-container/","text":"本节目标 基础用法 Padding 和 Margin BoxDecoration 装饰 BoxShadow 阴影 RadialGradient 渐变 基础用法Container 是一个组合类容器，它本身不对应具体的 RenderObject，它是 DecoratedBox、ConstrainedBox、Transform、Padding、Align 等组件组合的一个多功能容器，所以我们只需通过一个 Container 组件可以实现同时需要装饰、变换、限制的场景。下面是 Container 的定义： 构造函数 12345678910111213141516171819202122232425Container(&#123; Key key, // 容器子Widget对齐方式 this.alignment, // 容器内部padding this.padding, // 背景色 Color color, // 背景装饰 Decoration decoration, // 前景装饰 this.foregroundDecoration, // 容器的宽度 double width, // 容器的高度 double height, // 容器大小的限制条件 BoxConstraints constraints, // 容器外部margin this.margin, // 变换，如旋转 this.transform, // 容器内子Widget this.child, &#125;) BoxDecoration 装饰123456789101112131415161718const BoxDecoration(&#123; // 背景色 this.color, // 背景图片 this.image, // 边框样式 this.border, // 边框圆角 this.borderRadius, // 阴影 this.boxShadow, // 渐变 this.gradient, // 背景混合模式 this.backgroundBlendMode, // 形状 this.shape = BoxShape.rectangle,&#125;) 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Container( constraints: BoxConstraints.expand( height: 200.0, ), margin: const EdgeInsets.all(20.0), padding: const EdgeInsets.all(8.0), // 背景色 // color: Colors.teal.shade700, // 子Widget居中 alignment: Alignment.centerLeft, // 子Widget元素 child: Text('Hello World', style: Theme.of(context) .textTheme .display1 .copyWith(color: Colors.white)), // 背景装饰 decoration: BoxDecoration( // 背景色 color: Colors.blueAccent, // 圆角 // borderRadius: BorderRadius.all( // Radius.circular(20.0), // ), // 渐变 gradient: RadialGradient( colors: [Colors.red, Colors.orange], center: Alignment.topLeft, radius: .98, ), // 阴影 boxShadow: [ BoxShadow( blurRadius: 2, offset: Offset(0, 2), color: Colors.blue, ), ], // 背景图 // image: DecorationImage( // image: AssetImage('assets/flutter.png'), // fit: BoxFit.cover, // ), // 背景混合模式 backgroundBlendMode: BlendMode.color, // 形状 shape: BoxShape.circle, ), // 前景装饰 // foregroundDecoration: BoxDecoration( // image: DecorationImage( // image: AssetImage('assets/flutter.png'), // ), // ), // Container旋转 // transform: Matrix4.rotationZ(0.1), ), 代码https://github.com/ducafecat/flutter-learn/blob/master/container_widget 参考 Container class BoxDecoration class RadialGradient class © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 12 基础组件 Image Asset NetworkImage","date":"2019-10-06T16:00:00.000Z","path":"2019/10/07/flutter/flutter-12-widget-image/","text":"本节目标 image 构造函数的 5 种方式 加载图片 Asset、NetworkImage 占位图 FadeInImage 头像 CircleAvatar 圆角 ClipRRect 图片 fit 方式 1. Image图片显示组件 支持图像格式 JPEG，PNG，GIF，动画 GIF，WebP，动画 WebP，BMP 和 WBMP 五种构造方式 构造 说明 Image() ImageProvider 适配图片 Image.asset 加载资源图片 Image.file 加载本地图片 Image.network 加载网络图片 Image.memory 加载 Uint8List 资源图片 构造参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//通过ImageProvider来加载图片const Image(&#123; Key key, // ImageProvider，图像显示源 @required this.image, this.semanticLabel, this.excludeFromSemantics = false, //显示宽度 this.width, //显示高度 this.height, //图片的混合色值 this.color, //混合模式 this.colorBlendMode, //缩放显示模式 this.fit, //对齐方式 this.alignment = Alignment.center, //重复方式 this.repeat = ImageRepeat.noRepeat, //当图片需要被拉伸显示的时候，centerSlice定义的矩形区域会被拉伸，类似.9图片 this.centerSlice, //类似于文字的显示方向 this.matchTextDirection = false, //图片发生变化后，加载过程中原图片保留还是留白 this.gaplessPlayback = false, //图片显示质量 this.filterQuality = FilterQuality.low, &#125;)// 加载网络图片，封装类：NetworkImageImage.network( //路径 String src, &#123; Key key, //缩放 double scale = 1.0, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, Map&lt;String, String&gt; headers, &#125;)// 加载本地File文件图片，封装类：FileImageImage.file( //File对象 File file, &#123; Key key, double scale = 1.0, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, &#125;)// 加载本地资源图片,例如项目内资源图片// 需要把图片路径在pubspec.yaml文件中声明一下，如：// assets:// - packages/fancy_backgrounds/backgrounds/background1.png// 封装类有：AssetImage、ExactAssetImageImage.asset( //文件名称，包含路径 String name, &#123; Key key, // 用于访问资源对象 AssetBundle bundle, this.semanticLabel, this.excludeFromSemantics = false, double scale, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, String package, this.filterQuality = FilterQuality.low, &#125;)// 加载Uint8List资源图片/从内存中获取图片显示// 封装类：MemoryImageImage.memory( // Uint8List资源图片 Uint8List bytes, &#123; Key key, double scale = 1.0, this.semanticLabel, this.excludeFromSemantics = false, this.width, this.height, this.color, this.colorBlendMode, this.fit, this.alignment = Alignment.center, this.repeat = ImageRepeat.noRepeat, this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, &#125;) 29 种混合模式 123enum BlendMode &#123; clear,src,dst,srcOver,dstOver,srcIn,dstIn,srcOut,dstOut,srcATop,dstATop,xor,plus，modulate,screen,overlay,darken,lighten,colorDodge,colorBurn,hardLight,softLight,difference,exclusion,multiply,hue,saturation,color,luminosity,&#125; 主要的混合模式效果如下 缩放 enum BoxFit 枚举对象 名称 说明 fill 图片按照指定的大小在 Image 中显示，拉伸显示图片，不保持原比例，填满 Image。 contain 以原图正常显示为目的，如果原图大小大于 Image 的 size，就按照比例缩小原图的宽高，居中显示在 Image 中。如果原图 size 小于 Image 的 size，则按比例拉升原图的宽和高，填充 Image 一边并居中显示。 cover 以原图填满 Image 为目的，如果原图 size 大于 Image 的 size，按比例缩小，居中显示在 Image 上。如果原图 size 小于 Image 的 size，则按比例拉升原图的宽和高，填充 Image 居中显示。 fitWidth 以原图正常显示为目的，如果原图宽大小大于（小于）Image 的宽，就缩小（放大）原图的宽与 Image 一致，居中显示在 Image 中。 fitHeight 以原图正常显示为目的，如果原图高大小大于（小于）Image 的高，就缩小（放大）原图的高与 Image 一致，居中显示在 Image 中。 none 保持原图的大小，显示在 Image 的中心。当原图的 size 大于 Image 的 size 时，多出来的部分被截掉。 scaleDown 以原图正常显示为目的，如果原图大小大于 Image 的 size，就按照比例缩小原图的宽高，居中显示在 Image 中。如果原图 size 小于 Image 的 size，则不做处理居中显示图片。 示例 pubspec.yaml 12assets: - assets/images/ main.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// assetsText('assets'),Image.asset(_assetImg),// 网络读取Text('网络读取'),Image.network(_imgUrl),// NetworkImageText('NetworkImage'),Image(image: NetworkImage(_imgUrl)),// 占位图Text('占位图'),FadeInImage( fadeInCurve: Curves.bounceIn, placeholder: AssetImage(_assetImg), image: NetworkImage(_imgUrl)),// 原型头像Text('原型头像'),CircleAvatar( backgroundColor: Colors.brown.shade800, child: Text('圆角图片'), backgroundImage: AssetImage(_assetHeaderImg), radius: 50.0),// 图标Text('图标'),ImageIcon( NetworkImage(_imgUrl), size: 100,),// ClipRRect 圆角Text('ClipRRect 圆角'),ClipRRect( child: Image.network(_imgUrl), borderRadius: BorderRadius.all(Radius.circular(20)),),// 圆角矩形框Text('圆角矩形框'),Container( width: 200, height: 80, decoration: BoxDecoration( shape: BoxShape.rectangle, borderRadius: BorderRadius.circular(10.0), image: DecorationImage( image: NetworkImage(_imgUrl), fit: BoxFit.cover), ),),// 椭圆图Text('椭圆图'),ClipOval( child: Image.network( _imgUrl, scale: 8.5, ),),// 混色Text('混色'),Image.asset( _assetHeaderImg, color: Colors.amber, colorBlendMode: BlendMode.dstATop,),// 裁剪Text('裁剪'),Image.asset( _assetImg, width: 400, height: 50, fit: BoxFit.cover,), 代码https://github.com/ducafecat/flutter-learn/tree/master/image_widget 参考 Image class NetworkImage class FadeInImage class ClipRRect class ClipOval class ImageIcon class © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 13 基础组件 Button FlatButton RaisedButton OutlineButton","date":"2019-10-06T16:00:00.000Z","path":"2019/10/07/flutter/flutter-13-widget-button/","text":"本节目标常用按钮操作 FlatButton（扁平化） RaisedButton（有按下状态） OutlineButton（有边框） MaterialButton（Material 风格） RawMaterialButton（没有应用 style 的 Material 风格按钮） FloatingActionButton（悬浮按钮） Button在 Flutter 中 Button 有很多封装好的 Widget 类： FlatButton（扁平化） RaisedButton（有按下状态） OutlineButton（有边框） MaterialButton（Material 风格） RawMaterialButton（没有应用 style 的 Material 风格按钮） FloatingActionButton（悬浮按钮） BackButton（返回按钮） IconButton（Icon 图标） CloseButton（关闭按钮） ButtonBar（可以排列放置按钮元素的） 其中大部分的 Button 都是基于 RawMaterialButton 进行的修改定制而成的。 构造函数 12345678910111213141516171819202122232425262728293031const FlatButton(&#123; Key key, // 点击事件 @required VoidCallback onPressed, // 高亮改变，按下和抬起时都会调用的方法 ValueChanged&lt;bool&gt; onHighlightChanged, // 定义按钮的基色，以及按钮的最小尺寸，内部填充和形状的默认值 ButtonTextTheme textTheme, // 按钮文字的颜色 Color textColor, // 按钮禁用时的文字颜色 Color disabledTextColor, // 按钮背景颜色 Color color, // 按钮禁用时的背景颜色 Color disabledColor, // 按钮按下时的背景颜色 Color highlightColor, // 点击时，水波动画中水波的颜色，不要水波纹效果设置透明颜色即可 Color splashColor, // 按钮主题，默认是浅色主题，分为深色和浅色 Brightness colorBrightness, // 按钮的填充间距 EdgeInsetsGeometry padding, // 外形 ShapeBorder shape, Clip clipBehavior = Clip.none, MaterialTapTargetSize materialTapTargetSize, // 按钮的内容，里面可以放子元素 @required Widget child, &#125;) 示例 后退、关闭 12345678ButtonBar( children: &lt;Widget&gt;[ BackButton( color: Colors.orange, ), CloseButton(), ],), 扁平按钮 FlatButton 12345678910111213141516ButtonBar( children: &lt;Widget&gt;[ FlatButton( child: Text('扁平按钮'), onPressed: () &#123; print('我是扁平按钮'); &#125;, ), FlatButton( child: Text( '扁平按钮 禁用', ), onPressed: null, ), ],), 扁平带图标按钮 FlatButton.icon 1234567891011121314ButtonBar( children: &lt;Widget&gt;[ FlatButton.icon( label: Text('带图标扁平按钮'), icon: Icon(Icons.add_call, size: 18.0), onPressed: () &#123;&#125;, ), FlatButton.icon( icon: const Icon(Icons.add_call, size: 18.0), label: const Text('带图标扁平按钮 禁用'), onPressed: null, ), ],), 带框按钮 OutlineButton 123456789101112ButtonBar( children: &lt;Widget&gt;[ OutlineButton( onPressed: () &#123;&#125;, child: Text('带框按钮'), ), OutlineButton( onPressed: null, child: Text('带框按钮 禁用'), ), ],), 带框图标按钮 OutlineButton.icon 123456789101112131415ButtonBar( children: &lt;Widget&gt;[ OutlineButton.icon( label: Text('带框图标按钮'), icon: Icon(Icons.add_to_photos, size: 18.0), onPressed: () &#123;&#125;, ), OutlineButton.icon( disabledTextColor: Colors.orange, icon: Icon(Icons.add_to_photos, size: 18.0), label: Text('带框图标按钮 禁用'), onPressed: null, ), ],), 立体按钮 RaisedButton 123456789101112ButtonBar( children: &lt;Widget&gt;[ RaisedButton( child: Text('立体按钮'), onPressed: () &#123;&#125;, ), RaisedButton( child: Text('立体按钮 禁用'), onPressed: null, ), ],), 立体按钮带图标 RaisedButton.icon 1234567891011121314ButtonBar( children: &lt;Widget&gt;[ RaisedButton.icon( icon: Icon(Icons.add, size: 18.0), label: Text('立体按钮带图标'), onPressed: () &#123;&#125;, ), RaisedButton.icon( icon: Icon(Icons.add, size: 18.0), label: Text('立体按钮带图标 禁用'), onPressed: null, ), ],), Material 按钮 MaterialButton 1234567891011121314ButtonBar( children: &lt;Widget&gt;[ MaterialButton( child: Text('Material按钮'), onPressed: () &#123; // Perform some action &#125;, ), MaterialButton( child: Text('Material按钮 禁用'), onPressed: null, ), ],), RawMaterial 按钮 RawMaterialButton 1234567891011121314ButtonBar( children: &lt;Widget&gt;[ RawMaterialButton( child: Text('RawMaterial按钮'), onPressed: () &#123; // Perform some action &#125;, ), RawMaterialButton( child: Text('RawMaterial按钮 禁用'), onPressed: null, ), ],), 浮动按钮 FloatingActionButton 123456789101112131415161718ButtonBar( children: &lt;Widget&gt;[ FloatingActionButton( child: const Icon(Icons.add), heroTag: '浮动按钮', onPressed: () &#123; // Perform some action &#125;, tooltip: '浮动按钮提示1', ), FloatingActionButton( child: const Icon(Icons.add), onPressed: null, heroTag: '浮动按钮 禁用', tooltip: '浮动按钮提示2', ), ],), 代码https://github.com/ducafecat/flutter-learn/blob/master/button_widget 参考 FlatButton class RaisedButton class OutlineButton class MaterialButton class RawMaterialButton class FloatingActionButton class BackButton class IconButton class CloseButton class ButtonBar class © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 11 基础组件 Text RichText TextSpan","date":"2019-10-05T16:00:00.000Z","path":"2019/10/06/flutter/flutter-11-widget-text/","text":"本节目标 Text 构造参数 TextStyle 样式构造参数 Text.rich、RichText、TextSpan 处理复杂字符显示 TextText Widget，从名字也可以看出，在 Flutter 里是用来负责显示文本信息的一个组件，功能类似于 Android 的 TextView、HTML 的一些文本标签等等，属于基础组件。 基础用法 1Text('hello word!'); 构造函数 Text 1234567891011121314151617181920212223242526const Text( //要显示的文字内容 this.data, &#123; //key类似于id Key key, //文字显示样式和属性 this.style, this.strutStyle, //文字对齐方式 this.textAlign, //文字显示方向 this.textDirection, //设置语言环境 this.locale, //是否自动换行 this.softWrap, //文字溢出后处理方式 this.overflow, //字体缩放 this.textScaleFactor, //最大显示行数 this.maxLines, //图像的语义描述，用于向Andoid上的TalkBack和iOS上的VoiceOver提供图像描述 this.semanticsLabel, &#125;) TextStyle style 属性比较常用，传入的是 TextStyle 对象，我们细看下它可以配置哪些属性样式。 12345678910111213141516171819202122232425262728293031323334353637383940const TextStyle(&#123; //是否继承父类组件属性 this.inherit = true, //字体颜色 this.color, //文字大小，默认14px this.fontSize, //字体粗细 this.fontWeight, //字体样式,normal或italic this.fontStyle, //字母间距，默认为0，负数间距缩小，正数间距增大 this.letterSpacing, //单词间距，默认为0，负数间距缩小，正数间距增大 this.wordSpacing, //字体基线 this.textBaseline, //行高 this.height, //设置区域 this.locale, //前景色 this.foreground, //背景色 this.background, //阴影 this.shadows, //文字划线，下换线等等装饰 this.decoration, //划线颜色 this.decorationColor, //划线样式，虚线、实线等样式 this.decorationStyle, //描述信息 this.debugLabel, //字体 String fontFamily, List&lt;String&gt; fontFamilyFallback, String package, &#125;) 示例 颜色、大小、样式 123456Text('字体24下划线', style: TextStyle( color: Colors.blue, // 蓝色 fontSize: 24, // 24 号字体 decoration: TextDecoration.underline, // 下划线 )), 缩放、加粗 12345678Text('放大加粗', textScaleFactor: 1.2, // 放大 1.2 style: TextStyle( fontWeight: FontWeight.bold, // 加粗 bold fontSize: 24, // 24 号字体 color: Colors.green, // 绿色 decoration: TextDecoration.none, // 不要下滑线 )), 文字溢出 1234567891011Text( '缩放，Each line here is progressively more opaque. The base color is material.Colors.black, and Color.withOpacity is used to create a derivative color with the desired opacity. The root TextSpan for this RichText widget is explicitly given the ambient DefaultTextStyle, since RichText does not do that automatically. The inner TextStyle objects are implicitly mixed with the parent TextSpans TextSpan.style.', textScaleFactor: 1.0, textAlign: TextAlign.center, softWrap: true, maxLines: 3, // 3 行 overflow: TextOverflow.ellipsis, // 剪切 加省略号 style: TextStyle( fontWeight: FontWeight.bold, fontSize: 18, )), Text.rich、RichText 、TextSpan构造函数可以在 Text 里加入一些 Span 标签，对某部分文字进行个性化改变样式，如加入 @ 符号，加入超链接、变色、加表情等等。Text.rich(…) 等价于 RichText(…)，用哪个都可以。 12345678910111213141516171819202122232425262728293031const Text.rich( // 样式片段标签TextSpan this.textSpan, &#123; Key key, this.style, this.strutStyle, this.textAlign, this.textDirection, this.locale, this.softWrap, this.overflow, this.textScaleFactor, this.maxLines, this.semanticsLabel, &#125;)const RichText(&#123; Key key, // 样式片段标签TextSpan @required this.text, this.textAlign = TextAlign.start, this.textDirection, this.softWrap = true, this.overflow = TextOverflow.clip, this.textScaleFactor = 1.0, this.maxLines, this.locale, this.strutStyle, &#125;) textSpan 类型是 TextSpan ，其它参数同上 12345678910const TextSpan(&#123; //样式片段 this.style, //要显示的文字 this.text, //样式片段TextSpan数组，可以包含多个TextSpan this.children, //用于手势进行识别处理,如点击跳转 this.recognizer, &#125;) 示例 拼接字符 123456789101112131415161718192021Text.rich(TextSpan( text: 'TextSpan', style: TextStyle( color: Colors.red, fontSize: 24.0, ), children: &lt;TextSpan&gt;[ new TextSpan( text: 'aaaaa', style: new TextStyle( color: Colors.blueGrey, ), ), new TextSpan( text: 'bbbbbb', style: new TextStyle( color: Colors.cyan, ), ), ],)), 添加交互 123456789101112131415Text.rich(TextSpan( children: &lt;TextSpan&gt;[ new TextSpan( text: 'Tap点击', style: new TextStyle( color: Colors.blueGrey, ), recognizer: new TapGestureRecognizer() ..onTap = () &#123; //增加一个点击事件 print('被点击了'); &#125;, ), ],)), recognizer 用来识别事件 TapGestureRecognizer tap 点击手势 代码https://github.com/ducafecat/flutter-learn/tree/master/text_widget 参考 Text class TextSpan class RichText class © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 见闻 - 01 Flutter 1.9 正式发布 实现三端编译发布 android ios web","date":"2019-09-15T16:00:00.000Z","path":"2019/09/16/flutter-daily/flutter-daily-01-update-sdk19/","text":"本节目标 在 web 平台运行 Flutter macOS Catalina 和 iOS 13 支持 全新的 Material widget 全球语言支持 Dart 2.5 发布 工具链优化 在 web 平台运行 Flutter 更新 SDK 12&gt; flutter channel master&gt; flutter upgrade 启用 web 支持 123&gt; flutter config --enable-web&gt; flutter devices 更新现有项目 1&gt; flutter create . 创建新项目 1&gt; flutter create myapp 运行 web 1&gt; flutter run -d chrome 编译 web 1&gt; flutter build web Flutter Widget Livebook一个在网页上展示 widget 运行效果的网站，它使用 Flutter 开发，并直接运行在网页上。 https://flutter-widget-livebook.blankapp.org/basics/introduction/ Panache则是一款为 Flutter 创建主题的工具，您可以下载创建好的主题，然后将其直接添加到代码中。 https://rxlabz.github.io/panache_web/#/ macOS Catalina 和 iOS 13 支持 iOS 13 的拖拽式工具栏 https://github.com/flutter/flutter/pull/35829 触感反馈 https://github.com/flutter/flutter/pull/37724 开发者已经提交了 pull request https://github.com/flutter/flutter/issues/35541 启用 Bitcode 实验性支持 https://github.com/flutter/flutter/wiki/Creating-an-iOS-Bitcode-enabled-app-(experimental) 全新的 Material widget ToggleButtons 示例 它能为您的应用按钮实现更加多元化的设计——不论是单选还是多选，选择至少一个或是零个，尖角还是圆角、粗边或细边，图标或文本——ToggleButtons widget 全都可以满足。 https://github.com/csells/flutter_toggle_buttons ColorFiltered 示例 允许您更改子 widget 树的颜色，用来灵活的调整配色服务。 https://github.com/csells/flutter_color_filter 全球语言支持还新增了南非语 (Afrikaans)、祖鲁语 (Zulu) 等 24 种语言的支持。 Dart 2.5 发布 ML 代码补全 https://github.com/dart-lang/sdk/wiki/Previewing-Dart-code-completions-powered-by-machine-learning 用于 Dart-C 互操作的 ffi 外部函数接口 改进常量表达式 1234const Object i = 3;const list = [i as int];const set = &#123;if (list is List&lt;int&gt;) ...list&#125;;const map = &#123;if (i is int) i: \"int\"&#125;; 工具链优化 从 Flutter 1.9 开始，iOS 新项目默认使用 Swift 语言，而非 Objective-C；Android 新项目则默认使用 Kotlin，而非 Java。 Swift 编译瘦身 改善错误信息提示 https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652050546&amp;idx=1&amp;sn=2c81e067ac34da40f89558f426e97af6&amp;chksm=808cb437b7fb3d2127431c7858beb3a03a29186c1c6a78aa0a2e97cd895e756b7ee3367ec935&amp;scene=21#wechat_redirect 参考 Building a web application with Flutter flutter_web Flutter 1.9 正式发布！| 全平台创新开发体验 腾讯视频链接 Flutter Widget Livebook 更精准更简洁: Flutter 改进错误信息提示 Panache iOS 13 的拖拽式工具栏 触感反馈 开发者已经提交了 pull request 启用 Bitcode 实验性支持&gt;) ToggleButtons ColorFiltered ML 代码补全 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 10 stateless stateful 有状态、无状态组件","date":"2019-08-17T16:00:00.000Z","path":"2019/08/18/flutter/flutter-10-stateless-stateful-widget/","text":"本节目标 stateless、stateless 差别 动手封装两个 widget 来体验 点击切换 点击切换 安装插件Awesome Flutter Snippets 第一步：编写 statefull 主程序12345678910111213141516171819202122import 'package:flutter/material.dart';main(List&lt;String&gt; args) &#123; runApp(MyApp());&#125;class MyApp extends StatefulWidget &#123; MyApp(&#123;Key key&#125;) : super(key: key); _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( body: Text('data'), ), ); &#125;&#125; 第二步：编写 stateless 图片显示1234567891011121314151617import 'package:flutter/material.dart';class MyPicView extends StatefulWidget &#123; final String picName; MyPicView(&#123;Key key, this.picName&#125;) : super(key: key); _MyPicViewState createState() =&gt; _MyPicViewState();&#125;class _MyPicViewState extends State&lt;MyPicView&gt; &#123; @override Widget build(BuildContext context) &#123; return Container( child: Image.asset('assets/$&#123;widget.picName&#125;'), ); &#125;&#125; 第三步：编写切换图片路径状态1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';import 'my_pic_view.dart';main(List&lt;String&gt; args) &#123; runApp(MyApp());&#125;class MyApp extends StatefulWidget &#123; MyApp(&#123;Key key&#125;) : super(key: key); _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; String fileName = 'p1.jpg'; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( body: Column( children: &lt;Widget&gt;[ MyPicView( picName: fileName, ), RaisedButton( onPressed: () &#123; String tmpFileName = 'p1.jpg'; if (fileName == 'p1.jpg') &#123; tmpFileName = 'p2.jpg'; &#125; setState(() &#123; fileName = tmpFileName; &#125;); &#125;, child: Text('切换图片'), ) ], )), ); &#125;&#125; 代码https://github.com/ducafecat/flutter-learn/tree/master/state_less_ful_app 参考 插件 Awesome Flutter Snippets Flutter Stateless and Stateful Widget Flutter: Stateful vs Stateless Widget © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 09 一切都是 widget","date":"2019-08-16T16:00:00.000Z","path":"2019/08/17/flutter/flutter-09-widgets/","text":"本节目标 整体架构设计 层次分类 整体架构设计架构图 源码目录…/sdk/flutter/packages/flutter/lib 目录功能 名称 说明 Foundation 基础部分 Animation 动画 Painting 边框绘制、颜色、裁剪图像处理、画笔、插值器等跟绘制、图像、装饰相关的类 Gestures 事件类、长按、触摸、放大等等 Rendering 渲染 Widget 的基础库 Widget 依赖 Rendering 层进行构建，Widget 是 Flutter 的核心 Material Android 平台的风格 Cupertino iOS 平台风格的扁平化 widget 分类主要分为 StatelessWidget 和 StatefulWidget 官方分类 基础组件 Widget（Basics）： Container、Row、Column、Image、Text、Icon、RaisedButton、Scaffold、Appbar、FlutterLogo、Placeholder Material Components： App 结构和导航类 Scaffold、Appbar、BottomNavigationBar、TabBar、TabBarView、MaterialApp、WidgetsApp、Drawer、SliverAppBar 按钮类 RaisedButton、FloatingActionButton、FlatButton、IconButton、DropdownButton、PopupMenuButton、ButtonBar 输入和选择类 TextField、Checkbox、Raido、Switch、Slider、Date&amp;Time Pickers 对话框和控制面板类 SimpleDialog、AlertDialog、BottomSheet、ExpansionPanel、SnackBar）； 信息显示类（Image、Icon、Chip、Tooltip、DataTable、Card、LinearProgressIndicator、CircularProgressIndicator、GridView 布局类 ListTile、Stepper、Divider Cupertino （iOS-style widgets）： CupertinoActionSheet、CupertinoActivityIndicator、CupertinoAlertDialog、CupertinoButton、CupertinoDatePicker、CupertinoDialog、CupertinoDialogAction、CupertinoFullscreenDialogTransition、CupertinoPageScaffold、CupertinoPageTransition、CupertinoPicker、CupertinoPopupSurface、CupertinoSegmentedControl、CupertinoSlider、CupertinoSwitch、CupertinoNavigationBar、CupertinoTabBar、CupertinoTabScaffold、CupertinoTabView、CupertinoTextField、CupertinoTimerPicker Layout： 单个子元素的布局 Widget Container、Padding、Center、Align、FittedBox、AspectRatio、ConstrainedBox、Baseline、FractionallySizedBox、IntrinsicHeight、IntrinsicWidth、LimitedBox、Offstage、OverflowBox、SizedBox、SizedOverflowBox、Transform、CustomSingleChildLayout 多个子元素的布局 Widget Row、Column、Stack、IndexedStack、GridView、Flow、Table、Wrap、ListBody、CustomMultiChildLayout、LayoutBuilder、ListView、Expanded Text 文本显示类： Text、RichText、DefaultTextStyle Assets、图片、Icons 类： Image、Icon、RawImage、AssetBundle Input 输入类： Form、FormField、RawKeyboardListener 动画和 Motion 类： AnimatedContainer、AnimatedCrossFade、Hero、AnimatedBuilder、DecoratedBoxTransition、FadeTransition、PositionedTransition、RotationTransition、ScaleTransition、SizeTransition、SlideTransition、AnimatedDefaultTextStyle、AnimatedListState、AnimatedModalBarrier、AnimatedOpacity、AnimatedPhysicalModel、AnimatedPositioned、AnimatedSize、AnimatedWidget、AnimatedWidgetBaseState 交互模型类： 触摸交互 Draggable、LongPressDraggable、GestureDetector、DragTarget、Dismissible、IgnorePointer、AbsorbPointer、Scrollable 路由导航 Hero、Navigator 样式类： Padding、Theme、MediaQuery 绘制和效果类： Transform、Opacity、DecoratedBox、FractionalTranslation、RotatedBox、ClipOval、ClipPath、ClipRect、CustomPaint、BackdropFilter Async 异步模型类： FutureBuilder、StreamBuilder 滚动类： GridView、ListView、NestedScrollView、SingleChildScrollView、Scrollable、Scrollbar、CustomScrollView、NotificationListener、ScrollConfiguration、RefreshIndicator、PageView 辅助功能类： Semantics、MergeSemantics、ExcludeSemantics widget 地图 img 参考 Widget catalog © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 08 开发规范","date":"2019-08-15T16:00:00.000Z","path":"2019/08/16/flutter/flutter-08-standard/","text":"本节目标 Dart 规范 Flutter 阿里规范 VSCode 格式化 右键菜单 当 Save 时自动格式化 规范精要使用小写加下划线来命名库和源文件1234library peg_parser.source_scanner;import 'file_system.dart';import 'slider_menu.dart'; 优先使用小驼峰法作为常量命名1234567const pi = 3.14;const defaultTimeout = 1000;final urlScheme = RegExp('^([a-z]+):');class Dice &#123; static final numberGenerator = Random();&#125; 所有流控制结构，请使用大括号12345if (isWeekDay) &#123; print('Bike to work!');&#125; else &#123; print('Go dancing or read a book!');&#125; Doc 注释使用///文档注释来记录成员和类型。 12/// The number of characters in this chunk when unsplit.int get length =&gt; ... 导入 lib 下文件库，统一指定包名，避免过多的123```dartpackage:flutter_go/使用相邻字符串连接字符串文字123raiseAlarm( 'ERROR: Parts of the spaceship are on fire. Other ' 'parts are overrun by martians. Unclear which are which.'); 优先使用模板字符串1'Hello, $name! You are $&#123;year - birth&#125; years old.'; 在不需要的时候，避免使用花括号12'Hi, $name!'\"Wear your wildest $decade's outfit.\" 不要使用.length 查看集合是否为空12if (lunchBox.isEmpty) return 'so hungry...';if (words.isNotEmpty) return words.join(' '); 遍历一个序列123for (var person in people) &#123; ...&#125; 不要显式地将变量初始化为空123456789101112int _nextId;class LazyId &#123; int _id; int get id &#123; if (_nextId == null) _nextId = 0; if (_id == null) _id = _nextId++; return _id; &#125;&#125; 在不需要的时候不要用 this1234567891011class Box &#123; var value; void clear() &#123; update(null); &#125; void update(value) &#123; this.value = value; &#125;&#125; 尽可能使用初始化的形式1234class Point &#123; num x, y; Point(this.x, this.y);&#125; 不要使用 new12345678910Widget build(BuildContext context) &#123; return Row( children: [ RaisedButton( child: Text('Increment'), ), Text('Click!'), ], );&#125; 优先使用 async/await 代替原始的 futures123456789101112Future&lt;int&gt; countActivePlayers(String teamName) async &#123; try &#123; var team = await downloadTeam(teamName); if (team == null) return 0; var players = await team.roster; return players.where((player) =&gt; player.isActive).length; &#125; catch (e) &#123; log.error(e); return 0; &#125;&#125; 当异步没有任何用处时，不要使用它123Future afterTwoThings(Future first, Future second) &#123; return Future.wait([first, second]);&#125; 参考 Dart 官方规范 阿里 Flutter Go 代码开发规范 0.1.0 版 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 07 我们的第一个程序 hello word","date":"2019-08-11T16:00:00.000Z","path":"2019/08/12/flutter/flutter-07-first-app-helloword/","text":"本节目标 程序基础结构 pubspec.yaml 配置 布局，样式使用 目录文件结构 名称 说明 lib Flutter 代码 android Android 项目 ios IOS 项目 test 测试目录 .idea IDEA 编辑器配置 pubspec.yaml Flutter 配置文件 pubspec.lock 包版本锁定 build 编译目录 一、编写最基础 helloword 步骤 1231. 第一步 runApp(...)2. 第二步 MaterialApp(...)3. 第三步 指定 widget Text(...) 代码 1234567891011import 'package:flutter/material.dart';main(List&lt;String&gt; args) &#123; // 第一步 runApp(...) runApp( // 第二步 MaterialApp MaterialApp( // 第三步 指定 widget home: Text('hello word!'), ));&#125; 二、采用界面脚手架 标题 侧栏 正文12345678910111213141516171819202122main(List&lt;String&gt; args) &#123; // 第一步 runApp(...) runApp( // 第二步 MaterialApp MaterialApp( // 第三步 指定 widget home: // 第四步 页面脚手架 Scaffold( // 第五步 程序标题 appBar: AppBar( title: Text('我们第一个程序'), ), // 第六步 侧栏 drawer: Drawer( child: Text('侧栏'), ), // 正文 body: Text('hello word!'), ), ));&#125; 三、布局 样式 图片12345678910111213141516171819202122232425262728293031323334353637main(List&lt;String&gt; args) &#123; // 第一步 runApp(...) runApp( // 第二步 MaterialApp MaterialApp( // 第三步 指定 widget home: // 第四步 页面脚手架 Scaffold( // 第五步 程序标题 appBar: AppBar( title: Text('我们第一个程序'), ), // 第六步 侧栏 drawer: Drawer( child: Text('侧栏'), ), // 正文 body: // 居中 Center( child: Column( children: &lt;Widget&gt;[ // 载入图片 Image.asset('assets/p1.jpg'), // 文字 Text( '雷神', // 样式 style: TextStyle(fontSize: 28, color: Colors.red), ), ], ), ), ), ));&#125; 代码https://github.com/ducafecat/flutter-learn/tree/master/helloword 参考 Write your first Flutter app, part 1 widgets © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 06 Windows10 下配置 Flutter 开发环境","date":"2019-08-10T16:00:00.000Z","path":"2019/08/11/flutter/flutter-06-setup-windows10/","text":"本节目标 安装 JDK 1.8 安装 Flutter SDK 安装 Android Studio 安装 VSCode 配置 VSCode 插件 配置 Android 插件 配置 Android 模拟器 环境介绍 window10 专业版 jdk1.8 flutter 1.7.8 vscode 1.37.1 android studio 3.5 1. 安装 JDK 1.8 下载地址 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 选取 windows x64 2. 安装 Flutter SDK 下载地址 https://flutter.dev/docs/development/tools/sdk/releases?tab=windows#windows 解压 我放在了 c:\\sdk\\flutter 配置环境变量 12345678# PathC:\\sdk\\flutter\\bin# FLUTTER_STORAGE_BASE_URLhttps://storage.flutter-io.cn# PUB_HOSTED_URLhttps://pub.flutter-io.cn 执行检查 1Flutter doctor 3. 安装 Android Studio 下载 https://developer.android.com/studio/ 配置 SDK 包 配置 SDK Tools 配置环境变量 123456# PathC:\\Users\\ducaf\\AppData\\Local\\Android\\Sdk\\toolsC:\\Users\\ducaf\\AppData\\Local\\Android\\Sdk\\platform-tools# ANDROID_HOMEC:\\Users\\ducaf\\AppData\\Local\\Android\\Sdk 安装 Android 证书 123flutter doctor --android-licenses一路按 Y 4. 安装 VSCode 下载地址 https://code.visualstudio.com/ 5. 配置 VSCode 插件 Flutter 必装 Awesome Flutter Snippets Paste JSON as Code bloc 6. 配置 Android 插件 flutter 7. 配置 Android 模拟器 © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 05 配置 IDE Macos","date":"2019-06-20T16:00:00.000Z","path":"2019/06/21/flutter/flutter-05-setup-ide-macos/","text":"本节目标 配置 VSCode 配置 Intellij IDEA 配置 Android Studio Dart DevTools 调试视图 Hot Reload 热更新 配置 VSCode下载安装https://code.visualstudio.com/ 安装插件 Dart 安装插件 Flutter 安装插件 Awesome Flutter Snippets 创建项目 flutter: new project 创建完成 创建模拟器 被提示需要 android 配置 Install Sources for Android 27 安装模拟器镜像 android-27 Google Play Intel x86 Atom System Image (system-images;android-27;google_apis_playstore;x86) x86 模拟器加速器 Intel x86 Emulator Accelerator (HAXM installer) android 模拟器 ios 模拟器 F5 运行 打开 Dart DevTools 配置 Intellij IDEA安装http://www.jetbrains.com/ 安装插件 Flutter new project 选择 flutter 注意 选择 sdk 位置 选项 点击 more 更多设置 module name 为英文 运行 调试器 inspector outline 配置 Android Studio安装插件 Flutter 创建项目 主面板 导航 运行同 IDEA 效果 hot reload热更新已支持 参考 Flutter SDK MacOS install Set up an editor Hot reload © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 04 配置 Android 开发环境 MacOS","date":"2019-06-19T16:00:00.000Z","path":"2019/06/20/flutter/flutter-04-setup-android-macos/","text":"本节目标 安装 Android Studio 配置 Flutter 连接 Android Studio 配置 Android 模拟器 在 Android 模拟器中运行 Flutter App 1. 安装 Android Studiohttps://developer.android.google.cn/studio 1.2 “unable to access android sdk add-on list” 点击取消 unable to access android sdk add-on list 1.3 自定义安装，全选项目 all 1.4 配置模拟器 进去 AVD Manage 不要选最新的模拟器镜像 配置模拟器参数 大家机器好点的，就多给点内存和空间吧，这样模拟器运行的快些 运行模拟器 2. 配置环境变量12345678&gt; vi ~/.bash_profile# androidexport ANDROID_HOME=~/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolssource ~/.bash_profile 3. 运行 Flutter3.1 创建项目 crate &amp; run 1234567891011121314151617181920&gt; flutter create my_app&gt; cd my_app&gt; flutter runUsing hardware rendering with device Android SDK built for x86. If you get graphics artifacts, consider enabling software renderingwith \"--enable-software-rendering\".Launching lib/main.dart on Android SDK built for x86 in debug mode...Initializing gradle... 1.4sResolving dependencies... 2.2sRunning Gradle task 'assembleDebug'...Running Gradle task 'assembleDebug'... Done 2.2sBuilt build/app/outputs/apk/debug/app-debug.apk.Installing build/app/outputs/apk/app.apk... 2.2sD/EGL_emulation( 5614): eglMakeCurrent: 0xe2c05300: ver 3 0 (tinfo 0xe2c03350)Syncing files to device Android SDK built for x86... 2,067ms (!)🔥 To hot reload changes while running, press \"r\". To hot restart (and rebuild state), press \"R\".An Observatory debugger and profiler on Android SDK built for x86 is available at: http://127.0.0.1:64823/uqW8O20byg8=/For a more detailed help message, press \"h\". To detach, press \"d\"; to quit, press \"q\". 参考 Flutter SDK MacOS install © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 03 配置 IOS 开发环境 MacOS","date":"2019-06-18T16:00:00.000Z","path":"2019/06/19/flutter/flutter-03-setup-ios-macos/","text":"本节目标 安装 xcode 配置 flutter 连接 xcode 在 IOS 模拟器中运行 flutter app 1. 安装 XCode安装 Xcode 9.0 以上版本 (访问 Apple网站 下载或者，Mac App Store 方式安装). 2. 第一次启动 XCode 安装所需组件 3. 配置 Xcode command-line tools1234&gt; sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer检验 打印 license&gt; sudo xcodebuild -license 4. 启动模拟器1open -a Simulator 5. 创建 Flutter 项目5.1 create &amp; run1234567&gt; flutter create my_app&gt; cd my_app&gt; flutter run🔥 To hot reload changes while running, press \"r\". To hot restart (and rebuild state), press \"R\".An Observatory debugger and profiler on iPhone Xʀ is available at: http://127.0.0.1:62341/ztmtijcoJrI=/For a more detailed help message, press \"h\". To detach, press \"d\"; to quit, press \"q\". 模拟器运行 5.2 vm 报告1http://127.0.0.1:62341/ztmtijcoJrI=/#/vm vm 6. 部署到真机6.1 安装软件包1234567&gt; brew update&gt; brew install --HEAD usbmuxd&gt; brew link usbmuxd&gt; brew install --HEAD libimobiledevice&gt; brew install ideviceinstaller ios-deploy cocoapods&gt; pod setup 安装 homebrew pod setup 很慢的问题 手动下载 git clone https://github.com/CocoaPods/Specs 复制 ~/.cocoapods/repos/Specs-master 执行 pod update 复制 master 下的 .git 到 Specs-master 停止 pod update 重命名 Specs-master 为 master 进入项目的 ios 目录下 pod install 成功 6.2 配置AppStore开发者账号1open ios/Runner.xcworkspace Add Account 开发者登录 https://developer.apple.com/cn/programs/ 参考 Flutter SDK MacOS install © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 02 安装 SDK MacOS","date":"2019-06-17T16:00:00.000Z","path":"2019/06/18/flutter/flutter-02-install-sdk-macos/","text":"本节目标 采用 git 方式安装 SDK 编译代码 flutter tool 检查环境 flutter doctor 1. 安装 SDK1.1 方式一：下载SDK包 SDK包下载 解压到 ~/Documents/sdk/flutter 1.2 方式二：git 拉取源码123&gt; mkdir ~/Documents/sdk&gt; cd ~/Documents/sdk&gt; git clone -b stable https://github.com/flutter/flutter.git 1.3 持续升级下次更新直接进入目录升级 123&gt; cd ~/Documents/sdk/flutter&gt; git pull&gt; flutter --version 2. 配置环境变量12345678910&gt; vi ~/.bash_profile# flutter , 注意没有单引号export PATH=$&#123;PATH&#125;:~/Documents/sdk/flutter/bin# 以下两行适合国内export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn&gt; source ~/.bash_profile 3. zsh 用户修改配置文件123456&gt; vi ~/.zshrc最后一行加入source ~/.bash_profile重启终端生效 4. 命令行运行 flutter123456789101112131415161718192021222324252627&gt; flutter doctorxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrunBuilding flutter tool... ╔════════════════════════════════════════════════════════════════════════════╗ ║ Welcome to Flutter! - https://flutter.dev ║ ║ ║ ║ The Flutter tool anonymously reports feature usage statistics and crash ║ ║ reports to Google in order to help Google contribute improvements to ║ ║ Flutter over time. ║ ║ ║ ║ Read about data we send with crash reports: ║ ║ https://github.com/flutter/flutter/wiki/Flutter-CLI-crash-reporting ║ ║ ║ ║ See Google's privacy policy: ║ ║ https://www.google.com/intl/en/policies/privacy/ ║ ║ ║ ║ Use \"flutter config --no-analytics\" to disable analytics and crash ║ ║ reporting. ║ ╚════════════════════════════════════════════════════════════════════════════╝Doctor summary (to see all details, run flutter doctor -v):Oops; flutter has exited unexpectedly.Crash report written to /Users/ducafecat/flutter_01.log;please let us know at https://github.com/flutter/flutter/issues. 第一次运行会进行 build CommandLineTools 工具推荐，先安装 xcode （早晚都要安装的） 然后 Terminal 运行 xcode-select –install xcode-select --install 5. 检查环境 flutter doctor123456789101112131415161718192021222324252627282930313233343536373839&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.5.4-hotfix.2, on Mac OS X 10.14.5 18F132, locale zh-Hans-CN)[!] Android toolchain - develop for Android devices (Android SDK version 29.0.0) ✗ Android licenses not accepted. To resolve this, run: flutter doctor --android-licenses[✗] iOS toolchain - develop for iOS devices ✗ Xcode installation is incomplete; a full installation is necessary for iOS development. Download at: https://developer.apple.com/xcode/download/ Or install Xcode via the App Store. Once installed, run: sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer ✗ libimobiledevice and ideviceinstaller are not installed. To install with Brew, run: brew update brew install --HEAD usbmuxd brew link usbmuxd brew install --HEAD libimobiledevice brew install ideviceinstaller ✗ ios-deploy not installed. To install: brew install ios-deploy ✗ CocoaPods not installed. CocoaPods is used to retrieve the iOS platform side's plugin code that responds to your plugin usage on the Dart side. Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS. For more info, see https://flutter.dev/platform-plugins To install: brew install cocoapods pod setup[!] Android Studio (version 3.4) ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality.[!] IntelliJ IDEA Ultimate Edition (version 2019.1.3) ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality.[!] VS Code (version 1.35.1) ✗ Flutter extension not installed; install from https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter[!] Connected device ! No devices available! Doctor found issues in 6 categories. 6. 查看版本 version12345&gt; flutter --versionFlutter 1.5.4-hotfix.2 • channel stable • https://github.com/flutter/flutter.gitFramework • revision 7a4c33425d (9 weeks ago) • 2019-04-29 11:05:24 -0700Engine • revision 52c7a1e849Tools • Dart 2.3.0 (build 2.3.0-dev.0.5 a1668566e5) 参考 Flutter SDK MacOS install © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Flutter 零基础入门中文教学 - 01 前言","date":"2019-06-16T16:00:00.000Z","path":"2019/06/17/flutter/flutter-01-introduce/","text":"本节目标 介绍 Flutter 课程计划 如果获取课程资料、代码、视频 适合人群 泛移动开发人员 原生移动开发人员 前端开发人员 跨平台: 移动、Web、桌面、嵌入 跨平台 Flutter 框架结构 Flutter Framework Framework 这一层使用 Dart 语言开发，它实现了一套基础库。 Foundation、Animation、Painting、Gestures 为 Dart 实现的 UI 层，提供动画、手势及绘制。 Rendering 渲染层，依赖 UI 层，在运行时 Rendering 层会构建一个 Widget 树，当有变化时，会更具一定的算法计算出有变化的部分，然后更新 Widget 树。 Widgets 层是 Flutter 提供的的一套基础组件库，在基础组件库之上，Flutter 还提供了 Material 和 Cupertino 两种视觉风格的组件库。 Flutter Engine Skia 是一个开源的二维图形库，提供各种常用的 API，并可在多种软硬件平台上运行。谷歌 Chrome 浏览器、Chrome OS、安卓、火狐浏览器、火狐操作系统以及其它许多产品都使用它作为图形引擎。 Skia 由谷歌出资管理，任何人都可基于 BSD 免费软件许可证使用 Skia。Skia 开发团队致力于开发其核心部分， 并广泛采纳各方对于 Skia 的开源贡献。 因为没有使用原生的 UI 和绘制框架，所以才保证了 Flutter 的高性能体验。 Skia官网 image-20190626154959148 Skia是一个开源的二维图形库，提供各种常用的API，并可在多种软硬件平台上运行。谷歌Chrome浏览器、Chrome OS、安卓、火狐浏览器、火狐操作系统以及其它许多产品都使用它作为图形引擎。 Skia由谷歌出资管理，任何人都可基于BSD免费软件许可证使用Skia。Skia开发团队致力于开发其核心部分， 并广泛采纳各方对于Skia的开源贡献。 Flutter for Webhttps://flutter.dev/web 通过对比，可以发现，web框架层和mobile的几乎一模一样。因此只需要重新实现一下引擎和嵌入层，不用变动Flutter API就可以完全可以将UI代码从Android / IOS Flutter App移植到Web。Dart能够使用Dart2Js编译器把Dart代码编译成Js代码。大多数原生App元素能够通过DOM实现，DOM实现不了的元素可以通过Canvas来实现。 Fuchsia OS 许中兴博士演讲：Fuchsia OS 简介及幻灯片下载 桌面系统 手机OS 平板 华为荣耀Play Flutter 特点 多平台支持 iOS Android Linux 未来 Fuchsia OS 原生用户界面 120fps 超高性能 两套成熟 UI 库 Material Design 和 Cupertino 响应式的框架 Redux、RxDart、BloC 业务和 UI 分离 Flutter 支持 Hot Reload 国内阿里咸鱼、腾讯、京东、国外的谷歌等公司都已经有上线产品在使用 Flutter 开发 showcase Flutter 横向对比 Cordova 基于 WebView 渲染，遇到动画、大列表 性能慢 React Native、Weex 基于虚拟 DOM 生成原生组件，比 Cordova 这类的性能好，但是遇到负责项目会有叠加 view 过多性能瓶颈 Flutter 自己封装的组件和渲染引擎，在设计上肯定会比 RN 这类的性能好，用的自家 Dart 语言深度编译，不需要像 RN 桥接 JavaScript 进行通讯，也会在性能上有优势 Flutter 生态资源 Flutter应用展示 官方包管理平台 awesome 课程计划123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118- 开篇写在最前 - Flutter 介绍 - 学习方法推荐 - 课程计划- 开发环境搭建和工具配置 - Flutter 环境配置 MacOS - IOS 环境配置 MacOS - Android 环境配置 MacOS - Flutter 环境配置 Windows10 - Android 环境配置 Windows10 - 开发工具的选择 VSCode、IDEA、AndroidStudio- 基础知识 - 项目及配置文件介绍 - 开发规范 - 一切都是 widget - StatelessWidget、StatefulWidget - 框架组件 MaterialApp、Scaffold - 布局组件 Container、Center、Row、Column - 基础组件 Text、Image、Button - 路由导航 Routes、Navigator - 生命周期- 快熟上手实战 - 新闻应用程序结构分析 - 使用布局组件搭建新闻列表界面 - 采用第三方 Http Dio 程序包读取数据 - 解析 Json 到 Modle - 使用自定义组件展示新闻行信息 - 点击新闻条路由导航到详情页 - 采用Web容器展示新闻内容 - 上拉刷新、下拉加载新闻列表 - 定制 Loading 效果 - 采用矢量图标库 - 采用 Sqlite 实现新闻列表首页缓存 - Redux 管理主题样式 - 加入应用启动画面 - 打包 Android APK 文件 - 打包 IOS IPA 文件- 基础组件 - Widget 与 Element - StatelessWidget - StatefulWidget - Text - Image - Button - AppBar - AlertDialog - Icon - TextField - Form - Switch - Checkbox- 布局组件 - 线性 Row - 线性 Column - 弹性 Flex - 弹性 Expanded - 层叠 Stack - 层叠 IndexedStack - 层叠 Positioned - 流式 Flow - 流式 Wrap- 容器组件 - Scaffold - Container - Center - Padding - ConstrainedBox - SizedBox - DecoratedBox - Transform- 导航组件 - TabBar - NavigationBar - PageView- 可滚动组件 - CustomScrollView - ListView - GridView - ScrollView - ExpansionPanel - ScrollController- 表格组件 - Table - DataTables- 功能型组件 - WillPopScope - InheritedWidget - 主题 Theme- 事件处理与通知 - 事件处理 - 手势识别 - 全局事件总线 - 通知消息- 自定义 Widget - 组合其它 Widget - 自绘 CustomPaint、Canvas- 进阶 - 文件操作 - Http 请求 - WebSocket 连接 - Json 解析 - 包与插件 - 国际化 - 数据库缓存 - Redux 参考 flutter.io skia showcase An open list of apps built with Flutter Flutter: a Portable UI Framework for Mobile, Web, Embedded, and Desktop © 猫哥 https://ducafecat.tech","tags":[{"name":"flutter","slug":"flutter","permalink":"https://blog.ducafecat.tech/tags/flutter/"}]},{"title":"Dart语言学习 - 38 代码分格 API 设计 effective-design","date":"2019-01-28T08:44:13.000Z","path":"2019/01/28/dart/dart-38-effective-design/","text":"本节目标 API 设计 环境 Dart 2.1.0 要 使用一致的术语12345pageCount // 一个成员变量updatePageCount() // 和 pageCount 名字一致。toSomething() // 和 Iterable 的 toList() 一致。asSomething() // 和 List 的 asMap() 一致。Point // 广为人知的概念。 避免 缩写1234pageCountbuildRectanglesIOStreamHttpRequest 推荐 把最具描述性的名词放到最后1234pageCount // A count (of pages).ConversionSink // A sink for doing conversions.ChunkedConversionSink // A ConversionSink that's chunked.CssFontFaceRule // A rule for font faces in CSS. 考虑 尽量让代码看起来像普通的句子12345678// \"If errors is empty...\"if (errors.isEmpty) ...// \"Hey, _subscription, cancel!\"_subscription.cancel();// \"Get the monsters where the monster has claws.\"monsters.where((monster) =&gt; monster.hasClaws); 推荐 使用非命令式动词短语命名布尔类型的变量和属性123456isEmptyhasElementscanCloseclosesWindowcanShowPopuphasShownPopup 考虑 省略命名布尔参数的动词123Isolate.spawn(entryPoint, message, paused: false)new List.from(elements, growable: true)new RegExp(pattern, caseSensitive: false) 推荐 使用命令式动词短语来命名带有副作用的函数或者方法1234list.add()queue.removeFirst()window.refresh()connection.downloadData() 考虑 使用名词短语或者非命令式动词短语命名返回数据为主要功能的方法或者函数12list.elementAt(3)string.codeUnitAt(4) 推荐 使用 to___() 来命名把对象的状态转换到一个新的对象的函数123list.toSet()stackTrace.toString()dateTime.toLocal() 使用 as___() 来命名把原来对象转换为另外一种表现形式的函数123list.asMap()bytes.asFloat32List()subscription.asFuture() 避免 在方法或者函数名称中描述参数12list.add(element)map.remove(key) 避免 定义使用简单的方法可以替代的只有一个成员的抽象类和 Java 不同的是， Dart 支持一等方法（first-class functions）、闭包和优雅的语法来使用它们。 如果你需要的只是一个回调函数，使用方法即可。 如果你定义了一个类，里面只有一个名字无意义的函数， 例如 call 或者 invoke， 这种情况最好用方法替代 1typedef bool Predicate(item); 避免 定义只包含静态成员的类12345DateTime mostRecent(List&lt;DateTime&gt; dates) &#123; return dates.reduce((a, b) =&gt; a.isAfter(b) ? a : b);&#125;const _favoriteMammal = 'weasel'; 然后，这条规则并不是强制的。对于一些常量或者枚举型的类型， 使用类来把相关的成员组织到一起可能也是合理的。当然， 使用库也是同样合理的。1234567class Color &#123; static const red = '#f00'; static const green = '#0f0'; static const blue = '#00f'; static const black = '#000'; static const white = '#fff';&#125; 推荐 使用构造函数而不是静态函数来创建对象1234567class Point &#123; num x, y; Point(this.x, this.y); Point.polar(num theta, num radius) : x = radius * math.cos(theta), y = radius * math.sin(theta);&#125; 要 使用 getter 来定义访问属性的操作如果函数的名字带有 get 前缀，或者是一个像 length 或者 size 这样 的名称，这种情况通常最好定义该函数为一个 getter。 当全部满足下面的条件的时候，你应该使用一个 getter： 没有参数。返回一个值没有副作用 调用一个 getter 不应该改变对象外部可见的状态 (内部缓存和延时初始化的状态可以发生变化) 如果对象的状态在多次调用同一个 getter 之间没有发生变化，则 多次调用同一个 getter 应该返回同一个值 123rectangle.widthcollection.isEmptybutton.canShow 要 对于本质上为修改对象属性的函数要使用 setter12rectangle.width = 3;button.visible = false; 不要 为 setter 指定返回类型1set foo(Foo value) &#123;...&#125; 推荐 为私有成员提供类型在公开的 API 上使用类型可以帮助使用你的库的用户。同样， 是私有代码上使用类型，可以帮助你的你的同事或者代码维护者。 另外，在私有成员上使用类型，对于将来自己查看代码 也有帮助。 12345678class CallChainVisitor &#123; final SourceVisitor _visitor; final Expression _target; void _writeCall(Expression call) &#123; ... &#125; ...&#125; 避免 在方法表达式上使用类型1var names = people.map((person) =&gt; person.name); 避免 在没必要的地方使用 dynamic 类型在大部分 Dart 代码中，类型可以忽略，这样该参数类型会自动设置为 dynamic。 所以没必要手动指定类型为 dynamic 的， 只需要省略类型即可。 12345lookUpOrDefault(String name, Map map, defaultValue) &#123; var value = map[name]; if (value != null) return value; return defaultValue;&#125; 避免 使用 Function 类型 正确 1bool isValidString(String value, bool predicate(String string)) &#123; ... &#125; 错误 1bool isValidString(String value, Function predicate) &#123; ... &#125; 要 使用 Object 来替代 dynamic 来表示可以接受任意对象1234567891011// Accepts any object.void log(Object object) &#123; print(object.toString());&#125;// Only accepts bool or String, which can't be expressed in a type annotation.bool convertToBool(arg) &#123; if (arg is bool) return arg; if (arg is String) return arg == 'true'; throw new ArgumentError('Cannot convert $arg to a bool.');&#125; 考虑使用命名参数或者命名构造函数以及命名常量来清晰 的表明您的意图：1234new Task.oneShot();new Task.repeating();new ListBox(scroll: true, showScrollbars: true);new Button(ButtonState.enabled); 对于 setter 则没有这个要求，应为 setter 的名字已经明确的 表明了值所代表的意义12listBox.canScroll = true;button.isEnabled = false; 避免 把用户想要忽略的参数放到位置可选参数的前列123456789101112131415161718String.fromCharCodes(Iterable&lt;int&gt; charCodes, [int start = 0, int end])DateTime(int year, [int month = 1, int day = 1, int hour = 0, int minute = 0, int second = 0, int millisecond = 0, int microsecond = 0])Duration( &#123;int days: 0, int hours: 0, int minutes: 0, int seconds: 0, int milliseconds: 0, int microseconds: 0&#125;) 避免 使用强制无意义的参数1string.substring(start) 要 使用包含开始位置并且不包含结束位置的范围参数如果你定义一个函数或者方法让用户从基于位置排序的集合中 选择一些元素，需要一个开始位置索引和结束位置索引分别制定开始 元素的位置以及结束元素的位置。结束位置通常是指 大于最后一个元素的位置的值。 核心库就是这样定义的，所以最好和核心库保持一致 12[0, 1, 2, 3].sublist(1, 3) // [1, 2].'abcd'.substring(1, 3) // \"bc\". 不要 在自定义 == 操作符中判断 null语言规范表明了这种判断已经自动执行了，你的 == 自定义操作符只有当 右侧对象不为 null 的时候才会执行。 正确 123456class Person &#123; final String name; operator ==(other) =&gt; other is Person &amp;&amp; name == other.name;&#125; 错误 12345678class Person &#123; final String name; operator ==(other) =&gt; other != null &amp;&amp; other is Person &amp;&amp; name == other.name;&#125; 参考 design © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 37 代码分格 最佳实践 effective-usage","date":"2019-01-28T07:30:46.000Z","path":"2019/01/28/dart/dart-37-effective-usage/","text":"本节目标 最佳实践 环境 Dart 2.1.0 使用相邻的字符串字面量定义来链接字符串123raiseAlarm( 'ERROR: Parts of the spaceship are on fire. Other ' 'parts are overrun by martians. Unclear which are which.'); 使用插值的形式来组合字符串和值1'Hello, $name! You are $&#123;year - birth&#125; years old.'; 避免在字符串插值中使用多余的大括号123'Hi, $name!'\"Wear your wildest $decade's outfit.\"'Wear your wildest $&#123;decade&#125;s outfit.' 尽可能的使用集合字面量来定义集合12var points = [];var addresses = &#123;&#125;; 如果有必要还可以提供泛型类型12var points = &lt;Point&gt;[];var addresses = &lt;String, Address&gt;&#123;&#125;; 不要 使用 .length 来判断集合是否为空12if (lunchBox.isEmpty) return 'so hungry...';if (words.isNotEmpty) return words.join(' '); 使用高阶（higher-order）函数来转换集合数据123var aquaticNames = animals .where((animal) =&gt; animal.isAquatic) .map((animal) =&gt; animal.name); 避免 在 Iterable.forEach() 中使用函数声明形式123for (var person in people) &#123; ...&#125; forEach() 方法通常在 JavaScript 中使用，原因是系统内置的 for-in 循环并不能提供期望的结果。 相反，在 Dart 中如果需要遍历一个集合，通常使用循环语句 如果你只想在每个集合元素上调用一个已经定义好的函数，则可以使用 forEach() 函数1people.forEach(print); 要 用方法声明的形式来给方法起个名字 正确 12345void main() &#123; localFunction() &#123; ... &#125;&#125; 错误示范 12345void main() &#123; var localFunction = () &#123; ... &#125;;&#125; 不要 显式的把变量初始化为 null123456789101112int _nextId;class LazyId &#123; int _id; int get id &#123; if (_nextId == null) _nextId = 0; if (_id == null) _id = _nextId++; return _id; &#125;&#125; 在 Dart 中没有初始化的变量和域会自动的 初始化为 null。在语言基本就保证了该行为的可靠性。 在 Dart 中没有 “未初始化的内存”这个概念。所以添加 = null 是多余的。 不要 创建没必要的 getter 和 setter12345678910```# 段落 1- 正确```dartclass Box &#123; var contents;&#125; 错误 1234567class Box &#123; var _contents; get contents =&gt; _contents; set contents(value) &#123; _contents = value; &#125;&#125; 推荐 使用 final 关键字来限定只读属性123class Box &#123; final contents = [];&#125; 考虑 用 =&gt; 来实现只有一个单一返回语句的函数123get width =&gt; right - left;bool ready(num time) =&gt; minTime == null || minTime &lt;= time;containsValue(String value) =&gt; getValues().contains(value); 要 尽可能的在定义变量的时候初始化其值1234567class Folder &#123; final String name; final List&lt;Document&gt; contents = []; Folder(this.name); Folder.temp() : name = 'temporary';&#125; 要 尽可能的使用初始化形式1234class Point &#123; num x, y; Point(this.x, this.y);&#125; 要 把 super() 调用放到构造函数初始化列表之后调用123View(Style style, List children) : _children = children, super(style) &#123; 要 使用 rethrow 来重新抛出捕获的异常123456try &#123; somethingRisky();&#125; catch(e) &#123; if (!canHandle(e)) rethrow; handle(e);&#125; 推荐 使用 async/await 而不是直接使用底层的特性123456789Future&lt;bool&gt; doAsyncComputation() async &#123; try &#123; var result = await longRunningCalculation(); return verifyResult(result.summary); &#125; catch(e) &#123; log.error(e); return false; &#125;&#125; 不要 在没有有用效果的情况下使用 async123Future afterTwoThings(Future first, second) &#123; return Future.wait([first, second]);&#125; 参考 usage © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 36 - 代码分格 文档 effective-documentation","date":"2019-01-28T07:15:00.000Z","path":"2019/01/28/dart/dart-36-effective-documentation/","text":"本节目标 文档分格 环境 Dart 2.1.0 按照句子的格式来格式化评论12// Not if there is nothing before it.if (_chunks.isEmpty) return false; 如果第一个单词不是大小写相关的标识符，则首字母要大写。使用标点符号结尾 （句号、感叹号、问号）。对于所有的注释都是这样要求的：文档注释、 行内注释、甚至 TODO 注释。即使是一句话的一半也需要如此。 使用块注释作为解释说明1234greet(name) &#123; // Assume we have a valid name. print('Hi, $name!');&#125; 使用 /// 文档注释来注释成员和类型12/// The number of characters in this chunk when unsplit.int get length =&gt; ... 把第一个语句定义为一个段落12345/// Defines a flag.////// Throws an [ArgumentError] if there is already an option named [name] or/// there is already an option using abbreviation [abbr]. Returns the new flag.Flag addFlag(String name, String abbr) &#123; ... &#125; 注释文档中的第一个段落应该是简洁的、面向用户的注释。例如下面的示例， 通常不是一个完成的语句。 用第三人称来开始函数或者方法的文档注释12345/// Returns `true` if every element satisfies the [predicate].bool all(bool predicate(T element)) &#123; ... &#125;/// Starts the stopwatch if not already running.void start() &#123; ... &#125; 使用名词短语来开始变量、getter、setter 的注释12345/// The current day of the week, where `0` is Sunday.int weekday;/// The number of checked buttons on the page.int get checkedCount &#123; ... &#125; 注释文档应该表述这个属性是什么。虽然 getter 函数会做些计算， 但是也要求这样，调用者关心的是其结果而 不是如何计算的 使用名词短语来开始库和类型注释1234/// A chunk of non-breaking output text terminated by a hard or soft newline.////// ...class Chunk &#123; ... &#125; 在程序中，类的注释通常是最重要的文档。 类的注释描述了类型的不变性、介绍其使用的术语、 提供类成员使用的上下文信息。为类提供一些注释可以让 其他类成员的注释更易于理解和编写。 在文档注释中添加示例代码1234/// Returns the lesser of two numbers.////// min(5, 3); // 3.num min(num a, num b) &#123; ... &#125; 人类非常擅长从示例中抽象出实质内容，所以即使提供 一行最简单的示例代码都可以让 API 更易于理解。 而 Dart 把参数、返回值等描述放到文档注释中，并使用方括号来引用 以及高亮这些参数和返回值12345/// Defines a flag.////// Throws an [ArgumentError] if there is already an option named [name] or/// there is already an option using abbreviation [abbr]. Returns the new flag.Flag addFlag(String name, String abbr) &#123; ... &#125; 把注释文档放到注解之前123/// _Deprecated: Use [newMethod] instead._@deprecatedoldMethod(); 使用 “this” 而不是 “the” 来引用实例成员1234567class Box &#123; /// The value this wraps. var _value; /// True if this box contains a value. bool get hasValue =&gt; _value != null;&#125; 参考 documentation © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 35 - 代码分格 effective style","date":"2019-01-28T06:43:12.000Z","path":"2019/01/28/dart/dart-35-effective-style/","text":"本节目标 代码分格 环境 Dart 2.1.0 使用 UpperCamelCase 风格来命名类型名称12345class SliderMenu &#123; ... &#125;class HttpRequest &#123; ... &#125;typedef bool Predicate&lt;T&gt;(T value); 使用 lowercase_with_underscores 风格来命名库和文件名名字1234library peg_parser.source_scanner;import 'file_system.dart';import 'slider_menu.dart'; 使用 lowercase_with_underscores 风格命名导入的前缀1234import 'dart:json' as json;import 'dart:math' as math;import 'package:javascript_utils/javascript_utils.dart' as js_utils;import 'package:js/js.dart' as js; 使用 lowerCamelCase 风格来命名其他的标识符1234567var item;HttpRequest httpRequest;align(clearItems) &#123; // ...&#125; 使用 lowerCamelCase 来命名常量1234567const pi = 3.14;const defaultTimeout = 1000;final urlScheme = new RegExp('^([a-z]+):');class Dice &#123; static final numberGenerator = new Random();&#125; 把 “dart:” 导入语句放到其他导入语句之前12345import 'dart:async';import 'dart:html';import 'package:bar/bar.dart';import 'package:foo/foo.dart'; 把 “package:” 导入语句放到相对导入语句之前1234import 'package:bar/bar.dart';import 'package:foo/foo.dart';import 'a.dart'; 把”第三方” “package:” 导入语句放到其他语句之前。12345import 'package:bar/bar.dart';import 'package:foo/foo.dart';import 'package:myapp/io.dart';import 'package:myapp/util.dart'; 把导出（export）语句放到所有导入语句之后的部分1234import 'src/error.dart';import 'src/string_source.dart';export 'src/error.dart'; 按照字母顺序来排序每个部分中的语句12345import 'package:bar/bar.dart';import 'package:foo/bar.dart';import 'a.dart';import 'a/b.dart'; 在所有的控制结构上使用大括号12345if (true) &#123; print('sanity');&#125; else &#123; print('opposite day!');&#125; 当只有 if 语句没有 else 语句并且 所有语句可以放到一行的时候，可以省略大括号1if (arg == null) return defaultValue; 通常用于当条件满足的时候就跳出 if 或者 返回的情况。 但是对于其他表达式，如果可以放到一行中， 也可以这样使用1if (parameter == null) parameter = defaultValue; 在每个语句或者声明后面添加一个空行123456main() &#123; first(statement); second(statement);&#125;anotherDeclaration() &#123; ... &#125; 在关键字 operator 后面添加一个空格1bool operator ==(other) =&gt; ...; 在二元和三元操作符之间添加空格1234average = (a + b) / 2;largest = a &gt; b ? a : b;if (obj is! SomeType) print('not SomeType');optional([parameter = defaultValue]) &#123; ... &#125; 不要 在一元操作符前后添加空格12!conditionindex++ 把开始的大括号 ({) 放到同一行上123456789class Foo &#123; method() &#123; if (true) &#123; // ... &#125; else &#123; // ... &#125; &#125;&#125; 在函数和方法体的 { 之前添加一个空格123getEmptyFn(a) &#123; return () &#123;&#125;;&#125; 把三元操作符放到多个表达式的下一行开始位置123return someCondition ? whenTrue : whenFalse; 把 . 放到下一行开头当表达式换行的时候12someVeryLongVariable.withAVeryLongProperty .aMethodOnThatObject(); 把构造函数初始化列表中的每个参数和值都放到同一行123456MyClass() : firstField = 'some value', secondField = 'another', thirdField = 'last' &#123; // ...&#125; 当无法在一行写完集合的时候，把每个元素都用集合定义的方式来表达12345678910mapInsideList([ &#123; 'a': 'b', 'c': 'd' &#125;, &#123; 'a': 'b', 'c': 'd' &#125;,]); 用两个空格来缩进代码块和集合体123456789if (condition) &#123; print('hi'); [ long, list, literal ];&#125; 缩进 switch case 两个空格， case 体四个空格123456789switch (fruit) &#123; case 'apple': print('delish'); break; case 'durian': print('stinky'); break;&#125; 只少使用两个空格来缩进多行函数级联调用1234buffer ..write('Hello, ') ..write(name) ..write('!'); 使用四个空格来缩进同一行的换行12345someLongObject.aReallyLongMethodName(longArg, anotherLongArg, wrappedToNextLine);bobLikes() =&gt; isDeepFried || (hasPieCrust &amp;&amp; !vegan) || containsBacon; 当表达式包含多行函数或者 集合声明定义的时候除外123456789new Future.delayed(const Duration(seconds: 1), () &#123; print('I am a callback');&#125;);args.addAll([ '--mode', 'release', '--checked']); 参考 style © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 34 注解 Metadata","date":"2019-01-21T16:15:56.000Z","path":"2019/01/22/dart/dart-34-metadata/","text":"本节目标 了解内置注解 deprecated override 自定义注解，并使用反射实现 环境 Dart 2.1.0 作用官方称之为 元数据 , 其实在 java 里就是注解 简化代码编写，方便阅读，和重用 内置 deprecated用来注解 不建议使用、老旧的 成员对象 1234567891011121314151617class Television &#123; @deprecated void activate() &#123; turnOn(); &#125; void turnOn() &#123; print('on!'); &#125;&#125;main(List&lt;String&gt; args) &#123; var t = new Television(); t.activate(); t.turnOn();&#125; 内置 override表明你的函数是想覆写超类的一个函数 超类就是被你集成的父类 下面的代码中父类是 Object 1234567891011class A &#123; @override noSuchMethod(Invocation mirror) &#123; print('没有找到方法'); &#125;&#125;main(List&lt;String&gt; args) &#123; dynamic a = new A(); a.message();&#125; 内置 proxy注解来避免警告信息 在 Dart2 中已经被标记为过时老旧 1234567891011@proxyclass A &#123; noSuchMethod(Invocation mirror) &#123; print('没有找到方法'); &#125;&#125;main(List&lt;String&gt; args) &#123; dynamic a = new A(); a.say();&#125; 自定义注解使用反射可以在运行时获取元数据信息 比如服务端的控制器开发 下面的代码 展示了如何在反射中读取 metadata 信息 123456789101112131415161718192021222324252627282930import 'dart:mirrors';@Todo('seth', 'make this do something')void doSomething() &#123; print('do something');&#125;class Todo &#123; final String who; final String what; const Todo(this.who, this.what);&#125;main(List&lt;String&gt; args) &#123; currentMirrorSystem().libraries.forEach((uri, lib) &#123; // print('lib: $&#123;uri&#125;'); lib.declarations.forEach((s, decl) &#123; // print('decl: $&#123;s&#125;'); decl.metadata.where((m) =&gt; m.reflectee is Todo).forEach((m) &#123; var anno = m.reflectee as Todo; if (decl is MethodMirror) &#123; print('Todo($&#123;anno.who&#125;, $&#123;anno.what&#125;)'); ((decl as MethodMirror).owner as LibraryMirror).invoke(s, []); &#125; ; &#125;); &#125;); &#125;);&#125; 代码 34-媒体信息 参考 metadata © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 33 类型信息 typedef","date":"2019-01-20T16:21:06.000Z","path":"2019/01/21/dart/dart-33-typedef/","text":"本节目标 typedef 使用 环境 Dart 2.1.0 作用typedef 用来保存函数的信息，未来可能会保存类信息。 示例代码 采用 typedef 123456789101112131415161718192021// 定义函数类型typedef int Compare(Object a, Object b);// 定义排序类class SortedCollection &#123; Compare compare; // 构造时传入函数 SortedCollection(this.compare);&#125;// 定义排序函数int sort(Object a, Object b) =&gt; 0;// 程序入口main() &#123; // 实例化传入 SortedCollection coll = new SortedCollection(sort); // 类型检查 assert(coll.compare is Function); assert(coll.compare is Compare);&#125; 未采用 typedef 123456789101112131415161718192021class SortedCollection &#123; // 函数对象 Function compare; // 定义函数 SortedCollection(int f(Object a, Object b)) &#123; compare = f; &#125;&#125;// 生命函数int sort(Object a, Object b) =&gt; 0;main() &#123; // 实例化 SortedCollection coll = new SortedCollection(sort); // 我们只知道 compare 是一个 Function 类型， // 但是不知道具体是何种 Function 类型？ assert(coll.compare is Function);&#125; 区别就是 typedef 编辑器会提示函数信息 代码 33-类型信息 参考 typedefs © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 32 线程隔离 isolate","date":"2019-01-19T16:52:55.000Z","path":"2019/01/20/dart/dart-32-isolates/","text":"本节目标 了解线程隔离 环境 Dart 2.1.0 isolate在Dart中实现并发可以用Isolate，它是类似于线程(thread)但不共享内存的独立运行的worker，是一个独立的Dart程序执行环境。其实默认环境就是一个main isolate。 在Dart语言中，所有的Dart代码都运行在某个isolate中，代码只能使用所属isolate的类和值。不同的isolate可以通过port发送message进行交流。 示意图 ReceivePort 创建入口点 Isolate.spawn 连接进程 SendPort.send 发送消息 echo 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import 'dart:async';import 'dart:isolate';// 第1步：定义主线程main() async &#123; // 第3步：编写回调Port var receivePort = new ReceivePort(); await Isolate.spawn(echo, receivePort.sendPort); // 第6步：保存隔离线程回调Port var sendPort = await receivePort.first; // 第7步：发送消息 var msg = await sendReceive(sendPort, \"foo\"); print('received $msg'); msg = await sendReceive(sendPort, \"bar\"); print('received $msg');&#125;// 第2步：定义隔离线程的入口点echo(SendPort sendPort) async &#123; // 第4步：编写回调Port var port = new ReceivePort(); // 第5步：告诉主线程回调入口点 sendPort.send(port.sendPort); // 第8步：循环接收消息 await for (var msg in port) &#123; // 数组 msg[0] 是数据 var data = msg[0]; // 数组 msg[1] 是发送方Port SendPort replyTo = msg[1]; // 回传发送方 数据 replyTo.send(data); // 如果数据时 bar 关闭当前回调 if (data == \"bar\") port.close(); &#125;&#125;/*主线程 发送消息函数数组 msg[0] 是数据数组 msg[1] 是发送方Port返回 隔离线程 Port*/Future sendReceive(SendPort port, msg) &#123; ReceivePort response = new ReceivePort(); port.send([msg, response.sendPort]); return response.first;&#125; 代码 32-隔离 参考 isolates © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 31 可调用类 callable","date":"2019-01-16T03:37:26.000Z","path":"2019/01/16/dart/dart-31-callable/","text":"本节目标 定义并执行可定义类 环境 Dart 2.1.0 callable123456789101112main(List&lt;String&gt; args) &#123; var phone = IOSPhone(); phone('911'); // IOSPhone()('911');&#125;class IOSPhone &#123; call(String num) &#123; print('phone number is $num'); &#125;&#125; 代码 可调用类 参考 callable-classes © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 30 - 生成器 Generators","date":"2019-01-15T09:25:58.000Z","path":"2019/01/15/dart/dart-30-generator/","text":"本节目标 同步、异步代码生成器 环境 Dart 2.1.0 同步生成器123456789101112131415main(List&lt;String&gt; args) &#123; var it = naturalsTo(5).iterator; while(it.moveNext()) &#123; print(it.current); &#125;&#125;Iterable&lt;int&gt; naturalsTo(int n) sync* &#123; print('start'); int k = 0; while (k &lt; n) &#123; yield k++; &#125; print('end');&#125; yield 会等待 moveNext 指令 异步生成器123456789101112131415161718192021222324import 'dart:async';main(List&lt;String&gt; args) &#123; // 流监听 // asynchronousNaturalsTo(5).listen((onData) &#123; // print(onData); // &#125;); // 流监听 StreamSubscription 对象 StreamSubscription subscription = asynchronousNaturalsTo(5).listen(null); subscription.onData((value) &#123; print(value); // subscription.pause(); &#125;);&#125;Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* &#123; print('start'); int k = 0; while (k &lt; n) &#123; yield k++; &#125; print('end');&#125; 以流的方式一次性推送 StreamSubscription 对象进行流监听控制 递归生成器12345678910111213main(List&lt;String&gt; args) &#123; var it = naturalsDownFrom(5).iterator; while(it.moveNext()) &#123; print(it.current); &#125;&#125;Iterable&lt;int&gt; naturalsDownFrom(int n) sync* &#123; if ( n &gt; 0) &#123; yield n; yield* naturalsDownFrom(n-1); &#125;&#125; yield* 以指针的方式传递递归对象，而不是整个同步对象 代码 生成器 generators 参考 generators © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 29 异步 async","date":"2018-12-05T07:51:09.000Z","path":"2018/12/05/dart/dart-29-async/","text":"本节目标 调用异步 等待、递归 异步返回值 环境 Dart 2.1.0 调用异步 回调12345678import 'package:dio/dio.dart';void main() &#123; Dio dio = new Dio(); dio.get(\"https://www.baidu.com\").then((response) &#123; print(response.data); &#125;);&#125; then 的方式异步回调 调用异步 等待1234567import 'package:dio/dio.dart';void main() async &#123; Dio dio = new Dio(); Response&lt;String&gt; response = await dio.get(\"https://www.baidu.com\"); print(response.data);&#125; async 写在函数定义await 写在异步请求头 异步返回值123456789101112import 'package:dio/dio.dart';void main() async &#123; var content = await getUrl('https://www.baidu.com'); print(content);&#125;Future&lt;String&gt; getUrl(String url) async &#123; Dio dio = new Dio(); Response&lt;String&gt; response = await dio.get(url); return response.data;&#125; 定义 Future&lt;T&gt; 返回对象 代码 异步 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 28 泛型","date":"2018-12-05T03:30:26.000Z","path":"2018/12/05/dart/dart-28-generic/","text":"本节目标 使用泛型 定义泛型 限制泛型 环境 Dart 2.1.0 泛型使用12345678910111213main(List&lt;String&gt; args) &#123; var l = List&lt;String&gt;(); l.add('aaa'); l.add('bbb'); l.add('ccc'); print(l); var m = Map&lt;int, String&gt;(); m[1] = 'aaaa'; m[2] = 'bbbb'; m[3] = 'cccc'; print(m);&#125; 很多的容器对象，在创建对象时都可以定义泛型类型。 泛型函数123456789main(List&lt;String&gt; args) &#123; var key = addCache('a00001', 'val.....'); print(key);&#125;K addCache&lt;K, V&gt;(K key, V val) &#123; print('$&#123;key&#125; $&#123;val&#125;'); return key;&#125; 泛型可以用在一个函数的定义 构造函数泛型123456789main(List&lt;String&gt; args) &#123; var p = Phone&lt;String&gt;('abc00000011111'); print(p.mobileNumber);&#125;class Phone&lt;T&gt; &#123; final T mobileNumber; Phone(this.mobileNumber);&#125; 这是大多数情况下使用泛型的场景，在一个类的构造函数中 泛型限制12345678910111213141516main(List&lt;String&gt; args) &#123; var ad = AndroidPhone(); var p = Phone&lt;AndroidPhone&gt;(ad); p.mobile.startup();&#125;class Phone&lt;T extends AndroidPhone &gt; &#123; final T mobile; Phone(this.mobile);&#125;class AndroidPhone &#123; void startup() &#123; print('Android Phone 开机'); &#125;&#125; 通过 extends 关键字 可以限定你可以泛型使用的类型 代码 泛型 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 27 库","date":"2018-12-05T02:00:54.000Z","path":"2018/12/05/dart/dart-27-library/","text":"本节目标 核心库 外部库 导入模块 环境 Dart 2.1.0 导入核心库1234567import 'dart:io';void main() &#123; var f = new File('README.md'); var content = f.readAsStringSync(); print(content);&#125; 导入第三方库 编写 pubspec.yaml 123name: ducafecatdependencies: dio: 1.0.9 程序调用 1234567import 'package:dio/dio.dart';void main() async &#123; Dio dio = new Dio(); Response&lt;String&gt; response = await dio.get(\"https://www.baidu.com\"); print(response.data);&#125; 导入文件1234567import './phone.dart';void main() &#123; var xm = Phone('android'); xm.startup(); xm.shutdown();&#125; 前缀123456789101112import './phone.dart';import './phone1.dart' as pp;void main() &#123; var xm = Phone('android'); xm.startup(); xm.shutdown(); var xm1 = pp.Phone('android'); xm1.startup(); xm1.shutdown();&#125; 筛选包内容12345678// import './phone.dart' hide AndroidPhone;import './phone.dart' show IOSPhone;void main() &#123; var xm = IOSPhone(); xm.startup(); xm.shutdown();&#125; hide 筛掉某几个包show 只使用某几个包 延迟载入1234567891011import './phone.dart' deferred as pp;void main() async &#123; var run = true; if (run) &#123; await pp.loadLibrary(); var xm = pp.Phone('android'); xm.startup(); xm.shutdown(); &#125;&#125; loadLibrary() 方式在需要的时候载入包可提高程序启动速度用在不常使用的功能用在载入时间过长的包 代码 库 参考 language-tour 包管理平台 © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 26 工厂函数","date":"2018-12-04T06:33:01.000Z","path":"2018/12/04/dart/dart-26-factory/","text":"本节目标 工厂函数 工厂构造函数 环境 Dart 2.1.0 工厂函数简化类型实例化 1234567891011121314151617181920212223242526272829303132333435363738void main() &#123; var xm = phoneFactory('ios'); xm.startup(); xm.shutdown();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;Phone phoneFactory(String name) &#123; switch (name) &#123; case 'android': return new AndroidPhone(); break; default: return new IOSPhone(); &#125;&#125;class AndroidPhone extends Phone &#123; void startup() &#123; super.startup(); print('Android Phone 开机'); &#125;&#125;class IOSPhone extends Phone &#123; void startup() &#123; super.startup(); print('IOS Phone 开机'); &#125;&#125; 工厂构造函数12345678910111213141516171819202122232425262728293031323334353637void main() &#123; var xm = Phone('android'); xm.startup(); xm.shutdown();&#125;abstract class Phone &#123; factory Phone(String name) &#123; switch (name) &#123; case 'android': return new AndroidPhone(); break; default: return new IOSPhone(); &#125; &#125; void startup(); void shutdown();&#125;class AndroidPhone implements Phone &#123; void startup() &#123; print('Android Phone 开机'); &#125; void shutdown() &#123; print('Android 关机'); &#125;&#125;class IOSPhone implements Phone &#123; void startup() &#123; print('IOS Phone 开机'); &#125; void shutdown() &#123; print('IOS 关机'); &#125;&#125; 代码 factory 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 25 多继承类 mixin","date":"2018-12-04T03:26:18.000Z","path":"2018/12/04/dart/dart-25-mixin/","text":"本节目标 多继承类的实现方式 函数重名冲突 环境 Dart 2.1.0 类多继承123456789101112131415161718192021222324252627282930313233343536373839404142void main() &#123; var xm = Xiaomi(); xm.startup(); xm.shutdown(); xm.call(); xm.sms();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;class AndroidPhone extends Phone &#123; void startup() &#123; super.startup(); print('AndroidPhone 开机'); &#125;&#125;class AndroidSystem &#123; void call() &#123; print('android call'); &#125;&#125;class Weixin &#123; void sms() &#123; print('weixin sms'); &#125;&#125;class Xiaomi extends AndroidPhone with AndroidSystem, Weixin &#123; void startup() &#123; super.startup(); print('AndroidPhone 开机'); &#125;&#125; 采用 with ... , .... , ... 方式 mixin 入多个类功能 函数重名冲突1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void main() &#123; var xm = Xiaomi(); xm.startup(); xm.shutdown(); xm.sms();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;class AndroidPhone extends Phone &#123; void startup() &#123; super.startup(); print('AndroidPhone 开机'); &#125;&#125;class AndroidSystem &#123; void call() &#123; print('android call'); &#125;&#125;class Weixin &#123; void sms() &#123; print('weixin sms'); &#125;&#125;class QQ &#123; void sms() &#123; print('qq sms'); &#125;&#125;class Xiaomi extends AndroidPhone with AndroidSystem, Weixin, QQ &#123; void startup() &#123; super.startup(); print('AndroidPhone 开机'); &#125;&#125; 遇到相同功能的函数，最后载入的会覆盖之前的函数定义 代码 mixin 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 24 extends 继承","date":"2018-11-28T09:45:11.000Z","path":"2018/11/28/dart/dart-24-extends/","text":"本节目标 实现继承 继承抽象类的问题 不可多继承 父类调用 调用父类构造 重写超类函数 环境 Dart 2.0.0 实现继承1234567891011121314151617void main() &#123; var p = AndroidPhone(); p.startup(); p.shutdown();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;class AndroidPhone extends Phone &#123;&#125; 继承抽象类的问题12345678910111213void main() &#123; var p = AndroidPhone(); p.startup(); p.shutdown();&#125;abstract class Phone &#123; void startup(); void shutdown();&#125;class AndroidPhone extends Phone &#123;&#125; 抽象类中只定义抽象函数，实例化访问会报错 父类调用1234567891011121314151617181920void main() &#123; var p = AndroidPhone(); p.startup();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;class AndroidPhone extends Phone &#123; void startup() &#123; super.startup(); print('AndroidPhone 开机'); &#125;&#125; super 对象可以访问父类 调用父类构造1234567891011121314151617void main() &#123; var p = AndroidPhone(12345678); p.showNumber();&#125;class Mobile &#123; int number; int signal; Mobile(this.number); void showNumber() &#123; print('010-$&#123;number&#125;'); &#125;&#125;class AndroidPhone extends Mobile &#123; AndroidPhone(int number) : super(number);&#125; 可调用父类的 构造函数 重写超类函数12345678910111213141516171819202122void main() &#123; dynamic p = AndroidPhone(12345678); p.showNumber111();&#125;class Mobile &#123; int number; int signal; Mobile(this.number); void showNumber() &#123; print('010-$&#123;number&#125;'); &#125;&#125;class AndroidPhone extends Mobile &#123; AndroidPhone(int number) : super(number); @override void noSuchMethod(Invocation mirror) &#123; print('被重写 noSuchMethod'); &#125;&#125; 在重写的函数上加修饰符 @override 代码 extends 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 23 interface 接口","date":"2018-11-28T09:23:46.000Z","path":"2018/11/28/dart/dart-23-interface/","text":"本节目标 实现接口 implements 多接口 环境 Dart 2.0.0 Dart 中没有 interface 关键字实现接口12345678910111213141516171819void main() &#123; var p = AndroidPhone(); p.startup(); p.shutdown();&#125;abstract class IPhone &#123; void startup(); void shutdown();&#125;class AndroidPhone implements IPhone &#123; void startup() &#123; print('AndroidPhone 开机'); &#125; void shutdown() &#123; print('AndroidPhone 关机'); &#125;&#125; 接口用途的抽象类 请用字母 I 开头 , 如 IPhone 从一个普通类履行接口1234567891011121314151617181920212223void main() &#123; var p = AndroidPhone(); p.startup(); p.shutdown();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;class AndroidPhone implements Phone &#123; void startup() &#123; print('AndroidPhone 开机'); &#125; void shutdown() &#123; print('AndroidPhone 关机'); &#125;&#125; Dart 可以从一个普通的类履行接口 履行多接口12345678910111213141516171819202122232425262728void main() &#123; var p = AndroidPhone(); p.startup(); p.shutdown();&#125;class Phone &#123; void startup() &#123; print('开机'); &#125; void shutdown() &#123; print('关机'); &#125;&#125;class Mobile &#123; int signal;&#125;class AndroidPhone implements Phone, Mobile &#123; int signal; void startup() &#123; print('AndroidPhone 开机'); &#125; void shutdown() &#123; print('AndroidPhone 关机'); &#125;&#125; Dart 可以履行多个接口 代码 interface 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 22 abstract 抽象","date":"2018-11-28T08:17:42.000Z","path":"2018/11/28/dart/dart-22-abstract/","text":"本节目标 抽象 类、函数 接口方式使用 继承方式使用 环境 Dart 2.0.0 abstract 类、函数、成员 普通类前加 abstract 123456abstract class Person &#123; static const String name = 'ducafecat'; void printName()&#123; print(name); &#125;&#125; 不能直接 new 实例化12var p = Person();p.printName(); Dart 2 开始 new 可以不写，提高阅读体验 继承方式使用定义 12class Teacher extends Person &#123;&#125; 实例 12var user = Teacher();user.printName(); 接口方式使用定义 1234567891011abstract class Person &#123; static const String name = ''; void printName();&#125;class Student implements Person &#123; String name = 'this is student'; void printName() &#123; print(name); &#125;&#125; 实例 12var user = Student();user.printName(); 代码 abstract 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 21 静态成员","date":"2018-11-17T08:02:07.000Z","path":"2018/11/17/dart/dart-21-static/","text":"本节目标 静态变量 静态方法 环境 Dart 2.0.0 静态变量static 定义声明 123class People &#123; static String name = 'ducafecat';&#125; 调用 静态变量可以通过外部直接访问,不需要将类实例化 1print(People.name); 函数内部访问实例化后的类也可以访问该静态变量 声明 123456class People &#123; static String name = 'ducafecat'; void show() &#123; print(name); &#125;&#125; 调用 12var p = new People();p.show(); 不能用 this因为静态变量实际上存在于类中,而不是实例本身 123456class People &#123; static String name = 'ducafecat'; void show() &#123; print(this.name); &#125;&#125; 静态方法静态方法可以通过外部直接访问 声明 123456class People &#123; static String name = 'ducafecat'; static void printName() &#123; print(name); &#125;&#125; 调用 1People.printName(); 总结 实例化后将无法通过外部直接调用 static 成员 静态成员与实例成员是分开的, 静态成员处于类的定义体中, 实例成员处于类的实例中 代码 static.dart 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 20 get set","date":"2018-11-17T07:30:21.000Z","path":"2018/11/17/dart/dart-20-getter-setter/","text":"本节目标 定义、使用、简化 get set 环境 Dart 2.0.0 定义、使用 get setgetter 和 setter 的好处是，你可以开始使用实例变量，后来 你可以把实例变量用函数包裹起来，而调用你代码的地方不需要修改。 定义 1234567891011class People &#123; String _name; set pName(String value) &#123; _name = value; &#125; String get pName &#123; return 'people is $&#123;_name&#125;'; &#125;&#125; 使用 123var p = new People();p.pName = 'ducafecat';print(p.pName); 简化 get set1234567class People &#123; String _name; set pName(String value) =&gt; _name = value; String get pName =&gt; 'people is $&#123;_name&#125;';&#125; 代码 getset.dart 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 19 类","date":"2018-11-17T05:52:30.000Z","path":"2018/11/17/dart/dart-19-class/","text":"本节目标 定义、使用类 构造函数 简化构造 初始化列表 命名构造函数 重定向构造函数 环境 Dart 2.0.0 定义、使用类定义 12class Point &#123;&#125; 使用 1var p = new Point(); 构造函数定义 12345678class Point &#123; num x; num y; Point(num x, num y)&#123; this.x = x; this.y = y; &#125;&#125; 使用 12var p = new Point(1, 2);print([p.x, p.y]); 简化构造定义 12345class Point &#123; num x; num y; Point(this.x, this.y);&#125; 使用 12var p = new Point(1, 2);print([p.x, p.y]); 初始化列表定义 123456class Point &#123; num x; num y; var origin; Point(this.x, this.y): origin = &#123;x:x, y:y&#125;;&#125; 使用 12var p = new Point(1, 2);print([p.x, p.y, p.origin]); 命名构造函数定义 12345678class Point &#123; num x; num y; Point.fromJson(Map json) &#123; x = json['x']; y = json['y']; &#125;&#125; 使用 12var p = new Point.fromJson(&#123;\"x\": 1, \"y\": 2&#125;);print([p.x, p.y]); 重定向构造函数定义 123456class Point &#123; num x; num y; Point(this.x, this.y); Point.fromJson(Map json) : this(json['x'], json['y']);&#125; 使用 12var p = new Point.fromJson(&#123;\"x\": 1, \"y\": 2&#125;);print([p.x, p.y]); 代码 class.dart 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 18 异常","date":"2018-11-17T02:53:26.000Z","path":"2018/11/17/dart/dart-18-exceptions/","text":"本节目标 错误类型 抛出、捕获 环境 Dart 2.0.0 错误的两种类型Exception 类Exception class 名称 说明 DeferredLoadException 延迟加载错误 FormatException 格式错误 IntegerDivisionByZeroException 整数除零错误 IOException IO 错误 IsolateSpawnException 隔离产生错误 TimeoutException 超时错误 Error 类Error class 名称 说明 AbstractClassInstantiationError 抽象类实例化错误 ArgumentError 参数错误 AssertionError 断言错误 AsyncError 异步错误 CastError Cast 错误 ConcurrentModificationError 并发修改错误 CyclicInitializationError 周期初始错误 FallThroughError Fall Through 错误 JsonUnsupportedObjectError json 不支持错误 NoSuchMethodError 没有这个方法错误 NullThrownError Null 错误错误 OutOfMemoryError 内存溢出错误 RemoteError 远程错误 StackOverflowError 堆栈溢出错误 StateError 状态错误 UnimplementedError 未实现的错误 UnsupportedError 不支持错误 抛出错误12345678// Exception 对象// throw new FormatException('这是一个格式错误提示');// Error 对象// throw new OutOfMemoryError();// 任意对象// throw '这是一个异常'; 捕获错误12345678// try &#123;// // throw new FormatException('这是一个格式错误提示');// throw new OutOfMemoryError();// &#125; on OutOfMemoryError &#123;// print('没有内存了');// &#125; catch (e) &#123;// print(e);// &#125; 重新抛出错误12345678// try &#123;// throw new OutOfMemoryError();// &#125; on OutOfMemoryError &#123;// print('没有内存了');// rethrow;// &#125; catch (e) &#123;// print(e);// &#125; Finally 执行12345678910// try &#123;// throw new OutOfMemoryError();// &#125; on OutOfMemoryError &#123;// print('没有内存了');// rethrow;// &#125; catch (e) &#123;// print(e);// &#125; finally &#123;// print('end');// &#125; 代码 exception.dart 参考 language-tour Exception class Error class © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 17 流程控制语句","date":"2018-11-12T07:56:51.000Z","path":"2018/11/12/dart/dart-17-controlFlow/","text":"本节目标 条件判断 循环控制 环境 Dart 2.0.0 if else1234bool isPrint = true;if (isPrint) &#123; print('hello');&#125; for123for (var i = 0; i &lt; 5; i++) &#123; print(i);&#125; while12345bool isDone = false;while(!isDone) &#123; print('is not done'); isDone = true;&#125; do while12345bool isRunning = true;do &#123; print('is running'); isRunning = false;&#125; while (isRunning); switch case12345678String name = 'cat';switch (name) &#123; case 'cat': print('cat'); break; default: print('not find');&#125; break12345678num i = 1;while(true) &#123; print('$&#123;i&#125; - run'); i++; if(i == 5) &#123; break; &#125;&#125; continue123456for (var i = 0; i &lt; 5; i++) &#123; if (i &lt; 3) &#123; continue; &#125; print(i);&#125; continue 指定位置1234567891011121314151617String command = \"close\";switch(command) &#123; case \"open\": print(\"open\"); break; case \"close\": print(\"close\"); continue doClose; doClose: case \"doClose\": print(\"DO_CLOSE\"); break; default: print(\"-----\");&#125; 代码 controlFlow.dart 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 16 操作符","date":"2018-11-12T02:41:28.000Z","path":"2018/11/12/dart/dart-16-operators/","text":"本节目标 优先级 算术操作符 相等相关的操作符 类型判定操作符 赋值操作符 逻辑操作符 位和移位操作符 条件表达式 级联操作符 环境 Dart 2.0.0 操作符表 描述 操作符 \b 后缀操作 expr++ expr– () [] . ?. 前缀操作 -expr !expr ~expr ++expr –expr 乘除 * / % ~/ 加减 + - 位移 &lt;&lt; &gt;&gt; 按位与 &amp; 按位异或 ^ 按位或 \\ 类型操作 &gt;= &gt; &lt;= &lt; as is is! 相等 == != 逻辑与 &amp;&amp; 逻辑或 \\ \\ 是为为空 ?? 三目运算 expr1 ? expr2 : expr3 级联 .. 赋值 = *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= \\ = ??= 优先级顺序 上面左边 优先级高于 右边下面 123if(x == 1 &amp;&amp; y == 2)&#123; ...&#125; 算术操作符 操作符 解释 + 加号 – 减号 -expr 负号 * 乘号 / 除号 ~/ 除号，但是返回值为整数 % 取模 123print(5/2);print(5~/2);print(5 % 2); 相等相关的操作符 操作符 解释 == 相等 != 不等 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 类型判定操作符 操作符 解释 as 类型转换 is 如果对象是指定的类型返回 True is! 如果对象是指定的类型返回 False 123456int a = 123;String b = 'ducafecat';String c = 'abc';print(a as Object);print(b is String);print(c is! String); 条件表达式 操作符 解释 condition ? expr1 : expr2 如果 condition 是 true，执行 expr1 (并返回执行的结果)； 否则执行 expr2 并返回其结果。 expr1 ?? expr2 如果 expr1 是 non-null，返回其值； 否则执行 expr2 并返回其结果。 1234567bool isFinish = true;String txtVal = isFinish ? 'yes' : 'no';bool isFinish;isFinish = isFinish ?? false;orisFinish ??= false; 位和移位操作符 操作符 解释 &amp; 逻辑与 逻辑或 ^ 逻辑异或 ~expr 取反 &lt;&lt; 左移 &gt;&gt; 右移 级联操作符 操作符 解释 .. 可以在同一个对象上 连续调用多个函数以及访问成员变量。 123456StringBuffer sb = new StringBuffer();sb..write('hello')..write('word')..write('\\n')..writeln('doucafecat'); 其他操作符 操作符 解释 () 使用方法 代表调用一个方法 [] 访问 List 访问 list 中特定位置的元素 . 访问 Member 访问元素，例如 foo.bar 代表访问 foo 的 bar 成员 ?. 条件成员访问 和 . 类似，但是左边的操作对象不能为 null，例如 foo?.bar 如果 foo 为 null 则返回 null，否则返回 bar 成员 12String a;print(a?.length); 代码 operator.dart 参考 operators © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 15 函数 Function","date":"2018-11-12T01:36:04.000Z","path":"2018/11/12/dart/dart-15-function/","text":"本节目标 函数定义 可选参数 默认值 命名参数 内部定义 环境 Dart 2.0.0 函数定义123456int add(int x) &#123; return x + 1;&#125;调用add(1); 可选参数123456789101112int add(int x, [int y, int z]) &#123; if (y == null) &#123; y = 1; &#125; if (z == null) &#123; z = 1; &#125; return x + y + z;&#125;调用int(1, 2); 可选参数 默认值123456int add(int x, [int y = 1, int z = 2]) &#123; return x + y;&#125;调用int(1, 2); 命名参数 默认值123456int add(&#123;int x = 1, int y = 1, int z = 1&#125;) &#123; return x + y + z;&#125;调用int(x: 1, y: 2); 函数内定义123456void main()&#123; int add(int x)&#123; return x + x; &#125; print(add(1));&#125; Funcation 返回函数对象1234567Function makeAdd(int x) &#123; return (int y) =&gt; x + y;&#125;调用var add = makeAdd(1);print(add(5)); 代码 function.dart 参考 Functions © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 14 symbol、enum、comments","date":"2018-10-27T03:05:15.000Z","path":"2018/10/27/dart/dart-14-symbol-enum-comments/","text":"本节目标 symbol enum comments 环境 Dart 2.0.0 符号 SymbolDart语言的标识符，在反射中用的很普及，特别是很多发布包都是混淆后的。 123456import 'dart:mirrors';Symbol libraryName = new Symbol('dart.core');MirrorSystem mirrorSystem = currentMirrorSystem();LibraryMirror libMirror = mirrorSystem.findLibrary(libraryName);libMirror.declarations.forEach((s, d) =&gt; print('$s - $d')); 枚举 Enum适合用在常量定义，类型比较很方便。 123enum Status &#123; none, running, stopped, paused &#125;Status.values.forEach((it) =&gt; print('$it - index: $&#123;it.index&#125;')); 注释 Comments单行注释1// Symbol libraryName = new Symbol('dart.core'); 多行注释12345678/* * Symbol * Symbol libraryName = new Symbol('dart.core');MirrorSystem mirrorSystem = currentMirrorSystem();LibraryMirror libMirror = mirrorSystem.findLibrary(libraryName);libMirror.declarations.forEach((s, d) =&gt; print('$s - $d')); */ 文档注释12345678/// `main` 函数////// 符号/// 枚举///void main() &#123; ...&#125; 可参考 String 类中的注释使用 代码 symbol-enum-comments.dart 参考 language-tour Symbol © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 13 Runes","date":"2018-10-27T00:51:21.000Z","path":"2018/10/27/dart/dart-13-runes/","text":"本节目标 Runes 基础知识 字符编码 ASCII、Unicode、UTF-8、UTF-16、UTF-32 环境 Dart 2.0.0 RunesRunes 对象是一个 32位 字符对象，用来表示一个字。这样设计也是考虑兼容 UTF-16 四个字节的情况。 length 和 runes.length 比较1234567String a = '👺';print(a.length);print(a.runes.length);&gt;&gt; 输出2 // 标识占 2 个 16 位字符1 // 表示占 1 个 32 位字符 runes 是一个 32 位字符对象 操作 32-bit Unicode 字符123456Runes b = new Runes('\\u&#123;1f596&#125; \\u6211');var c = String.fromCharCodes(b);或者String c = '\\u&#123;1f596&#125; \\u6211' 如果非4个数值，需要用 {…} 返回 16-bit code units 的 codeUnitAt codeUnits1234567var a = '👺';print(a.codeUnitAt(0));print(a.codeUnits);&gt;&gt; 输出55357 // 第 1 位的 10 进制数值[55357, 56442] // 显示 2 位的 10 进制数值 返回 32-bit Unicode 的 runes123456var a = '👺';print(a.runes);&gt;&gt; 输出(128122) // 显示 32 位的 10 进制数值 String 操作整理 名称 说明 codeUnitAt 某个字符的码 10进制 fromCharCodes Runes 转 String 工厂函数 runes 返回字对象 基础知识字符集ASCII ASCII 非 ASCII 中的 GB2312、GBK 汉字内码扩展规范 Unicode、UTF-8、UTF-16、UTF-32 UTF-8 UTF-16 UTF-32 代码 runes.dart 参考 language-tour Runes ASCII Unicode UTF-8 UTF-16 UTF-32 在线字符 © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 12 Set","date":"2018-10-25T06:47:10.000Z","path":"2018/10/25/dart/dart-12-set/","text":"本节目标 初始、声明 常用属性 常用方法 环境 Dart 2.0.0 声明Set 是一个元素唯一的有序队列 松散12345678// var a = new Set();// a.add('java');// a.add('php');// a.add('python');// a.add('java');// a.add('sql');// a.add('swift');// a.add('dart'); 强类型12// var b = new Set&lt;String&gt;();// b.addAll(['dart', 'c#', 'j#', 'e#']); 基本属性 名称 说明 isEmpty 是否为空 isNotEmpty 是否不为空 first 第一个 last 最后一个 length 个数 常用方法 名称 说明 addAll 添加 contains 查询单个 containsAll 查询多个 difference 集合不同 intersection 交集 union 联合 lookup 按对象查询到返回对象 remove 删除单个 removeAll 删除多个 clear 清空 firstWhere 按条件正向查询 lastWhere 按条件反向查询 removeWhere 按条件删除 retainAll 只保留几个 retainWhere 按条件只保留几个 1234567891011121314151617181920// b.addAll(['dart', 'c#', 'j#', 'e#']);// print(b.contains('dart'));// print(b.containsAll(['dart', 'swift']));// print('b =&gt; $b');// print(a.difference(b));// print(a.intersection(b));// print(b.lookup('dart'));// print(b.union(a));// b.remove('dart');// b.removeAll(['dart','c#']);// b.clear();// print(b.firstWhere((it) =&gt; it == 'c#'));// print(b.lastWhere((it) =&gt; it == 'c#'));// b.removeWhere((it) =&gt; it == 'c#');// b.retainAll(['e#']);// b.retainWhere((it) =&gt; it == 'e#');// b.retainWhere((it) &#123;// bool ret = it == 'e#';// return ret;// &#125;); 代码 set.dart 参考 language-tour Set © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 11 Map","date":"2018-10-23T07:36:12.000Z","path":"2018/10/23/dart/dart-11-map/","text":"本节目标 初始、声明 常用属性 常用方法 环境 Dart 2.0.0 初始key value 形式的集合 1var a = &#123;'name': 'ducafecat', 'web': 'www.ducafecat.tech'&#125;; 声明松散1234var a = new Map();a['name'] = 'ducafecat';a['web'] = 'www.ducafecat.tech';a[0] = 'abc'; 强类型123var b = new Map&lt;int, String&gt;();b[0] = 'java';b[1] = 'python'; 基本属性 名称 说明 isEmpty 是否为空 isNotEmpty 是否不为空 keys key 集合 values values 集合 length 个数 entries 加工数据入口 123456print(a.isEmpty);print(a.isNotEmpty);print(a.keys);print(a.values);print(a.length);print(a.entries); 常用方法 名称 说明 addAll 添加 addEntries 从入口添加 containsKey 按 key 查询 containsValue 按 value 查询 clear 清空 remove 删除某个 removeWhere 按条件删除 update 更新某个 updateAll 按条件更新 addAll1b.addAll(&#123;'first': 'java', 'second': 'python'&#125;); addEntries1b.addEntries(a.entries); containsKey1print(a.containsKey('name')); containsValue1print(a.containsValue('www.ducafecat.tech')); clear1b.clear(); remove1a.remove('name'); removeWhere1a.removeWhere((key,val) =&gt; key == 'name'); update1a.update('name', (val) =&gt; 'abc'); updateAll1a.updateAll((key, val) =&gt; \"---$val---\"); 操作符 名称 说明 [] 取值 []= 赋值 12print(a['name']);a['name'] = 'abc'; 代码 map.dart 参考 language-tour Map © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 10 列表","date":"2018-10-19T02:49:35.000Z","path":"2018/10/19/dart/dart-10-list/","text":"本节目标 初始、声明 常用属性 常用方法 环境 Dart 2.0.0 初始List 是一个有序列表 12var l = [1, 2, 3];print(l); 声明自动123456List&lt;int&gt; l = new List();l..add(1)..add(2)..add(3);print(l); 定长123456List&lt;int&gt; l = new List(3);// print(l[0]);l[0] = 1;l[1] = 2;l[2] = 3;print(l); 属性 名称 说明 isEmpty 是否为空 isNotEmpty 是否不为空 first 第一个对象 last 最后一个对象 length 个数 reversed 反转 1234567var l = [1, 2, 3];print(l.first);print(l.last);print(l.length);print(l.isEmpty);print(l.isNotEmpty);print(l.reversed); 方法 名称 说明 add 添加 addAll 添加多个 insert 插入 insertAll 插入多个 indexOf 查询 indexWhere 按条件查询 remove 删除 removeAt 按位置删除 fillRange 按区间填充 getRange 按区间获取 shuffle 随机变换顺序 sort 排序 sublist 创建子 添加12345678List&lt;int&gt; l = new List();l ..add(1) ..addAll([2, 3, 4, 5]) ..insert(0, 6) ..insertAll(6, [6, 6]) ; 查询12print(l.indexOf(5));print(l.indexWhere((it) =&gt; it == 4)); 删除1234l.remove(6);print(l);l.removeAt(5);print(l); Range12l.fillRange(0, 3, 9);print(l.getRange(0, 5)); 洗牌1234l.shuffle();print(l);l.shuffle();print(l); 排序12345678910111213数字l.sort();print(l);日期List&lt;DateTime&gt; dtList = new List();dtList.addAll([ DateTime.now(), DateTime.now().add(new Duration(days: -12)), DateTime.now().add(new Duration(days: -2)) ]);print(dtList);dtList.sort((a, b) =&gt; a.compareTo(b));print(dtList); 复制子列表123print(l);var l2 = l.sublist(1,4);print(l2); 操作符 名称 说明 + 连接 [] 取值 []= 赋值 12345var l1 = [1, 2, 3];var l2 = [4, 5, 6];print(l1 + l2);l1[2] = 9;print(l1[2]); 代码 list.dart 参考 language-tour List © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 09 日期时间","date":"2018-10-18T07:02:05.000Z","path":"2018/10/18/dart/dart-09-datetime/","text":"本节目标 声明 UTC 时间 公元时间 时间戳 解析标准时间 时间运算 环境 Dart 2.0.0 声明1234var now = new DateTime.now();print(now);var d = new DateTime(2018, 10, 10, 9, 30);print(d); 创建时间 UTC UTC 协调世界时 原子时 原子钟 12var d = new DateTime.utc(2018, 10, 10, 9, 30);print(d); 解析时间 IOS 8601 ISO 8601 时区 时区列表 1234var d1 = DateTime.parse('2018-10-10 09:30:30Z');print(d1);var d2 = DateTime.parse('2018-10-10 09:30:30+0800');print(d2); 时间增减量1234var d1 = DateTime.now();print(d1);print(d1.add(new Duration(minutes: 5)));print(d1.add(new Duration(minutes: -5))); 比较时间1234567var d1 = new DateTime(2018, 10, 1);var d2 = new DateTime(2018, 10, 10);print(d1.isAfter(d2));print(d1.isBefore(d2));var d1 = DateTime.now();var d2 = d1.add(new Duration(milliseconds: 30));print(d1.isAtSameMomentAs(d2)); 时间差1234var d1 = new DateTime(2018, 10, 1);var d2 = new DateTime(2018, 10, 10);var difference = d1.difference(d2);print([difference.inDays, difference.inHours]); 时间戳 公元 123var now = new DateTime.now();print(now.millisecondsSinceEpoch);print(now.microsecondsSinceEpoch); 代码 datetime.dart 参考 language-tour DateTime UTC 协调世界时 原子时 原子钟 ISO 8601 时区 时区列表 公元 © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 08 字符串","date":"2018-10-18T05:48:22.000Z","path":"2018/10/18/dart/dart-08-string/","text":"本节目标 声明方式 字符串模板 字符串连接 转义操作 其它常用运算 环境 Dart 2.0.0 单引号或者双引号12String a = 'ducafecat';String b = \"ducafecat\"; 字符串模板123var a = 123;String b = 'ducafecat : $&#123;a&#125;';print(b); 字符串连接123456789101112131415var a = 'hello' + ' ' + 'ducafecat';var a = 'hello'' ''ducafecat';var a = 'hello' ' ' 'ducafecat';var a = 'hello'' ''ducafecat';var a = '''hello wordthis is multi line''';var a = \"\"\"hello wordthis is multi line\"\"\";print(a); 转义符号12var a = 'hello word \\n this is multi line';print(a); 取消转义12var a = r'hello word \\n this is multi line';print(a); 搜索12345var a = 'web site ducafecat.tech';print(a.contains('ducafecat'));print(a.startsWith('web'));print(a.endsWith('tech'));print(a.indexOf('site')); 提取数据1234print(a.substring(0,5));var b = a.split(' ');print(b.length);print(b[0]); 大小写转换12print(a.toLowerCase());print(a.toUpperCase()); 裁剪 判断空字符串12print(' hello word '.trim());print(''.isEmpty); 替换部分字符1print('hello word word!'.replaceAll('word', 'ducafecat')); 字符串创建123456var sb = StringBuffer();sb..write('hello word!')..write('my')..write(' ')..writeAll(['web', 'site', 'https://ducafecat.tech']);print(sb.toString()); 代码 string.dart 参考 language-tour String © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 07 布尔","date":"2018-10-17T09:37:31.000Z","path":"2018/10/17/dart/dart-07-bool/","text":"本节目标 布尔 声明、比较、默认值 断言、asset、isEmpty、isNaN 逻辑操作符 &amp;&amp;、||、! 关系运算符 == != &gt; &gt;= &lt; &lt;= 环境 Dart 2.0.0 声明为了代表布尔值，Dart 有一个名字为 bool 的类型。 只有两个对象是布尔类型的：true 和 false 所创建的对象， 这两个对象也都是编译时常量。 bool 12bool a;print(a); 只有 true 对象才被认为是 true。 所有其他的值都是 flase。 1234String name = 'ducafecat';if(name) &#123; print('this is name');&#125; assert 断言123456789var a = true;assert(a);var name = '';assert(name.isEmpty);assert(name.isNotEmpty);var num = 0 / 0;assert(num.isNaN); 注意： 断言只在检查模式下运行有效，如果在生产模式 运行，则断言不会执行。 逻辑运算符&amp;&amp; 逻辑与123bool a = true;bool b = true;assert(a &amp;&amp; b); || 逻辑或123bool a = true;bool b = false;assert(a || b); ! 逻辑非123bool a = true;bool b = !a;print(b); 关系运算符== 等于1if(a == b) &#123;&#125; != 不等于1if(a != b) &#123;&#125; &gt; 大于1if(a &gt; b) &#123;&#125; &gt;= 大于或等于1if(a &gt;= b) &#123;&#125; &lt; 小于1if(a &lt; b) &#123;&#125; &lt;= 小于或等于1if(a &lt;= b) &#123;&#125; 代码 bool.dart 参考 language-tour bool © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 06 数值","date":"2018-10-16T09:08:33.000Z","path":"2018/10/16/dart/dart-06-number/","text":"本节目标 数值类型 int、double、num 数值表示法 十进制、十六进制 科学计数法 数值转换 位运算 环境 Dart 2.0.0 数值数值类型int整数值，其取值通常位于 -253 和 253 之间。 int class double64-bit (双精度) 浮点数，符合 IEEE 754 标准。 double class numint 和 double 都是 num 的子类。 num class 数值表示法 十进制、十六进制123int a = 1001;int b = 0xABC;print([a, b]); 科学计数法12num a = 21.2e3;print([a]); 数值转换123456789101112131415// string -&gt; int// string -&gt; doubleint a = int.parse('123');double b = double.parse('1.223');// int -&gt; string// double -&gt; stringString a = 123.toString();String b = 1.223.toString();print([a, b]);// double -&gt; intdouble a = 1.8;int b = a.toInt();print(b); 位运算&amp; 与运算同时 1 才行 12341 0 1 0 100 0 1 0 2--------0 0 1 0 2 123var a = 10;var b = 2;print(a &amp; b); | 或运算有一个 1 就行 12341 0 1 0 100 0 1 0 2--------1 0 1 0 10 123var a = 10;var b = 2;print(a | b); 可以用在常量组合 123456const USE_LEFT = 0x1;const USE_TOP = 0x2;const USE_LEFT_TOP = USE_LEFT | USE_TOP;var result = USE_LEFT | USE_TOP;print(result);assert(USE_LEFT_TOP == result); ~ 非运算二进制数逐位进行逻辑非运算 1234560 1 0 0 1 +9 二进制 最高位 0 整数 1 负数0 0 1 1 0 补码1 1 0 0 1 取反1 1 0 1 0 加1--------1 1 0 1 0 -10 12var a = 9;print(~a); ^ 异或不相同的才出 1 12341 0 1 0 100 0 1 0 2--------1 0 0 0 8 123var a = 10;var b = 2;print(a ^ b); 计算机中可以用来取反色 移位运算符&lt;&lt; 左移12340 0 0 1 1 二进制0 0 1 0 左移一位 20 1 0 0 左移一位 41 0 0 0 左移一位 8 向左移动一位 12var a = 1 &lt;&lt; 1;print(a); &gt;&gt; 右移12341 0 0 0 8 二进制0 1 0 0 右移一位 40 0 1 0 右移一位 20 0 0 1 右移一位 1 向右移动一位 12var a = 8 &gt;&gt; 1;print(a); 代码 number.dart 参考 language-tour int class double class num class © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 05 常量","date":"2018-10-10T06:49:26.000Z","path":"2018/10/10/dart/dart-05-constant/","text":"本节目标 常量的定义方式 final const 的区别 环境 Dart 2.0.0 定义类型声明可以省略12345final String a = 'ducafecat';final a = 'ducafecat';const String a = 'ducafecat';const a = 'ducafecat'; 初始后不能再赋值12345final a = 'ducafecat';a = 'abc';const a = 'ducafecat';a = 'abc'; 不能和 var 同时使用12final var a = 'ducafecat';const var a = 'ducafecat'; const 赋值 申明可省略12const List ls = const [11, 22, 33];const List ls = [11, 22, 33]; 区别需要确定的值123final dt = DateTime.now();const dt = const DateTime.now(); 不可变性可传递12345final List ls = [11, 22, 33];ls[1] = 44;const List ls = [11, 22, 33];ls[1] = 44; 内存中重复创建1234567final a1 = [11 , 22];final a2 = [11 , 22];print(identical(a1, a2));const a1 = [11 , 22];const a2 = [11 , 22];print(identical(a1, a2)); 代码 constant.dart 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 04 变量的两种类型","date":"2018-10-10T02:18:25.000Z","path":"2018/10/10/dart/dart-04-variables/","text":"本节目标 了解 弱类型 强类型 常见 强类型 有哪些 如何选着何时用那种类型 环境 Dart 2.0.0 弱类型var如果没有初始值，可以变成任何类型 123456var a;a = 'ducafecat';a = 123;a = true;a = &#123;'key': 'val123'&#125;;a = ['abc']; Object动态任意类型，编译阶段检查类型 1234Object a = 'doucafecat';a = 123;a = [2222];a.p(); dynamic动态任意类型，编译阶段不检查检查类型 1234dynamic a = 'doucafecat';a = 123;a = [1111];a.p(); 比较 var 与 dynamic、Object唯一区别 var 如果有初始值，类型被锁定 1234var a = 'ducafecat';dynamic a = 'doucafecat';Object a = 'doucafecat';a = 123; 强类型申明类型声明后，类型被锁定 123String a;a = 'ducafecat';a = 123; 常见类型 名称 说明 num 数字 int 整型 double 浮点 bool 布尔 String 字符串 StringBuffer 字符串 buffer DateTime 时间日期 Duration 时间区间 List 列表 Sets 无重复队列 Maps kv 容器 enum 枚举 123456String a = 'doucafecat';int i = 123;double d = 0.12;bool b = true;DateTime dt = new DateTime.now();List l = [ a, i, d, b, dt]; 默认值一切都是 Object , 变量声明后默认都是 null 1234var a;String a;print(a);assert(a == null); assert 检查点函数，如果不符合条件直接抛出错误并终止程序进程 如何使用 在写 API 接口的时候，请用 强类型，一旦不符合约定，接收数据时能方便排查故障 你在写个小工具时，可以用 弱类型，这样代码写起来很快，类型自动适应 代码 variables.dart 参考 language-tour © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 03 MacOS 下安装 SDK","date":"2018-09-30T07:41:49.000Z","path":"2018/09/30/dart/dart-03-install-macos/","text":"本节目标 配置 Dart 开发环境 解决墙内问题 环境 MacOS Dart SDK 2.0.0 下载 SDKSDK 列表 archive 下载 URL1https://storage.googleapis.com/dart-archive/channels/stable/release/2.0.0/sdk/dartsdk-macos-x64-release.zip 墙内请替换域名 storage.flutter-io.cn 替换后 URL1https://storage.flutter-io.cn/dart-archive/channels/stable/release/2.0.0/sdk/dartsdk-macos-x64-release.zip 解压到磁盘 磁盘位置 ~/Documents/sdk/dart-sdk 配置 VSCode IDE下载链接安装 Dart 插件编写 HelloWord 新建目录 dart-learn 编写文件 hello.dart 123void main() &#123; print('hello word!');&#125; 调试运行配置文件 launch.json 1234567891011121314&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"Dart\", \"program\": \"$&#123;file&#125;\", \"request\": \"launch\", \"type\": \"dart\" &#125; ]&#125; 配置命令行模式设置环境变量12345678# 打开配置文件vim ~/.bash_profile# 尾部加入配置export PATH=~/Documents/sdk/dart-sdk/bin:$PATH# 重载配置文件source ~/.bash_profile 测试 新开命令行窗口 12dart --versionDart VM version: 2.0.0 (Fri Aug 3 10:53:23 2018 +0200) on \"macos_x64\" 参考 Dart SDK Archive Using-Flutter-in-China © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 02 Windows 下安装 SDK","date":"2018-09-30T06:41:49.000Z","path":"2018/09/30/dart/dart-02-install-windows/","text":"本节目标 配置 Dart 开发环境 解决墙内问题 环境 Windows 10 Dart SDK 2.0.0 下载 SDKSDK 列表 archive 源下载 URL1https://storage.googleapis.com/dart-archive/channels/stable/release/2.0.0/sdk/dartsdk-windows-x64-release.zip 墙内请替换域名 storage.flutter-io.cn 替换后 URL1https://storage.flutter-io.cn/dart-archive/channels/stable/release/2.0.0/sdk/dartsdk-windows-x64-release.zip 解压到磁盘 磁盘位置 C:\\sdk\\dart-sdk 配置 VSCode IDE下载链接安装 Dart 插件编写 HelloWord 新建目录 dart-learn 编写文件 hello.dart 123void main() &#123; print('hello word!');&#125; 调试运行配置文件 launch.json 1234567891011121314&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"Dart\", \"program\": \"$&#123;file&#125;\", \"request\": \"launch\", \"type\": \"dart\" &#125; ]&#125; 配置命令行模式设置环境变量 环境变量 PATH 新增 C:\\sdk\\dart-sdk\\bin 测试 新开命令行窗口 12dart --versionDart VM version: 2.0.0 (Fri Aug 3 10:53:23 2018 +0200) on \"windows_x64\" 参考 Dart SDK Archive Using-Flutter-in-China © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]},{"title":"Dart语言学习 - 01 前言","date":"2018-09-30T02:00:48.000Z","path":"2018/09/30/dart/dart-01-introduce/","text":"本节目标 为什么学习 Dart 课程计划 如果获取课程资料、代码、视频 2018 Google 开发者大会大会官网 首页简介 bilibili 视频 介绍视频 Flutter官网 Flutter Dart官网 homepage 多平台开发 Platforms 课程计划12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879## 前言## 安装&amp;配置 - Windows## 安装&amp;配置 - MacOS## 变量 - 两种方式## 变量 - 常量## 类型 - 数字## 类型 - Bool## 类型 - 字符串## 类型 - 日期## 类型 - List## 类型 - Map## 类型 - Set## 类型 - Runes## 类型 - Symbol## 类型 - Enum## 注释 - Comments## 函数## 操作符## 流程控制## 异常## 类 - Class## 类 - getter、setter## 类 - 静态变量、方法## 类 - Abstract 抽象类、方法## 类 - Interface 接口## 类 - extends 继承## 类 - mixin 混合## 类 - 工厂构造函数## 类库 - Libraries## 泛型 - Generics## 异步 - Asynchrony## 生成器 - Generators## 可调用 - Callable## 隔离 - Isolate## 类型定义 - Typedef## 注解 - Metadata## 代码规范 - 代码风格## 代码规范 - 文档注释## 代码规范 - 最佳实践## 代码规范 - 设计指南 课程资料主站 https://ducafecat.tech资料 视频 youtube 优酷 文档 \b代码 参考 Dart 官网 Flutter 官网 2018 Google 开发者大会 bilibili © 猫哥 https://ducafecat.tech","tags":[{"name":"dart","slug":"dart","permalink":"https://blog.ducafecat.tech/tags/dart/"}]}]